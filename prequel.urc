CLASS `ResourceIds:

  METHOD_INIT():
    THIS.`_ids = []
    THIS.`_cur_id = `trunc(0.5+`random()*1000)
    THIS.`_free_ids = []

  METHOD `alloc():
    VAR `an_id
    IF `length(THIS.`_free_ids) > 0:
      `an_id = `pop(THIS.`_free_ids)
    ELSE:
      `an_id = THIS.`_cur_id
      THIS.`_cur_id += 1
    ENDIF
    `queue(THIS.`_ids, `an_id)
    return `an_id

  METHOD `free(`an_id):
    VAR `index = `indexof(THIS.`_ids, `an_id)
    IF `index < 0:
      `warning("Prequel"+" "+"ResourceIds"+" "+"free"+":"+" "+"id"+" "+"does"+" "+"not"+" "+"exist"+":", `an_id)
      return
    ENDIF
    `push(THIS.`_free_ids, THIS.`_ids[`index])
    `pick(THIS.`_ids, `index)

ENDCLASS

VAR `ARG_TYPE_INTEGER = 0
VAR `ARG_TYPE_LIST = 1
VAR `ARG_TYPE_STRING = 2
VAR `ARG_TYPE_VARNAME = 3
VAR `ARG_TYPE_MODNAME = 4

VAR `key_limits_instructions = 0
VAR `key_limits_max_memory = 1
VAR `key_limits_memory = 2
VAR `key_limits_memory_i = 3
VAR `key_limits_memory_l = 4
VAR `key_limits_time = 5

VAR `key_interp_boolean = 0
VAR `key_interp_by_ref = 1
VAR `key_interp_integer = 2
VAR `key_interp_list = 3
VAR `key_interp_module_name = 4
VAR `key_interp_procedure = 5
VAR `key_interp_string = 6

CLASS `Utils:

  METHOD_INIT():
    VAR `x = NULL

  METHOD `deepCopy(`val):
    VAR `val_type = `get_type(`val)
    VAR `arr
    VAR `obj
    VAR `j
    VAR `k
    IF `is_type_list(`val_type):
      `arr = []
      FORINCR `j(0 `length(`val)):
        `push(`arr, THIS.`deepCopy(`val[`j]))
      ENDFOR
      return `arr
    ENDIF
    IF `is_type_dict(`val_type):
      `obj = {}
      FOREACH `k(`val):
        `obj[`k] = THIS.`deepCopy(`val[`k])
      ENDFOR
      return `obj
    ENDIF
    return `val

  METHOD `isValidErrorMessage(`error_message):
    IF `not(`is_type_str(`get_type(`error_message))):
      return FALSE
    ENDIF
    IF `length(`error_message) == 0:
      return FALSE
    ENDIF
    IF `length(`error_message) != `length(`strip(`error_message)):
      return FALSE
    ENDIF
    VAR `j
    VAR `code
    FORINCR `j(0 `length(`error_message)):
      `code = `char_code_at(`error_message, `j)
      IF (`code < 32) OR (`code > 126):
        return FALSE
      ENDIF
    ENDFOR
    return TRUE

  METHOD `isValidArgsSynopsis(`args_synopsis):
    IF `not(`is_type_list(`get_type(`args_synopsis))):
      return FALSE
    ENDIF
    VAR `j
    FORINCR `j(0 `length(`args_synopsis)):
      IF `not(THIS.`isValidErrorMessage(`args_synopsis[`j])):
        return FALSE
      ENDIF
    ENDFOR
    return TRUE

  METHOD `isInt32b(`val):
    return (`is_type_num(`get_type(`val)) AND `trunc(`val) == `val AND `val >= -2147483648 AND `val <= 2147483647)

  METHOD `isArgData(`arg):
    return (`is_type_list(`get_type(`arg)) AND `length(`arg) == 2 AND `is_type_num(`get_type(`arg[0])) AND `arg[0] >= `ARG_TYPE_INTEGER AND `arg[0] <= `ARG_TYPE_MODNAME)

  METHOD `getNormalizedLimits(`limits_):
    VAR `limits = {}
    `limits[`key_limits_instructions] = NULL
    `limits[`key_limits_memory] = NULL
    `limits[`key_limits_memory_i] = NULL
    `limits[`key_limits_memory_l] = NULL
    `limits[`key_limits_time] = NULL
    IF `is_type_dict(`get_type(`limits_)):
      IF "instructions" in `limits_:
        IF `not(THIS.`isInt32b(`limits_["instructions"])):
          return NULL
        ENDIF
        `limits[`key_limits_instructions] = `limits_["instructions"]
      ENDIF
      IF "memory" in `limits_:
        IF `not(THIS.`isInt32b(`limits_["memory"])):
          return NULL
        ENDIF
        `limits[`key_limits_memory] = `limits_["memory"]
      ENDIF
      IF "memory_i" in `limits_:
        IF `not(THIS.`isInt32b(`limits_["memory_i"])):
          return NULL
        ENDIF
        `limits[`key_limits_memory_i] = `limits_["memory_i"]
      ENDIF
      IF "memory_l" in `limits_:
        IF `not(THIS.`isInt32b(`limits_["memory_l"])):
          return NULL
        ENDIF
        `limits[`key_limits_memory_l] = `limits_["memory_l"]
      ENDIF
      IF "time" in `limits_:
        IF `not(THIS.`isInt32b(`limits_["time"])):
          return NULL
        ENDIF
        `limits[`key_limits_time] = `limits_["time"]
      ENDIF
    ELSIF `not(`isnull(`limits_)):
      return NULL
    ENDIF
    return `limits

  METHOD `setNormalizedLimits(`limits_):
    VAR `limits = {}
    `limits["instructions"] = `limits_[`key_limits_instructions]
    `limits["max_memory"] = `limits_[`key_limits_max_memory]
    `limits["memory"] = `limits_[`key_limits_memory]
    `limits["memory_i"] = `limits_[`key_limits_memory_i]
    `limits["memory_l"] = `limits_[`key_limits_memory_l]
    `limits["time"] = `limits_[`key_limits_time]
    return `limits

  METHOD `elemEqElem(`xs `ys):
    VAR `j
    IF `is_type_list(`get_type(`xs)):
      IF `not(`is_type_list(`get_type(`ys))):
        return FALSE
      ENDIF
      IF `length(`xs) != `length(`ys):
        return FALSE
      ENDIF
      FORINCR `j(0 `length(`xs)):
        IF `not(THIS.`elemEqElem(`xs[`j], `ys[`j])):
          return FALSE
        ENDIF
      ENDFOR
      return TRUE
    ENDIF
    IF `is_type_list(`get_type(`ys)):
      return FALSE
    ENDIF
    return (`xs == `ys)

  METHOD `structuralIndexOf(`l `e `from):
    VAR `j
    IF `from >= 0:
      FORINCR `j(`from `length(`l)):
        IF THIS.`elemEqElem(`l[`j], `e):
          return `j
        ENDIF
      ENDFOR
    ELSE:
      FORDECR `j(`length(`l)+`from 0):
        IF THIS.`elemEqElem(`l[`j], `e):
          return `j
        ENDIF
      ENDFOR
    ENDIF
    return -1

  METHOD `isizeEvalue(`evalue):
    return `evalue[3]

  METHOD `lsizeEvalue(`evalue):
    return `evalue[2]

  METHOD `encodeProcedure(`args_synopsis):
    IF `not(THIS.`isValidArgsSynopsis(`args_synopsis)):
      return NULL
    ENDIF
    return [`key_interp_procedure, THIS.`deepCopy(`args_synopsis)]

  METHOD `encodeData(`data):
    VAR `data_type = `get_type(`data)
    VAR `isize
    VAR `lsize
    VAR `elist
    VAR `evalue
    IF `is_type_num(`data_type) OR `is_type_bool(`data_type):
      `isize = 1
      `lsize = 0
      return [`key_interp_integer, `trunc(`data), `lsize, `isize]
    ENDIF
    VAR `j
    IF `is_type_list(`data_type):
      `isize = 0
      `lsize = 1
      `elist = []
      FORINCR `j(0 `length(`data)):
        `evalue = THIS.`encodeData(`data[`j])
        IF `isnull(`evalue):
          return NULL
        ENDIF
        `push(`elist, `evalue)
        `isize += THIS.`isizeEvalue(`evalue)
        `lsize += THIS.`lsizeEvalue(`evalue)
      ENDFOR
      return [`key_interp_list, `elist, `lsize, `isize]
    ENDIF
    `warning("Prequel"+" "+"Utils"+" "+"encodeData"+":"+" "+"invalid"+" "+"data"+":", `data)
    return NULL

  METHOD `encodeOverwriteData(`evalue `data):
    VAR `data_type = `get_type(`data)
    VAR `isize
    VAR `lsize
    VAR `elist
    VAR `j
    VAR `evalueE
    IF `is_type_num(`data_type) OR `is_type_bool(`data_type):
      IF `length(`evalue) == 0:
        `isize = 1
        `lsize = 0
        `push(`evalue, `key_interp_integer)
        `push(`evalue, `trunc(`data))
        `push(`evalue, `lsize)
        `push(`evalue, `isize)
      ELSE:
        IF `evalue[0] != `key_interp_integer:
          `isize = 1
          `lsize = 0
          `evalue[0] = `key_interp_integer
          `evalue[2] = `lsize
          `evalue[3] = `isize
        ENDIF
        `evalue[1] = `trunc(`data)
      ENDIF
      return TRUE
    ENDIF
    IF `is_type_list(`data_type):
      `isize = 0
      `lsize = 1
      IF `length(`evalue) == 0:
        `elist = []
        FORINCR `j(0 `length(`data)):
          `evalueE = THIS.`encodeData(`data[`j])
          IF `isnull(`evalueE):
            return FALSE
          ENDIF
          `push(`elist, `evalueE)
          `isize += THIS.`isizeEvalue(`evalueE)
          `lsize += THIS.`lsizeEvalue(`evalueE)
        ENDFOR
        `push(`evalue, `key_interp_list)
        `push(`evalue, `elist)
        `push(`evalue, `lsize)
        `push(`evalue, `isize)
      ELSIF `evalue[0] != `key_interp_list:
        `elist = []
        FORINCR `j(0 `length(`data)):
          `evalueE = THIS.`encodeData(`data[`j])
          IF `isnull(`evalueE):
            return FALSE
          ENDIF
          `push(`elist, `evalueE)
          `isize += THIS.`isizeEvalue(`evalueE)
          `lsize += THIS.`lsizeEvalue(`evalueE)
        ENDFOR
        `evalue[0] = `key_interp_list
        `evalue[1] = `elist
        `evalue[2] = `lsize
        `evalue[3] = `isize
      ELSE:
        IF `length(`evalue[1]) == `length(`data):
          FORINCR `j(0 `length(`data)):
            IF `not(THIS.`encodeOverwriteData(`evalue[1][`j], `data[`j])):
              return FALSE
            ENDIF
            `isize += THIS.`isizeEvalue(`evalue[1][`j])
            `lsize += THIS.`lsizeEvalue(`evalue[1][`j])
          ENDFOR
        ELSIF `length(`evalue[1]) > `length(`data):
          FORDECR `j(`length(`evalue[1])-`length(`data)-1 0):
            `pick(`evalue[1], `length(`data))
          ENDFOR
          FORINCR `j(0 `length(`data)):
            IF `not(THIS.`encodeOverwriteData(`evalue[1][`j], `data[`j])):
              return FALSE
            ENDIF
            `isize += THIS.`isizeEvalue(`evalue[1][`j])
            `lsize += THIS.`lsizeEvalue(`evalue[1][`j])
          ENDFOR
        ELSE:
          FORINCR `j(0 `length(`evalue[1])):
            IF `not(THIS.`encodeOverwriteData(`evalue[1][`j], `data[`j])):
              return FALSE
            ENDIF
            `isize += THIS.`isizeEvalue(`evalue[1][`j])
            `lsize += THIS.`lsizeEvalue(`evalue[1][`j])
          ENDFOR
          FORINCR `j(`length(`evalue[1]) `length(`data)):
            `evalueE = THIS.`encodeData(`data[`j])
            IF `isnull(`evalueE):
              return FALSE
            ENDIF
            `push(`evalue[1], `evalueE)
            `isize += THIS.`isizeEvalue(`evalueE)
            `lsize += THIS.`lsizeEvalue(`evalueE)
          ENDFOR
        ENDIF
        `evalue[2] = `lsize
        `evalue[3] = `isize
      ENDIF
      return TRUE
    ENDIF
    `warning("Prequel"+" "+"Utils"+" "+"encodeOverwriteData"+":"+" "+"invalid"+" "+"data"+":", `data)
    return FALSE

  METHOD `decodeData(`edata):
    VAR `dlist
    VAR `j
    VAR `dvalue
    IF `not(`is_type_list(`get_type(`edata))) OR `length(`edata) < 2:
      `warning("Prequel"+" "+"Utils"+" "+"decodeData"+":"+" "+"invalid"+" "+"data"+":", `edata)
      return NULL
    ENDIF
    IF `edata[0] == `key_interp_integer:
      return [`ARG_TYPE_INTEGER, `trunc(`edata[1])]
    ENDIF
    IF `edata[0] == `key_interp_list:
      IF `not(`is_type_list(`get_type(`edata[1]))):
        `warning("Prequel"+" "+"Utils"+" "+"decodeData"+":"+" "+"invalid"+" "+"data"+":", `edata)
        return NULL
      ENDIF
      `dlist = []
      FORINCR `j(0 `length(`edata[1])):
        `dvalue = THIS.`decodeData(`edata[1][`j])
        IF `isnull(`dvalue):
          return NULL
        ENDIF
        `push(`dlist, `dvalue[1])
      ENDFOR
      return [`ARG_TYPE_LIST, `dlist]
    ENDIF
    IF `edata[0] == `key_interp_by_ref:
      IF `not(`is_type_list(`get_type(`edata[1]))) OR `length(`edata[1]) <= 0:
        `warning("Prequel"+" "+"Utils"+" "+"decodeData"+":"+" "+"invalid"+" "+"data"+":", `edata)
        return NULL
      ENDIF
      IF `not(`is_type_str(`get_type(`edata[1][0]))):
        `warning("Prequel"+" "+"Utils"+" "+"decodeData"+":"+" "+"invalid"+" "+"data"+":", `edata)
        return NULL
      ENDIF
      `dlist = [`edata[1][0]]
      FORINCR `j(1 `length(`edata[1])):
        `push(`dlist, `trunc(`edata[1][`j]))
      ENDFOR
      return [`ARG_TYPE_VARNAME, `dlist]
    ENDIF
    IF `edata[0] == `key_interp_module_name:
      IF `not(`is_type_str(`get_type(`edata[1]))):
        `warning("Prequel"+" "+"Utils"+" "+"decodeData"+":"+" "+"invalid"+" "+"data"+":", `edata)
        return NULL
      ENDIF
      return [`ARG_TYPE_MODNAME, `edata[1]]
    ENDIF
    IF `edata[0] == `key_interp_string:
      IF `not(`is_type_str(`get_type(`edata[1]))):
        `warning("Prequel"+" "+"Utils"+" "+"decodeData"+":"+" "+"invalid"+" "+"data"+":", `edata)
        return NULL
      ENDIF
      return [`ARG_TYPE_STRING, `edata[1]]
    ENDIF
    `warning("Prequel"+" "+"Utils"+" "+"decodeData"+":"+" "+"invalid"+" "+"data"+":", `edata)
    return NULL

  METHOD `stringify(`evalue):
    VAR `lstr
    VAR `j
    IF `isnull(`evalue):
      return "<NULL>"
    ENDIF
    IF `evalue[0] == `key_interp_integer:
      return `str(`evalue[1])
    ENDIF
    IF `evalue[0] == `key_interp_list:
      IF `length(`evalue[1]) == 0:
        return "[]"
      ENDIF
      `lstr = "["
      `lstr += THIS.`stringify(`evalue[1][0])
      FORINCR `j(1 `length(`evalue[1])):
        `lstr += ","+" "+THIS.`stringify(`evalue[1][`j])
      ENDFOR
      `lstr += "]"
      return `lstr
    ENDIF
    IF `evalue[0] == `key_interp_boolean:
      return TERNARY{`evalue[1]}{"<TRUE>"}{"<FALSE>"}
    ENDIF
    IF `evalue[0] == `key_interp_procedure:
      return "<PROCEDURE>"
    ENDIF
    `warning("Prequel"+" "+"Utils"+" "+"stringify"+":"+" "+"unknown"+" "+"value"+":", `evalue)
    return "<UNKNOWN>"

ENDCLASS

VAR `utils = NEW `Utils()

CLASS `Lexer:

  METHOD_INIT():
    THIS.`_reserved_words = []
    `push(THIS.`_reserved_words, "IF")
    `push(THIS.`_reserved_words, "ELSIF")
    `push(THIS.`_reserved_words, "ELSE")
    `push(THIS.`_reserved_words, "ENDIF")
    `push(THIS.`_reserved_words, "REPEAT")
    `push(THIS.`_reserved_words, "REPSTOP")
    `push(THIS.`_reserved_words, "REPNEXT")
    `push(THIS.`_reserved_words, "ENDREP")
    `push(THIS.`_reserved_words, "LOG")
    `push(THIS.`_reserved_words, "OR")
    `push(THIS.`_reserved_words, "AND")
    `push(THIS.`_reserved_words, "NOT")
    `push(THIS.`_reserved_words, "IS")
    `push(THIS.`_reserved_words, "INTEGER")
    `push(THIS.`_reserved_words, "LIST")
    `push(THIS.`_reserved_words, "PROCEDURE")
    `push(THIS.`_reserved_words, "RANDOM")
    `push(THIS.`_reserved_words, "UNDEFINED")

    THIS.`_reserved_vlast_words = []
    `push(THIS.`_reserved_vlast_words, "UNASSIGN")
    `push(THIS.`_reserved_vlast_words, "LENGTH")
    `push(THIS.`_reserved_vlast_words, "SIZE")
    `push(THIS.`_reserved_vlast_words, "ISIZE")
    `push(THIS.`_reserved_vlast_words, "LSIZE")
    `push(THIS.`_reserved_vlast_words, "PUSH")
    `push(THIS.`_reserved_vlast_words, "QUEUE")
    `push(THIS.`_reserved_vlast_words, "POP")
    `push(THIS.`_reserved_vlast_words, "UNQUEUE")
    `push(THIS.`_reserved_vlast_words, "INDEXOF")

    THIS.`_reserved_qlast_words = []
    `push(THIS.`_reserved_qlast_words, "LENGTH")
    `push(THIS.`_reserved_qlast_words, "SIZE")
    `push(THIS.`_reserved_qlast_words, "ISIZE")
    `push(THIS.`_reserved_qlast_words, "LSIZE")
    `push(THIS.`_reserved_qlast_words, "INDEXOF")

  METHOD `isCompoundToken(`token):
    return (`indexof(THIS.`_reserved_vlast_words, `token) >= 0)

  METHOD `isModuleNameCharStart(`c):
    return (((`c >= "a") AND (`c <= "z")) OR ((`c >= "A") AND (`c <= "Z")) OR (`c == "_"))

  METHOD `isModuleNameChar(`c):
    return (((`c >= "0") AND (`c <= "9")) OR ((`c >= "a") AND (`c <= "z")) OR ((`c >= "A") AND (`c <= "Z")) OR (`c == "_") OR (`c == "."))

  METHOD `isValidModuleName(`module_name):
    VAR `j
    IF `not(`is_type_str(`get_type(`module_name))):
      return FALSE
    ENDIF
    IF `length(`module_name) == 0:
      return FALSE
    ENDIF
    IF `not(THIS.`isModuleNameCharStart(`module_name[0])):
      return FALSE
    ENDIF
    FORINCR `j(1 `length(`module_name)):
      IF `not(THIS.`isModuleNameChar(`module_name[`j])):
        return FALSE
      ENDIF
    ENDFOR
    return TRUE

  METHOD `isValidSourceCode(`source_code):
    VAR `j
    VAR `chrcode_j
    IF `not(`is_type_str(`get_type(`source_code))):
      return FALSE
    ENDIF
    FORINCR `j(0 `length(`source_code)):
      `chrcode_j = `char_code_at(`source_code, `j)
      IF `chrcode_j != 9 AND `chrcode_j != 10 AND `chrcode_j != 13 AND (`chrcode_j < 32 OR `chrcode_j > 126):
        return FALSE
      ENDIF
    ENDFOR
    return TRUE

  METHOD `normalize(`source_code):
    VAR `splits
    VAR `j
    `splits = `split(`source_code, `chr_tab)
    `source_code = `splits[0]
    FORINCR `j(1 `length(`splits)):
      `source_code += " "+`splits[`j]
    ENDFOR
    `splits = `split(`source_code, `chr_cr)
    `source_code = `splits[0]
    FORINCR `j(1 `length(`splits)):
      `source_code += `splits[`j]
    ENDFOR
    return `source_code

  METHOD `tokenName(`token):
    return `token[0]

  METHOD `tokenColumn(`token):
    return `token[1]

  METHOD `tokenValue(`token):
    return `token[2]

  METHOD `tokenExtra(`token):
    IF `length(`token) <= 3:
      return NULL
    ENDIF
    return `token[3]

  METHOD `memberOf(`s `i `e `l):
    VAR `len_
    VAR `isEq
    VAR `j
    VAR `j2
    `len_ = `e-`i
    FORINCR `j(0 `length(`l)):
      IF `length(`l[`j]) != `len_:
        continue
      ENDIF
      `isEq = TRUE
      FORINCR `j2(0 `len_):
        IF `s[`i+`j2] != `l[`j][`j2]:
          `isEq = FALSE
          break
        ENDIF
      ENDFOR
      IF `isEq:
        return TRUE
      ENDIF
    ENDFOR
    return FALSE

  METHOD `isValidVarname(`varname):
    IF `not(`is_type_str(`get_type(`varname))):
      return FALSE
    ENDIF
    IF `length(`varname) == 0:
      return FALSE
    ENDIF
    IF ((`varname[0] < "a") OR (`varname[0] > "z")) AND ((`varname[0] < "A") OR (`varname[0] > "Z")) AND (`varname[0] != "_"):
      return FALSE
    ENDIF
    VAR `dotCount
    VAR `lastDotIdx
    VAR `startIdx
    VAR `j
    `dotCount = 0
    FORINCR `j(1 `length(`varname)):
      IF `varname[`j] == ".":
        `startIdx = TERNARY{`dotCount == 0}{0}{`lastDotIdx+1}
        IF `j-`startIdx == 0:
          return FALSE
        ENDIF
        IF `varname[`startIdx] >= "0" AND `varname[`startIdx] <= "9":
          return FALSE
        ENDIF
        IF THIS.`memberOf(`varname, `startIdx, `j, THIS.`_reserved_words):
          return FALSE
        ENDIF
        IF THIS.`memberOf(`varname, `startIdx, `j, THIS.`_reserved_vlast_words):
          return FALSE
        ENDIF
        `dotCount += 1
        `lastDotIdx = `j
        continue
      ENDIF
      IF ((`varname[`j] >= "0") AND (`varname[`j] <= "9")) OR ((`varname[`j] >= "a") AND (`varname[`j] <= "z")) OR ((`varname[`j] >= "A") AND (`varname[`j] <= "Z")) OR (`varname[`j] == "_"):
        continue
      ENDIF
      return FALSE
    ENDFOR
    `startIdx = TERNARY{`dotCount == 0}{0}{`lastDotIdx+1}
    IF `length(`varname)-`startIdx == 0:
      return FALSE
    ENDIF
    IF `varname[`startIdx] >= "0" AND `varname[`startIdx] <= "9":
      return FALSE
    ENDIF
    IF THIS.`memberOf(`varname, `startIdx, `length(`varname), THIS.`_reserved_words):
      return FALSE
    ENDIF
    IF THIS.`memberOf(`varname, `startIdx, `length(`varname), THIS.`_reserved_vlast_words):
      return FALSE
    ENDIF
    return TRUE

  METHOD `isValidIvarname(`ivarname):
    IF `not(`is_type_str(`get_type(`ivarname))):
      return FALSE
    ENDIF
    IF `length(`ivarname) == 0:
      return FALSE
    ENDIF
    IF ((`ivarname[0] < "a") OR (`ivarname[0] > "z")) AND ((`ivarname[0] < "A") OR (`ivarname[0] > "Z")) AND (`ivarname[0] != "_"):
      return FALSE
    ENDIF
    VAR `j
    FORINCR `j(1 `length(`ivarname)):
      IF ((`ivarname[`j] >= "0") AND (`ivarname[`j] <= "9")) OR ((`ivarname[`j] >= "a") AND (`ivarname[`j] <= "z")) OR ((`ivarname[`j] >= "A") AND (`ivarname[`j] <= "Z")) OR (`ivarname[`j] == "_"):
        continue
      ENDIF
      return FALSE
    ENDFOR
    IF THIS.`memberOf(`ivarname, 0, `length(`ivarname), THIS.`_reserved_words):
      return FALSE
    ENDIF
    IF THIS.`memberOf(`ivarname, 0, `length(`ivarname), THIS.`_reserved_vlast_words):
      return FALSE
    ENDIF
    return TRUE

  METHOD `isVarChar(`c):
    return (((`c >= "0") AND (`c <= "9")) OR ((`c >= "a") AND (`c <= "z")) OR ((`c >= "A") AND (`c <= "Z")) OR (`c == "_") OR (`c == "."))

  METHOD `isTokenEndSpace(`l `start `token):
    VAR `j
    FORINCR `j(0 `length(`token)):
      IF `l[`start+`j] != `token[`j]:
        return FALSE
      ENDIF
    ENDFOR
    return (`l[`start+`length(`token)] == " ")

  METHOD `isTokenEndOther(`l `start `token):
    VAR `j
    FORINCR `j(0 `length(`token)):
      IF `l[`start+`j] != `token[`j]:
        return FALSE
      ENDIF
    ENDFOR
    return `not(THIS.`isVarChar(`l[`start+`length(`token)]))

  METHOD `lexLine(`line):
    `line += " "+`chr_lf
    VAR `tname
    VAR `textra
    VAR `col = 0
    VAR `start
    WHILE `line[`col] == " ":
      `col += 1
    ENDWHILE
    IF `line[`col] == `chr_lf:
      return [["INDENT", 0, `substring(`line, 0, `col-1)], ["NEWLINE", `length(`line)-2, `chr_lf]]
    ENDIF
    VAR `tokens = []
    VAR `nonzero
    VAR `j
    VAR `subtextras
    VAR `error_msg
    VAR `var_op
    `push(`tokens, ["INDENT", 0, `substring(`line, 0, `col)])
    WHILE TRUE:
      IF `line[`col] == " ":
        `start = `col
        WHILE `line[`col] == " ":
          `col += 1
        ENDWHILE
        IF `line[`col] == `chr_lf:
          IF `col-`start == 1:
            break
          ENDIF
          `push(`tokens, ["SPACES", `start, `substring(`line, `start, `col-1)])
          break
        ENDIF
        `push(`tokens, ["SPACES", `start, `substring(`line, `start, `col)])
      ENDIF
      IF `line[`col] == "I":
        `tname = "IF"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `push(`tokens, ["IF", `col, `tname])
          `col += `length(`tname)
          continue
        ENDIF
        `tname = "IS"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `tname = "NOT"
          IF THIS.`isTokenEndSpace(`line, `col+3, `tname):
            `tname = "IS_NOT"
            `push(`tokens, ["IS_NOT", `col, `substring(`line, `col, `col+`length(`tname))])
            `col += `length(`tname)
            continue
          ENDIF
          `tname = "IS"
          `push(`tokens, ["IS", `col, `tname])
          `col += `length(`tname)
          continue
        ENDIF
        `tname = "INTEGER"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `push(`tokens, ["INTEGER", `col, `tname])
          `col += `length(`tname)
          continue
        ENDIF
      ENDIF
      IF `line[`col] == "R":
        `tname = "REPEAT"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `push(`tokens, ["REPEAT", `col, `tname])
          `col += `length(`tname)
          continue
        ENDIF
        `tname = "REPNEXT"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `push(`tokens, ["REPNEXT", `col, `tname])
          `col += `length(`tname)
          continue
        ENDIF
        `tname = "REPSTOP"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `push(`tokens, ["REPSTOP", `col, `tname])
          `col += `length(`tname)
          continue
        ENDIF
        `tname = "RANDOM"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `push(`tokens, ["RANDOM", `col, `tname])
          `col += `length(`tname)
          continue
        ENDIF
      ENDIF
      IF `line[`col] == "L":
        `tname = "LOG"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `push(`tokens, ["LOG", `col, `tname])
          `col += `length(`tname)
          continue
        ENDIF
        `tname = "LIST"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `push(`tokens, ["LIST", `col, `tname])
          `col += `length(`tname)
          continue
        ENDIF
      ENDIF
      IF `line[`col] == "A":
        `tname = "AND"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `push(`tokens, ["AND", `col, `tname])
          `col += `length(`tname)
          continue
        ENDIF
      ENDIF
      IF `line[`col] == "P":
        `tname = "PROCEDURE"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `push(`tokens, ["PROCEDURE", `col, `tname])
          `col += `length(`tname)
          continue
        ENDIF
      ENDIF
      IF `line[`col] == "E":
        `tname = "ENDIF"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `push(`tokens, ["ENDIF", `col, `tname])
          `col += `length(`tname)
          continue
        ENDIF
        `tname = "ENDREP"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `push(`tokens, ["ENDREP", `col, `tname])
          `col += `length(`tname)
          continue
        ENDIF
        `tname = "ELSE"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `push(`tokens, ["ELSE", `col, `tname])
          `col += `length(`tname)
          continue
        ENDIF
        `tname = "ELSIF"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `push(`tokens, ["ELSIF", `col, `tname])
          `col += `length(`tname)
          continue
        ENDIF
      ENDIF
      IF `line[`col] == "N":
        `tname = "NOT"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `push(`tokens, ["NOT", `col, `tname])
          `col += `length(`tname)
          continue
        ENDIF
      ENDIF
      IF `line[`col] == "O":
        `tname = "OR"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `push(`tokens, ["OR", `col, `tname])
          `col += `length(`tname)
          continue
        ENDIF
      ENDIF
      IF `line[`col] == "U":
        `tname = "UNDEFINED"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `push(`tokens, ["UNDEFINED", `col, `tname])
          `col += `length(`tname)
          continue
        ENDIF
      ENDIF
      IF `line[`col] == ":":
        IF `line[`col+1] == "=":
          `push(`tokens, ["ASSIGN_OP", `col, ":="])
          `col += 2
          continue
        ENDIF
        IF `line[`col+1] == "~":
          `push(`tokens, ["ASSIGN_OP_RANDOM", `col, ":~"])
          `col += 2
          continue
        ENDIF
      ENDIF
      IF `line[`col] == "+":
        IF `line[`col+1] == "+":
          `push(`tokens, ["ASSIGN_OP_INCR", `col, "++"])
          `col += 2
          continue
        ENDIF
        IF `line[`col+1] == "=":
          `push(`tokens, ["ASSIGN_OP_PLUS", `col, "+="])
          `col += 2
          continue
        ENDIF
        `push(`tokens, ["PLUS", `col, "+"])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "-":
        IF `line[`col+1] == "-":
          `push(`tokens, ["ASSIGN_OP_DECR", `col, "--"])
          `col += 2
          continue
        ENDIF
        IF `line[`col+1] == "=":
          `push(`tokens, ["ASSIGN_OP_MINUS", `col, "-="])
          `col += 2
          continue
        ENDIF
        `push(`tokens, ["MINUS", `col, "-"])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "*":
        IF `line[`col+1] == "=":
          `push(`tokens, ["ASSIGN_OP_MUL", `col, "*="])
          `col += 2
          continue
        ENDIF
        `push(`tokens, ["MUL", `col, "*"])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "/":
        IF `line[`col+1] == "=":
          `push(`tokens, ["ASSIGN_OP_DIV", `col, "/="])
          `col += 2
          continue
        ENDIF
        `push(`tokens, ["DIV", `col, "/"])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "%":
        IF `line[`col+1] == "=":
          `push(`tokens, ["ASSIGN_OP_MOD", `col, "%="])
          `col += 2
          continue
        ENDIF
        `push(`tokens, ["MOD", `col, "%"])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "&":
        IF `line[`col+1] == "=":
          `push(`tokens, ["ASSIGN_OP_BIT_AND", `col, "&="])
          `col += 2
          continue
        ENDIF
        `push(`tokens, ["BIT_AND", `col, "&"])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "^":
        IF `line[`col+1] == "=":
          `push(`tokens, ["ASSIGN_OP_BIT_XOR", `col, "^="])
          `col += 2
          continue
        ENDIF
        `push(`tokens, ["BIT_XOR", `col, "^"])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "|":
        IF `line[`col+1] == "=":
          `push(`tokens, ["ASSIGN_OP_BIT_OR", `col, "|="])
          `col += 2
          continue
        ENDIF
        `push(`tokens, ["BIT_OR", `col, "|"])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "~":
        IF `line[`col+1] == "~":
          `push(`tokens, ["ASSIGN_OP_TOGGLE", `col, "~~"])
          `col += 2
          continue
        ENDIF
        `push(`tokens, ["BIT_NOT", `col, "~"])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "(":
        `push(`tokens, ["LPAR", `col, "("])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == ")":
        `push(`tokens, ["RPAR", `col, ")"])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "[":
        `push(`tokens, ["LSQR", `col, "["])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "]":
        `push(`tokens, ["RSQR", `col, "]"])
        `col += 1
        IF `line[`col] == ".":
          `start = `col
          `col += 1
          WHILE (`line[`col] >= "A") AND (`line[`col] <= "Z"):
            `col += 1
          ENDWHILE
          `textra = `substring(`line, `start+1, `col)
          IF `indexof(THIS.`_reserved_vlast_words, `textra) < 0:
            `push(`tokens, ["ERROR", `start, `substring(`line, `start, `col), "UNEXPECTED"+" "+"SUFFIX"])
            `start = `col
            WHILE `line[`col] != `chr_lf:
              `col += 1
            ENDWHILE
            `push(`tokens, ["POSTERROR", `start, `substring(`line, `start, `col-1)])
            break
          ENDIF
          `push(`tokens, ["SUFFIX", `start, `substring(`line, `start, `col), `textra])
          continue
        ENDIF
        continue
      ENDIF
      IF `line[`col] == ",":
        `push(`tokens, ["COMMA", `col, ","])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "=":
        `push(`tokens, ["EQ", `col, "="])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "<":
        IF `line[`col+1] == ">":
          `push(`tokens, ["NE", `col, "<>"])
          `col += 2
          continue
        ENDIF
        IF `line[`col+1] == "=":
          `push(`tokens, ["LE", `col, "<="])
          `col += 2
          continue
        ENDIF
        IF `line[`col+1] == "<":
          IF `line[`col+2] == "=":
            `push(`tokens, ["ASSIGN_OP_BIT_SHL", `col, "<<="])
            `col += 3
            continue
          ENDIF
          `push(`tokens, ["BIT_SHL", `col, "<<"])
          `col += 2
          continue
        ENDIF
        `push(`tokens, ["LT", `col, "<"])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == ">":
        IF `line[`col+1] == "=":
          `push(`tokens, ["GE", `col, ">="])
          `col += 2
          continue
        ENDIF
        IF `line[`col+1] == ">":
          IF `line[`col+2] == "=":
            `push(`tokens, ["ASSIGN_OP_BIT_SHR", `col, ">>="])
            `col += 3
            continue
          ENDIF
          `push(`tokens, ["BIT_SHR", `col, ">>"])
          `col += 2
          continue
        ENDIF
        `push(`tokens, ["GT", `col, ">"])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "@":
        `start = `col
        `col += 1
        IF THIS.`isModuleNameCharStart(`line[`col]):
          `col += 1
          WHILE THIS.`isModuleNameChar(`line[`col]):
            `col += 1
          ENDWHILE
        ENDIF
        IF `start+1 == `col:
          `push(`tokens, ["ERROR", `start, `substring(`line, `start, `col), "MISSING"+" "+"MODULE"+" "+"NAME"])
          `start = `col
          WHILE `line[`col] != `chr_lf:
            `col += 1
          ENDWHILE
          `push(`tokens, ["POSTERROR", `start, `substring(`line, `start, `col-1)])
          break
        ENDIF
        `textra = `substring(`line, `start+1, `col)
        `push(`tokens, ["MODULE_NAME", `start, `substring(`line, `start, `col), `textra])
        continue
      ENDIF
      IF `line[`col] == `chr_quote:
        `start = `col
        `col += 1
        `textra = ""
        WHILE TRUE:
          IF `line[`col] == `chr_quote:
            `col += 1
            break
          ENDIF
          IF `line[`col] == `chr_lf:
            `textra = NULL
            `push(`tokens, ["ERROR", `start, `substring(`line, `start, `col-1), "UNEXPECTED"+" "+"END"+" "+"OF"+" "+"STRING"])
            `push(`tokens, ["POSTERROR", `col-1, ""])
            break
          ENDIF
          IF `line[`col] != "\\":
            `textra += `line[`col]
            `col += 1
            continue
          ENDIF
          `col += 1
          IF `line[`col] == "n":
            `textra += `chr_lf
            `col += 1
            continue
          ENDIF
          IF `line[`col] == "\\":
            `textra += "\\"
            `col += 1
            continue
          ENDIF
          IF `line[`col] == `chr_quote:
            `textra += `chr_quote
            `col += 1
            continue
          ENDIF
          `textra = NULL
          `push(`tokens, ["ERROR", `start, `substring(`line, `start, `col), "STRING"+" "+"ESCAPE"+" "+"NOT"+" "+"ALLOWED"])
          `start = `col
          WHILE `line[`col] != `chr_lf:
            `col += 1
          ENDWHILE
          `push(`tokens, ["POSTERROR", `start, `substring(`line, `start, `col-1)])
          break
        ENDWHILE
        IF `isnull(`textra):
          break
        ENDIF
        `push(`tokens, ["STRING", `start, `substring(`line, `start, `col), `textra])
        continue
      ENDIF
      IF `line[`col] == "#":
        `start = `col
        `col += 1
        WHILE `line[`col] != `chr_lf:
          `col += 1
        ENDWHILE
        `push(`tokens, ["COMMENT", `start, `substring(`line, `start, `col-1)])
        break
      ENDIF
      IF (`line[`col] == "0") AND (`line[`col+1] == "x") AND (((`line[`col+2] >= "0") AND (`line[`col+2] <= "9")) OR ((`line[`col+2] >= "a") AND (`line[`col+2] <= "f")) OR ((`line[`col+2] >= "A") AND (`line[`col+2] <= "F"))):
        `start = `col
        `col += 3
        WHILE ((`line[`col] >= "0") AND (`line[`col] <= "9")) OR ((`line[`col] >= "a") AND (`line[`col] <= "f")) OR ((`line[`col] >= "A") AND (`line[`col] <= "F")):
          `col += 1
        ENDWHILE
        IF `col-`start > 10:
          `push(`tokens, ["ERROR", `start, `substring(`line, `start, `col), "HEXADECIMAL"+" "+"NUMBER"+" "+"GREATER"+" "+"THAN"+" "+"32"+" "+"BITS"])
          `start = `col
          WHILE `line[`col] != `chr_lf:
            `col += 1
          ENDWHILE
          `push(`tokens, ["POSTERROR", `start, `substring(`line, `start, `col-1)])
          break
        ENDIF
        `push(`tokens, ["HEXADECIMAL", `start, `substring(`line, `start, `col)])
        continue
      ENDIF
      IF (`line[`col] >= "0") AND (`line[`col] <= "9"):
        `start = `col
        `col += 1
        WHILE (`line[`col] >= "0") AND (`line[`col] <= "9"):
          `col += 1
        ENDWHILE
        `nonzero = `col
        FORINCR `j(`start `col):
          IF `line[`j] == "0":
            continue
          ENDIF
          `nonzero = `j
          break
        ENDFOR
        IF (`col-`nonzero > 10) OR (`parse_int(`substring(`line, `start, `col), 10) > 0xffffffff):
          `push(`tokens, ["ERROR", `start, `substring(`line, `start, `col), "INTEGER"+" "+"GREATER"+" "+"THAN"+" "+"32"+" "+"BITS"])
          `start = `col
          WHILE `line[`col] != `chr_lf:
            `col += 1
          ENDWHILE
          `push(`tokens, ["POSTERROR", `start, `substring(`line, `start, `col-1)])
          break
        ENDIF
        `push(`tokens, ["DECIMAL", `start, `substring(`line, `start, `col)])
        continue
      ENDIF
      IF ((`line[`col] >= "a") AND (`line[`col] <= "z")) OR ((`line[`col] >= "A") AND (`line[`col] <= "Z")) OR (`line[`col] == "_"):
        `start = `col
        `col += 1
        WHILE ((`line[`col] >= "0") AND (`line[`col] <= "9")) OR ((`line[`col] >= "a") AND (`line[`col] <= "z")) OR ((`line[`col] >= "A") AND (`line[`col] <= "Z")) OR (`line[`col] == "_") OR (`line[`col] == "."):
          `col += 1
        ENDWHILE
        `textra = `substring(`line, `start, `col)
        `subtextras = `split(`textra, ".")
        `error_msg = NULL
        `var_op = NULL
        FORINCR `j(0 `length(`subtextras)):
          IF `length(`subtextras[`j]) == 0:
            `error_msg = "INVALID"+" "+"VARIABLE"
            break
          ENDIF
          IF (`subtextras[`j][0] >= "0") AND (`subtextras[`j][0] <= "9"):
            `error_msg = "INVALID"+" "+"VARIABLE"
            break
          ENDIF
          IF `indexof(THIS.`_reserved_words, `subtextras[`j]) >= 0:
            `error_msg = "RESERVED"+" "+"WORD"
            break
          ENDIF
          IF (`indexof(THIS.`_reserved_vlast_words, `subtextras[`j]) >= 0) AND ((`j != `length(`subtextras)-1) OR (`length(`subtextras) == 1)):
            `error_msg = "RESERVED"+" "+"WORD"
            break
          ENDIF
        ENDFOR
        IF `isnull(`error_msg):
          IF `indexof(THIS.`_reserved_vlast_words, `subtextras[`length(`subtextras)-1]) >= 0:
            IF (`indexof(THIS.`_reserved_qlast_words, `subtextras[`length(`subtextras)-1]) < 0) AND (`length(`subtextras) > 2):
              `error_msg = "INVALID"+" "+"VARIABLE"
            ELSE:
              `var_op = `subtextras[`length(`subtextras)-1]
              `textra = `substring(`textra, 0, `length(`textra)-`length(`var_op)-1)
            ENDIF
          ELSE:
              `var_op = TERNARY{`length(`subtextras) > 1}{"QUALVAR"}{"VAR"}
          ENDIF
        ENDIF
        IF `not(`isnull(`error_msg)):
          `push(`tokens, ["ERROR", `start, `substring(`line, `start, `col), `error_msg])
          `start = `col
          WHILE `line[`col] != `chr_lf:
            `col += 1
          ENDWHILE
          `push(`tokens, ["POSTERROR", `start, `substring(`line, `start, `col-1)])
          break
        ENDIF
        `push(`tokens, [`var_op, `start, `substring(`line, `start, `col), `textra])
        continue
      ENDIF
      `push(`tokens, ["ERROR", `col, `substring(`line, `col, `col+1), "UNEXPECTED"+" "+"CHAR"])
      `col += 1
      `start = `col
      WHILE `line[`col] != `chr_lf:
        `col += 1
      ENDWHILE
      `push(`tokens, ["POSTERROR", `start, `substring(`line, `start, `col-1)])
      break
    ENDWHILE
    `push(`tokens, ["NEWLINE", `length(`line)-2, `chr_lf])
    return `tokens

ENDCLASS

VAR `lexer = NEW `Lexer()

CLASS `Parser:

  METHOD_INIT():
    THIS.`_ignored_lexemes = []
    `push(THIS.`_ignored_lexemes, "INDENT")
    `push(THIS.`_ignored_lexemes, "SPACES")
    `push(THIS.`_ignored_lexemes, "COMMENT")

  METHOD `parseLine(`tokens):
    IF `lexer.`tokenName(`tokens[`length(`tokens)-2]) == "POSTERROR":
      return ["ERROR", NULL, `lexer.`tokenExtra(`tokens[`length(`tokens)-3]), `lexer.`tokenColumn(`tokens[`length(`tokens)-3]), []]
    ENDIF
    VAR `lidxs = []
    VAR `j
    FORINCR `j(0 `length(`tokens)):
      IF `indexof(THIS.`_ignored_lexemes, `lexer.`tokenName(`tokens[`j])) < 0:
        `push(`lidxs, `j)
      ENDIF
    ENDFOR
    IF `length(`lidxs) == 1:
      return NULL
    ENDIF
    VAR `lidx_sfxexpr = THIS.`_parseVarSuffix(`tokens, `lidxs, 0)
    IF `length(`lidx_sfxexpr) > 1:
      IF `lidx_sfxexpr[1][1] == "PUSH":
        return THIS.`_parsePush(`tokens, `lidxs, `lidx_sfxexpr)
      ELSIF `lidx_sfxexpr[1][1] == "QUEUE":
        return THIS.`_parseQueue(`tokens, `lidxs, `lidx_sfxexpr)
      ELSIF `lidx_sfxexpr[1][1] == "POP":
        return THIS.`_parsePop(`tokens, `lidxs, `lidx_sfxexpr)
      ELSIF `lidx_sfxexpr[1][1] == "UNQUEUE":
        return THIS.`_parseUnqueue(`tokens, `lidxs, `lidx_sfxexpr)
      ENDIF
    ENDIF
    VAR `token = `lexer.`tokenName(`tokens[`lidxs[0]])
    IF `token == "VAR":
      return THIS.`_parseAssign(`tokens, `lidxs)
    ELSIF `token == "IF":
      return THIS.`_parseIf(`tokens, `lidxs)
    ELSIF `token == "ELSIF":
      return THIS.`_parseElsif(`tokens, `lidxs)
    ELSIF `token == "ELSE":
      return THIS.`_parseElse(`tokens, `lidxs)
    ELSIF `token == "ENDIF":
      return THIS.`_parseEndif(`tokens, `lidxs)
    ELSIF `token == "REPEAT":
      return THIS.`_parseRepeat(`tokens, `lidxs)
    ELSIF `token == "REPNEXT":
      return THIS.`_parseRepnext(`tokens, `lidxs)
    ELSIF `token == "REPSTOP":
      return THIS.`_parseRepstop(`tokens, `lidxs)
    ELSIF `token == "ENDREP":
      return THIS.`_parseEndrep(`tokens, `lidxs)
    ELSIF `token == "QUALVAR":
      return THIS.`_parseProcedure(`tokens, `lidxs)
    ELSIF `token == "PUSH":
      return THIS.`_parsePush(`tokens, `lidxs, NULL)
    ELSIF `token == "QUEUE":
      return THIS.`_parseQueue(`tokens, `lidxs, NULL)
    ELSIF `token == "POP":
      return THIS.`_parsePop(`tokens, `lidxs, NULL)
    ELSIF `token == "UNQUEUE":
      return THIS.`_parseUnqueue(`tokens, `lidxs, NULL)
    ELSIF `token == "UNASSIGN":
      return THIS.`_parseUnassign(`tokens, `lidxs)
    ELSIF `token == "LOG":
      return THIS.`_parseLog(`tokens, `lidxs)
    ENDIF
    return ["ERROR", NULL, "INVALID"+" "+"INSTRUCTION", `lexer.`tokenColumn(`tokens[`lidxs[0]]), []]

  METHOD `_parseAssign(`tokens `lidxs):
    VAR `vvar = `lexer.`tokenValue(`tokens[`lidxs[0]])
    VAR `exprs = []
    VAR `lidx_expr
    VAR `lidx = 1
    VAR `proc_exprs
    VAR `byref_exprs
    VAR `j
    VAR `lidx_ariexpr
    VAR `qualvar
    VAR `expr
    VAR `lidx_sfxexpr
    WHILE `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "LSQR":
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ELSIF `lexer.`tokenName(`tokens[`lidxs[`lidx_expr[0]]]) != "RSQR":
        return ["ERROR", NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST"+" "+"INDEX", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      `push(`exprs, `lidx_expr[1])
      `lidx = `lidx_expr[0]+1
    ENDWHILE
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "COMMA":
      `proc_exprs = []
      `byref_exprs = [`vvar]
      FORINCR `j(0 `length(`exprs)):
        `push(`byref_exprs, `exprs[`j])
      ENDFOR
      `push(`proc_exprs, ["BY_REF", `byref_exprs])
      WHILE `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "COMMA":
        `lidx += 1
        IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "ASSIGN_OP":
          break
        ENDIF
        IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) != "VAR":
          return ["ERROR", NULL, "EXPECTED"+" "+"VARIABLE"+" "+"NAME"+" "+"IN"+" "+"PROCEDURE"+" "+"CALL", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]
        ENDIF
        `byref_exprs = [`lexer.`tokenValue(`tokens[`lidxs[`lidx]])]
        `lidx += 1
        WHILE `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "LSQR":
          `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
          IF `length(`lidx_ariexpr) == 1:
            return `lidx_ariexpr
          ENDIF
          `lidx = `lidx_ariexpr[0]
          IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) != "RSQR":
            return [["ERROR", NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST"+" "+"INDEX", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
          ENDIF
          `push(`byref_exprs, `lidx_ariexpr[1])
          `lidx += 1
        ENDWHILE
        `push(`proc_exprs, ["BY_REF", `byref_exprs])
      ENDWHILE
      IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) != "ASSIGN_OP":
        return ["ERROR", NULL, "EXPECTED"+" "+"ASSIGNMENT"+" "+"IN"+" "+"PROCEDURE"+" "+"CALL", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]
      ENDIF
      `lidx += 1
      IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) != "QUALVAR":
        return ["ERROR", NULL, "EXPECTED"+" "+"PROCEDURE"+" "+"IN"+" "+"ASSIGNMENT", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]
      ENDIF
      `qualvar = `lexer.`tokenValue(`tokens[`lidxs[`lidx]])
      IF `lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) != "LPAR":
        return ["ERROR", NULL, "EXPECTED"+" "+"LPAR"+" "+"AFTER"+" "+"PROCEDURE"+" "+"NAME", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+1]]), []]
      ENDIF
      IF `lexer.`tokenName(`tokens[`lidxs[`lidx+2]]) == "RPAR":
        IF `lexer.`tokenName(`tokens[`lidxs[`lidx+3]]) != "NEWLINE":
          return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"PROCEDURE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+3]]), []]
        ENDIF
        return ["PROCEDURE", NULL, `qualvar, `proc_exprs]
      ENDIF
      IF `lexer.`tokenName(`tokens[`lidxs[`lidx+2]]) == "BIT_AND":
        IF `lexer.`tokenName(`tokens[`lidxs[`lidx+3]]) != "VAR":
          return ["ERROR", NULL, "EXPECTED"+" "+"VARIABLE"+" "+"NAME"+" "+"IN"+" "+"CALL"+" "+"BY"+" "+"REFERENCE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+3]]), []]
        ENDIF
        `lidx += 3
        `byref_exprs = [`lexer.`tokenValue(`tokens[`lidxs[`lidx]])]
        `lidx += 1
        WHILE `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "LSQR":
          `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
          IF `length(`lidx_ariexpr) == 1:
            return `lidx_ariexpr
          ENDIF
          `lidx = `lidx_ariexpr[0]
          IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) != "RSQR":
            return [["ERROR", NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST"+" "+"INDEX", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
          ENDIF
          `push(`byref_exprs, `lidx_ariexpr[1])
          `lidx += 1
        ENDWHILE
        `push(`proc_exprs, ["BY_REF", `byref_exprs])
      ELSIF `lexer.`tokenName(`tokens[`lidxs[`lidx+2]]) == "MODULE_NAME":
        `push(`proc_exprs, ["MODULE_NAME", `lexer.`tokenExtra(`tokens[`lidxs[`lidx+2]])])
        `lidx += 3
      ELSIF `lexer.`tokenName(`tokens[`lidxs[`lidx+2]]) == "STRING":
        `push(`proc_exprs, ["STRING", `lexer.`tokenExtra(`tokens[`lidxs[`lidx+2]])])
        `lidx += 3
      ELSE:
        `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx+2)
        IF `length(`lidx_expr) == 1:
          return `lidx_expr[0]
        ENDIF
        `push(`proc_exprs, `lidx_expr[1])
        `lidx = `lidx_expr[0]
      ENDIF
      WHILE `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "COMMA":
        IF `lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "RPAR":
          `lidx += 1
          break
        ENDIF
        IF `lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "BIT_AND":
          IF `lexer.`tokenName(`tokens[`lidxs[`lidx+2]]) != "VAR":
            return ["ERROR", NULL, "EXPECTED"+" "+"VARIABLE"+" "+"NAME"+" "+"IN"+" "+"CALL"+" "+"BY"+" "+"REFERENCE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+2]]), []]
          ENDIF
          `lidx += 2
          `byref_exprs = [`lexer.`tokenValue(`tokens[`lidxs[`lidx]])]
          `lidx += 1
          WHILE `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "LSQR":
            `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
            IF `length(`lidx_ariexpr) == 1:
              return `lidx_ariexpr
            ENDIF
            `lidx = `lidx_ariexpr[0]
            IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) != "RSQR":
              return [["ERROR", NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST"+" "+"INDEX", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
            ENDIF
            `push(`byref_exprs, `lidx_ariexpr[1])
            `lidx += 1
          ENDWHILE
          `push(`proc_exprs, ["BY_REF", `byref_exprs])
        ELSIF `lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "MODULE_NAME":
          `push(`proc_exprs, ["MODULE_NAME", `lexer.`tokenExtra(`tokens[`lidxs[`lidx+1]])])
          `lidx = `lidx+2
        ELSIF `lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "STRING":
          `push(`proc_exprs, ["STRING", `lexer.`tokenExtra(`tokens[`lidxs[`lidx+1]])])
          `lidx = `lidx+2
        ELSE:
          `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx+1)
          IF `length(`lidx_expr) == 1:
            return `lidx_expr[0]
          ENDIF
          `push(`proc_exprs, `lidx_expr[1])
          `lidx = `lidx_expr[0]
        ENDIF
      ENDWHILE
      IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) != "RPAR":
        return ["ERROR", NULL, "EXPECTED"+" "+"RPAR"+" "+"CLOSING"+" "+"PROCEDURE"+" "+"PARAMETERS", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]
      ENDIF
      IF `lidx+1 != `length(`lidxs)-1:
        return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"PROCEDURE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+1]]), []]
      ENDIF
      return ["PROCEDURE", NULL, `qualvar, `proc_exprs]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "ASSIGN_OP_RANDOM":
      IF `lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "RANDOM":
        IF `lidx+2 != `length(`lidxs)-1:
          return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"RANDOM", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+2]]), []]
        ENDIF
        return ["ASSIGN_OP_RANDOM", NULL, `vvar, `exprs, NULL]
      ENDIF
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ARITHMETIC"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      return ["ASSIGN_OP_RANDOM", NULL, `vvar, `exprs, `lidx_expr[1]]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "ASSIGN_OP_INCR":
      IF `lidx+1 != `length(`lidxs)-1:
        return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"INCREMENT"+" "+"OPERATOR", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+1]]), []]
      ENDIF
      IF `length(`exprs) == 0:
        `expr = ["PLUS", ["VAR", `vvar], ["INTEGER", 1]]
      ELSE:
        `expr = ["PLUS", ["LIST_AT_VAR", `vvar, `exprs], ["INTEGER", 1]]
      ENDIF
      return ["ASSIGN_OP", NULL, `vvar, `exprs, `expr]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "ASSIGN_OP_DECR":
      IF `lidx+1 != `length(`lidxs)-1:
        return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"DECREMENT"+" "+"OPERATOR", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+1]]), []]
      ENDIF
      IF `length(`exprs) == 0:
        `expr = ["MINUS", ["VAR", `vvar], ["INTEGER", 1]]
      ELSE:
        `expr = ["MINUS", ["LIST_AT_VAR", `vvar, `exprs], ["INTEGER", 1]]
      ENDIF
      return ["ASSIGN_OP", NULL, `vvar, `exprs, `expr]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "ASSIGN_OP_PLUS":
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ARITHMETIC"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      IF `length(`exprs) == 0:
        `expr = ["PLUS", ["VAR", `vvar], `lidx_expr[1]]
      ELSE:
        `expr = ["PLUS", ["LIST_AT_VAR", `vvar, `exprs], `lidx_expr[1]]
      ENDIF
      return ["ASSIGN_OP", NULL, `vvar, `exprs, `expr]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "ASSIGN_OP_MINUS":
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ARITHMETIC"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      IF `length(`exprs) == 0:
        `expr = ["MINUS", ["VAR", `vvar], `lidx_expr[1]]
      ELSE:
        `expr = ["MINUS", ["LIST_AT_VAR", `vvar, `exprs], `lidx_expr[1]]
      ENDIF
      return ["ASSIGN_OP", NULL, `vvar, `exprs, `expr]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "ASSIGN_OP_MUL":
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ARITHMETIC"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      IF `length(`exprs) == 0:
        `expr = ["MUL", ["VAR", `vvar], `lidx_expr[1]]
      ELSE:
        `expr = ["MUL", ["LIST_AT_VAR", `vvar, `exprs], `lidx_expr[1]]
      ENDIF
      return ["ASSIGN_OP", NULL, `vvar, `exprs, `expr]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "ASSIGN_OP_DIV":
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ARITHMETIC"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      IF `length(`exprs) == 0:
        `expr = ["DIV", ["VAR", `vvar], `lidx_expr[1]]
      ELSE:
        `expr = ["DIV", ["LIST_AT_VAR", `vvar, `exprs], `lidx_expr[1]]
      ENDIF
      return ["ASSIGN_OP", NULL, `vvar, `exprs, `expr]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "ASSIGN_OP_MOD":
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ARITHMETIC"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      IF `length(`exprs) == 0:
        `expr = ["MOD", ["VAR", `vvar], `lidx_expr[1]]
      ELSE:
        `expr = ["MOD", ["LIST_AT_VAR", `vvar, `exprs], `lidx_expr[1]]
      ENDIF
      return ["ASSIGN_OP", NULL, `vvar, `exprs, `expr]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "ASSIGN_OP_BIT_AND":
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ARITHMETIC"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      IF `length(`exprs) == 0:
        `expr = ["BIT_AND", ["VAR", `vvar], `lidx_expr[1]]
      ELSE:
        `expr = ["BIT_AND", ["LIST_AT_VAR", `vvar, `exprs], `lidx_expr[1]]
      ENDIF
      return ["ASSIGN_OP", NULL, `vvar, `exprs, `expr]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "ASSIGN_OP_BIT_OR":
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ARITHMETIC"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      IF `length(`exprs) == 0:
        `expr = ["BIT_OR", ["VAR", `vvar], `lidx_expr[1]]
      ELSE:
        `expr = ["BIT_OR", ["LIST_AT_VAR", `vvar, `exprs], `lidx_expr[1]]
      ENDIF
      return ["ASSIGN_OP", NULL, `vvar, `exprs, `expr]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "ASSIGN_OP_BIT_XOR":
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ARITHMETIC"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      IF `length(`exprs) == 0:
        `expr = ["BIT_XOR", ["VAR", `vvar], `lidx_expr[1]]
      ELSE:
        `expr = ["BIT_XOR", ["LIST_AT_VAR", `vvar, `exprs], `lidx_expr[1]]
      ENDIF
      return ["ASSIGN_OP", NULL, `vvar, `exprs, `expr]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "ASSIGN_OP_BIT_SHL":
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ARITHMETIC"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      IF `length(`exprs) == 0:
        `expr = ["BIT_SHL", ["VAR", `vvar], `lidx_expr[1]]
      ELSE:
        `expr = ["BIT_SHL", ["LIST_AT_VAR", `vvar, `exprs], `lidx_expr[1]]
      ENDIF
      return ["ASSIGN_OP", NULL, `vvar, `exprs, `expr]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "ASSIGN_OP_BIT_SHR":
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ARITHMETIC"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      IF `length(`exprs) == 0:
        `expr = ["BIT_SHR", ["VAR", `vvar], `lidx_expr[1]]
      ELSE:
        `expr = ["BIT_SHR", ["LIST_AT_VAR", `vvar, `exprs], `lidx_expr[1]]
      ENDIF
      return ["ASSIGN_OP", NULL, `vvar, `exprs, `expr]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "ASSIGN_OP_TOGGLE":
      IF `lidx+1 != `length(`lidxs)-1:
        return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"TOGGLE"+" "+"OPERATOR", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+1]]), []]
      ENDIF
      IF `length(`exprs) == 0:
        `expr = ["BIT_NOT", ["VAR", `vvar]]
      ELSE:
        `expr = ["BIT_NOT", ["LIST_AT_VAR", `vvar, `exprs]]
      ENDIF
      return ["ASSIGN_OP", NULL, `vvar, `exprs, `expr]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) != "ASSIGN_OP":
      return ["ERROR", NULL, "EXPECTED"+" "+"ASSIGNMENT", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]
    ENDIF
    IF (`lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "QUALVAR") AND (`lexer.`tokenName(`tokens[`lidxs[`lidx+2]]) == "LPAR"):
      `proc_exprs = []
      `byref_exprs = [`vvar]
      FORINCR `j(0 `length(`exprs)):
        `push(`byref_exprs, `exprs[`j])
      ENDFOR
      `push(`proc_exprs, ["BY_REF", `byref_exprs])
      `lidx += 1
      `qualvar = `lexer.`tokenValue(`tokens[`lidxs[`lidx]])
      IF `lexer.`tokenName(`tokens[`lidxs[`lidx+2]]) == "RPAR":
        IF `lexer.`tokenName(`tokens[`lidxs[`lidx+3]]) != "NEWLINE":
          return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"PROCEDURE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+3]]), []]
        ENDIF
        return ["PROCEDURE", NULL, `qualvar, `proc_exprs]
      ENDIF
      IF `lexer.`tokenName(`tokens[`lidxs[`lidx+2]]) == "BIT_AND":
        IF `lexer.`tokenName(`tokens[`lidxs[`lidx+3]]) != "VAR":
          return ["ERROR", NULL, "EXPECTED"+" "+"VARIABLE"+" "+"NAME"+" "+"IN"+" "+"CALL"+" "+"BY"+" "+"REFERENCE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+3]]), []]
        ENDIF
        `lidx += 3
        `byref_exprs = [`lexer.`tokenValue(`tokens[`lidxs[`lidx]])]
        `lidx += 1
        WHILE `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "LSQR":
          `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
          IF `length(`lidx_ariexpr) == 1:
            return `lidx_ariexpr
          ENDIF
          `lidx = `lidx_ariexpr[0]
          IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) != "RSQR":
            return [["ERROR", NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST"+" "+"INDEX", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
          ENDIF
          `push(`byref_exprs, `lidx_ariexpr[1])
          `lidx += 1
        ENDWHILE
        `push(`proc_exprs, ["BY_REF", `byref_exprs])
      ELSIF `lexer.`tokenName(`tokens[`lidxs[`lidx+2]]) == "MODULE_NAME":
        `push(`proc_exprs, ["MODULE_NAME", `lexer.`tokenExtra(`tokens[`lidxs[`lidx+2]])])
        `lidx += 3
      ELSIF `lexer.`tokenName(`tokens[`lidxs[`lidx+2]]) == "STRING":
        `push(`proc_exprs, ["STRING", `lexer.`tokenExtra(`tokens[`lidxs[`lidx+2]])])
        `lidx += 3
      ELSE:
        `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx+2)
        IF `length(`lidx_expr) == 1:
          return `lidx_expr[0]
        ENDIF
        `push(`proc_exprs, `lidx_expr[1])
        `lidx = `lidx_expr[0]
      ENDIF
      WHILE `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "COMMA":
        IF `lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "RPAR":
          `lidx += 1
          break
        ENDIF
        IF `lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "BIT_AND":
          IF `lexer.`tokenName(`tokens[`lidxs[`lidx+2]]) != "VAR":
            return ["ERROR", NULL, "EXPECTED"+" "+"VARIABLE"+" "+"NAME"+" "+"IN"+" "+"CALL"+" "+"BY"+" "+"REFERENCE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+2]]), []]
          ENDIF
          `lidx += 2
          `byref_exprs = [`lexer.`tokenValue(`tokens[`lidxs[`lidx]])]
          `lidx += 1
          WHILE `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "LSQR":
            `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
            IF `length(`lidx_ariexpr) == 1:
              return `lidx_ariexpr
            ENDIF
            `lidx = `lidx_ariexpr[0]
            IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) != "RSQR":
              return [["ERROR", NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST"+" "+"INDEX", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
            ENDIF
            `push(`byref_exprs, `lidx_ariexpr[1])
            `lidx += 1
          ENDWHILE
          `push(`proc_exprs, ["BY_REF", `byref_exprs])
        ELSIF `lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "MODULE_NAME":
          `push(`proc_exprs, ["MODULE_NAME", `lexer.`tokenExtra(`tokens[`lidxs[`lidx+1]])])
          `lidx = `lidx+2
        ELSIF `lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "STRING":
          `push(`proc_exprs, ["STRING", `lexer.`tokenExtra(`tokens[`lidxs[`lidx+1]])])
          `lidx = `lidx+2
        ELSE:
          `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx+1)
          IF `length(`lidx_expr) == 1:
            return `lidx_expr[0]
          ENDIF
          `push(`proc_exprs, `lidx_expr[1])
          `lidx = `lidx_expr[0]
        ENDIF
      ENDWHILE
      IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) != "RPAR":
        return ["ERROR", NULL, "EXPECTED"+" "+"RPAR"+" "+"CLOSING"+" "+"PROCEDURE"+" "+"PARAMETERS", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]
      ENDIF
      IF `lidx+1 != `length(`lidxs)-1:
        return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"PROCEDURE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+1]]), []]
      ENDIF
      return ["PROCEDURE", NULL, `qualvar, `proc_exprs]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "POP":
      IF `lexer.`tokenName(`tokens[`lidxs[`lidx+2]]) == "NEWLINE":
        return ["ASSIGN_POP", NULL, `vvar, `exprs, ["VAR", `lexer.`tokenExtra(`tokens[`lidxs[`lidx+1]])], NULL]
      ENDIF
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+2)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"POP", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      return ["ASSIGN_POP", NULL, `vvar, `exprs, ["VAR", `lexer.`tokenExtra(`tokens[`lidxs[`lidx+1]])], `lidx_expr[1]]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "UNQUEUE":
      IF `lexer.`tokenName(`tokens[`lidxs[`lidx+2]]) != "NEWLINE":
        return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"UNQUEUE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+2]]), []]
      ENDIF
      return ["ASSIGN_UNQUEUE", NULL, `vvar, `exprs, ["VAR", `lexer.`tokenExtra(`tokens[`lidxs[`lidx+1]])]]
    ENDIF
    `lidx_sfxexpr = THIS.`_parseVarSuffix(`tokens, `lidxs, `lidx+1)
    IF `length(`lidx_sfxexpr) > 1:
      IF `lidx_sfxexpr[1][1] == "POP":
        IF `lexer.`tokenName(`tokens[`lidxs[`lidx_sfxexpr[0]]]) == "NEWLINE":
          return ["ASSIGN_POP", NULL, `vvar, `exprs, `lidx_sfxexpr[1][2], NULL]
        ENDIF
        `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx_sfxexpr[0])
        IF `length(`lidx_expr) == 1:
          return `lidx_expr[0]
        ENDIF
        IF `lidx_expr[0] != `length(`lidxs)-1:
          return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"POP", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
        ENDIF
        return ["ASSIGN_POP", NULL, `vvar, `exprs, `lidx_sfxexpr[1][2], `lidx_expr[1]]
      ENDIF
      IF `lidx_sfxexpr[1][1] == "UNQUEUE":
        IF `lexer.`tokenName(`tokens[`lidxs[`lidx_sfxexpr[0]]]) != "NEWLINE":
          return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"UNQUEUE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_sfxexpr[0]]]), []]
        ENDIF
        return ["ASSIGN_UNQUEUE", NULL, `vvar, `exprs, `lidx_sfxexpr[1][2]]
      ENDIF
    ENDIF
    `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx+1)
    IF `length(`lidx_expr) == 1:
      return `lidx_expr[0]
    ENDIF
    IF `lidx_expr[0] != `length(`lidxs)-1:
      return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ASSIGNMENT", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
    ENDIF
    return ["ASSIGN_OP", NULL, `vvar, `exprs, `lidx_expr[1]]

  METHOD `_parseIf(`tokens `lidxs):
    VAR `lidx_expr = THIS.`_parseLogicalExpression(`tokens, `lidxs, 1)
    IF `length(`lidx_expr) == 1:
      return `lidx_expr[0]
    ENDIF
    IF `lidx_expr[0] != `length(`lidxs)-1:
      return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"LOGICAL"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
    ENDIF
    return ["IF", NULL, NULL, `lidx_expr[1]]

  METHOD `_parseElsif(`tokens `lidxs):
    VAR `lidx_expr = THIS.`_parseLogicalExpression(`tokens, `lidxs, 1)
    IF `length(`lidx_expr) == 1:
      return `lidx_expr[0]
    ENDIF
    IF `lidx_expr[0] != `length(`lidxs)-1:
      return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"LOGICAL"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
    ENDIF
    return ["ELSIF", NULL, NULL, `lidx_expr[1]]

  METHOD `_parseElse(`tokens `lidxs):
    IF `length(`lidxs) != 2:
      return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ELSE", `lexer.`tokenColumn(`tokens[`lidxs[1]]), []]
    ENDIF
    return ["ELSE", NULL]

  METHOD `_parseEndif(`tokens `lidxs):
    IF `length(`lidxs) != 2:
      return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ENDIF", `lexer.`tokenColumn(`tokens[`lidxs[1]]), []]
    ENDIF
    return ["ENDIF", NULL]

  METHOD `_parseRepeat(`tokens `lidxs):
    IF `length(`lidxs) == 3 AND `lexer.`tokenName(`tokens[`lidxs[1]]) == "VAR":
      return ["REPEAT", NULL, NULL, `lexer.`tokenValue(`tokens[`lidxs[1]])]
    ENDIF
    IF `length(`lidxs) < 3 OR `lexer.`tokenName(`tokens[`lidxs[1]]) != "VAR":
      return ["ERROR", NULL, "EXPECTED"+" "+"VARIABLE"+" "+"AFTER"+" "+"REPEAT", `lexer.`tokenColumn(`tokens[`lidxs[1]]), []]
    ENDIF
    return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"REPEAT", `lexer.`tokenColumn(`tokens[`lidxs[2]]), []]

  METHOD `_parseRepnext(`tokens `lidxs):
    IF `length(`lidxs) != 2:
      return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"REPNEXT", `lexer.`tokenColumn(`tokens[`lidxs[1]]), []]
    ENDIF
    return ["REPNEXT", NULL]

  METHOD `_parseRepstop(`tokens `lidxs):
    IF `length(`lidxs) != 2:
      return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"REPSTOP", `lexer.`tokenColumn(`tokens[`lidxs[1]]), []]
    ENDIF
    return ["REPSTOP", NULL]

  METHOD `_parseEndrep(`tokens `lidxs):
    IF `length(`lidxs) != 2:
      return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ENDREP", `lexer.`tokenColumn(`tokens[`lidxs[1]]), []]
    ENDIF
    return ["ENDREP", NULL, NULL]

  METHOD `_parseProcedure(`tokens `lidxs):
    VAR `qualvar = `lexer.`tokenValue(`tokens[`lidxs[0]])
    IF `lexer.`tokenName(`tokens[`lidxs[1]]) != "LPAR":
      return ["ERROR", NULL, "EXPECTED"+" "+"LPAR"+" "+"AFTER"+" "+"PROCEDURE"+" "+"NAME", `lexer.`tokenColumn(`tokens[`lidxs[1]]), []]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[2]]) == "RPAR":
      IF `lexer.`tokenName(`tokens[`lidxs[3]]) != "NEWLINE":
        return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"PROCEDURE", `lexer.`tokenColumn(`tokens[`lidxs[3]]), []]
      ENDIF
      return ["PROCEDURE", NULL, `qualvar, []]
    ENDIF
    VAR `exprs = []
    VAR `lidx_expr
    VAR `lidx
    VAR `byref_exprs
    VAR `lidx_ariexpr
    IF `lexer.`tokenName(`tokens[`lidxs[2]]) == "BIT_AND":
      IF `lexer.`tokenName(`tokens[`lidxs[3]]) != "VAR":
        return ["ERROR", NULL, "EXPECTED"+" "+"VARIABLE"+" "+"NAME"+" "+"IN"+" "+"CALL"+" "+"BY"+" "+"REFERENCE", `lexer.`tokenColumn(`tokens[`lidxs[3]]), []]
      ENDIF
      `lidx = 3
      `byref_exprs = [`lexer.`tokenValue(`tokens[`lidxs[`lidx]])]
      `lidx += 1
      WHILE `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "LSQR":
        `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
        IF `length(`lidx_ariexpr) == 1:
          return `lidx_ariexpr
        ENDIF
        `lidx = `lidx_ariexpr[0]
        IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) != "RSQR":
          return [["ERROR", NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST"+" "+"INDEX", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
        ENDIF
        `push(`byref_exprs, `lidx_ariexpr[1])
        `lidx += 1
      ENDWHILE
      `push(`exprs, ["BY_REF", `byref_exprs])
    ELSIF `lexer.`tokenName(`tokens[`lidxs[2]]) == "MODULE_NAME":
      `push(`exprs, ["MODULE_NAME", `lexer.`tokenExtra(`tokens[`lidxs[2]])])
      `lidx = 3
    ELSIF `lexer.`tokenName(`tokens[`lidxs[2]]) == "STRING":
      `push(`exprs, ["STRING", `lexer.`tokenExtra(`tokens[`lidxs[2]])])
      `lidx = 3
    ELSE:
      `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, 2)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      `push(`exprs, `lidx_expr[1])
      `lidx = `lidx_expr[0]
    ENDIF
    WHILE `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "COMMA":
      IF `lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "RPAR":
        `lidx += 1
        break
      ENDIF
      IF `lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "BIT_AND":
        IF `lexer.`tokenName(`tokens[`lidxs[`lidx+2]]) != "VAR":
          return ["ERROR", NULL, "EXPECTED"+" "+"VARIABLE"+" "+"NAME"+" "+"IN"+" "+"CALL"+" "+"BY"+" "+"REFERENCE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+2]]), []]
        ENDIF
        `lidx += 2
        `byref_exprs = [`lexer.`tokenValue(`tokens[`lidxs[`lidx]])]
        `lidx += 1
        WHILE `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "LSQR":
          `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
          IF `length(`lidx_ariexpr) == 1:
            return `lidx_ariexpr
          ENDIF
          `lidx = `lidx_ariexpr[0]
          IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) != "RSQR":
            return [["ERROR", NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST"+" "+"INDEX", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
          ENDIF
          `push(`byref_exprs, `lidx_ariexpr[1])
          `lidx += 1
        ENDWHILE
        `push(`exprs, ["BY_REF", `byref_exprs])
      ELSIF `lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "MODULE_NAME":
        `push(`exprs, ["MODULE_NAME", `lexer.`tokenExtra(`tokens[`lidxs[`lidx+1]])])
        `lidx = `lidx+2
      ELSIF `lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "STRING":
        `push(`exprs, ["STRING", `lexer.`tokenExtra(`tokens[`lidxs[`lidx+1]])])
        `lidx = `lidx+2
      ELSE:
        `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx+1)
        IF `length(`lidx_expr) == 1:
          return `lidx_expr[0]
        ENDIF
        `push(`exprs, `lidx_expr[1])
        `lidx = `lidx_expr[0]
      ENDIF
    ENDWHILE
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) != "RPAR":
      return ["ERROR", NULL, "EXPECTED"+" "+"RPAR"+" "+"CLOSING"+" "+"PROCEDURE"+" "+"PARAMETERS", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]
    ENDIF
    IF `lidx+1 != `length(`lidxs)-1:
      return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"PROCEDURE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+1]]), []]
    ENDIF
    return ["PROCEDURE", NULL, `qualvar, `exprs]

  METHOD `_parsePush(`tokens `lidxs `lidx_sfxexpr):
    VAR `lidx_expr
    VAR `lidx_ariexpr
    IF `not(`isnull(`lidx_sfxexpr)):
      `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx_sfxexpr[0])
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] == `length(`lidxs)-1:
        return ["PUSH", NULL, `lidx_sfxexpr[1][2], `lidx_expr[1], NULL]
      ENDIF
      `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx_expr[0])
      IF `length(`lidx_ariexpr) == 1:
        return `lidx_ariexpr[0]
      ENDIF
      IF `lidx_ariexpr[0] != `length(`lidxs)-1:
        return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"PUSH", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_ariexpr[0]]]), []]
      ENDIF
      return ["PUSH", NULL, `lidx_sfxexpr[1][2], `lidx_expr[1], `lidx_ariexpr[1]]
    ENDIF
    `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, 1)
    IF `length(`lidx_expr) == 1:
      return `lidx_expr[0]
    ENDIF
    IF `lidx_expr[0] == `length(`lidxs)-1:
      return ["PUSH", NULL, ["VAR", `lexer.`tokenExtra(`tokens[`lidxs[0]])], `lidx_expr[1], NULL]
    ENDIF
    `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx_expr[0])
    IF `length(`lidx_ariexpr) == 1:
      return `lidx_ariexpr[0]
    ENDIF
    IF `lidx_ariexpr[0] != `length(`lidxs)-1:
      return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"PUSH", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_ariexpr[0]]]), []]
    ENDIF
    return ["PUSH", NULL, ["VAR", `lexer.`tokenExtra(`tokens[`lidxs[0]])], `lidx_expr[1], `lidx_ariexpr[1]]

  METHOD `_parseQueue(`tokens `lidxs `lidx_sfxexpr):
    VAR `lidx_expr
    IF `not(`isnull(`lidx_sfxexpr)):
      `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx_sfxexpr[0])
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"QUEUE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      return ["QUEUE", NULL, `lidx_sfxexpr[1][2], `lidx_expr[1]]
    ENDIF
    `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, 1)
    IF `length(`lidx_expr) == 1:
      return `lidx_expr[0]
    ENDIF
    IF `lidx_expr[0] != `length(`lidxs)-1:
      return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"QUEUE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
    ENDIF
    return ["QUEUE", NULL, ["VAR", `lexer.`tokenExtra(`tokens[`lidxs[0]])], `lidx_expr[1]]

  METHOD `_parsePop(`tokens `lidxs `lidx_sfxexpr):
    VAR `lidx_expr
    IF `not(`isnull(`lidx_sfxexpr)):
      IF `lidx_sfxexpr[0] == `length(`lidxs)-1:
        return ["ASSIGN_POP", NULL, NULL, NULL, `lidx_sfxexpr[1][2], NULL]
      ENDIF
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx_sfxexpr[0])
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"POP", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      return ["ASSIGN_POP", NULL, NULL, NULL, `lidx_sfxexpr[1][2], `lidx_expr[1]]
    ENDIF
    IF `length(`lidxs) == 2:
      return ["ASSIGN_POP", NULL, NULL, NULL, ["VAR", `lexer.`tokenExtra(`tokens[`lidxs[0]])], NULL]
    ENDIF
    `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, 1)
    IF `length(`lidx_expr) == 1:
      return `lidx_expr[0]
    ENDIF
    IF `lidx_expr[0] != `length(`lidxs)-1:
      return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"POP", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
    ENDIF
    return ["ASSIGN_POP", NULL, NULL, NULL, ["VAR", `lexer.`tokenExtra(`tokens[`lidxs[0]])], `lidx_expr[1]]

  METHOD `_parseUnqueue(`tokens `lidxs `lidx_sfxexpr):
    IF `not(`isnull(`lidx_sfxexpr)):
      IF `lidx_sfxexpr[0] != `length(`lidxs)-1:
        return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"UNQUEUE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_sfxexpr[0]]]), []]
      ENDIF
      return ["ASSIGN_UNQUEUE", NULL, NULL, NULL, `lidx_sfxexpr[1][2]]
    ENDIF
    IF `length(`lidxs) != 2:
      return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"UNQUEUE", `lexer.`tokenColumn(`tokens[`lidxs[1]]), []]
    ENDIF
    return ["ASSIGN_UNQUEUE", NULL, NULL, NULL, ["VAR", `lexer.`tokenExtra(`tokens[`lidxs[0]])]]

  METHOD `_parseUnassign(`tokens `lidxs):
    IF `lexer.`tokenName(`tokens[`lidxs[1]]) != "NEWLINE":
      return ["ERROR", NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"UNASSIGNMENT", `lexer.`tokenColumn(`tokens[`lidxs[1]]), []]
    ENDIF
    return ["UNASSIGN", NULL, `lexer.`tokenExtra(`tokens[`lidxs[0]])]

  METHOD `_parseLog(`tokens `lidxs):
    IF `length(`lidxs) <= 2:
      return ["ERROR", NULL, "EXPECTED"+" "+"STRING"+" "+"OR"+" "+"EXPRESSION"+" "+"AFTER"+" "+"LOG", `lexer.`tokenColumn(`tokens[`lidxs[1]]), []]
    ENDIF
    VAR `log_message = []
    VAR `lidx_expr
    VAR `j = 1
    WHILE `j < `length(`lidxs)-1:
      IF `lexer.`tokenName(`tokens[`lidxs[`j]]) == "STRING":
        `push(`log_message, ["STRING", `lexer.`tokenExtra(`tokens[`lidxs[`j]])])
        `j += 1
        continue
      ENDIF
      `lidx_expr = THIS.`_parseLogicalExpression(`tokens, `lidxs, `j)
      IF `length(`lidx_expr) != 1:
        `push(`log_message, `lidx_expr[1])
        `j = `lidx_expr[0]
        continue
      ENDIF
      `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `j)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      `push(`log_message, `lidx_expr[1])
      `j = `lidx_expr[0]
    ENDWHILE
    return ["LOG", NULL, `log_message]

  METHOD `_parseLogicalExpression(`tokens `lidxs `lidx):
    VAR `terms = []
    VAR `lidx_term = THIS.`_parseLogicalTerm(`tokens, `lidxs, `lidx)
    IF `length(`lidx_term) == 1:
      return `lidx_term
    ENDIF
    `push(`terms, `lidx_term[1])
    `lidx = `lidx_term[0]
    WHILE `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "OR":
      `lidx_term = THIS.`_parseLogicalTerm(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_term) == 1:
        return `lidx_term
      ENDIF
      `push(`terms, `lidx_term[1])
      `lidx = `lidx_term[0]
    ENDWHILE
    VAR `logical_expression = TERNARY{`length(`terms) == 1}{`terms[0]}{["OR", `terms]}
    return [`lidx, `logical_expression]

  METHOD `_parseLogicalTerm(`tokens `lidxs `lidx):
    VAR `factors = []
    VAR `lidx_factor = THIS.`_parseLogicalFactor(`tokens, `lidxs, `lidx)
    IF `length(`lidx_factor) == 1:
      return `lidx_factor
    ENDIF
    `push(`factors, `lidx_factor[1])
    `lidx = `lidx_factor[0]
    WHILE `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "AND":
      `lidx_factor = THIS.`_parseLogicalFactor(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_factor) == 1:
        return `lidx_factor
      ENDIF
      `push(`factors, `lidx_factor[1])
      `lidx = `lidx_factor[0]
    ENDWHILE
    VAR `logical_term = TERNARY{`length(`factors) == 1}{`factors[0]}{["AND", `factors]}
    return [`lidx, `logical_term]

  METHOD `_parseLogicalFactor(`tokens `lidxs `lidx):
    VAR `logical_factor
    VAR `lidx_factor
    VAR `lidx_logexpr
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "NOT":
      `lidx_factor = THIS.`_parseLogicalFactor(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_factor) == 1:
        return `lidx_factor
      ENDIF
      IF `lidx_factor[1][0] == "NOT":
        `logical_factor = `lidx_factor[1][1]
      ELSIF `lidx_factor[1][0] == "EQ":
        `logical_factor = ["NE", `lidx_factor[1][1], `lidx_factor[1][2]]
      ELSIF `lidx_factor[1][0] == "NE":
        `logical_factor = ["EQ", `lidx_factor[1][1], `lidx_factor[1][2]]
      ELSIF `lidx_factor[1][0] == "LT":
        `logical_factor = ["GE", `lidx_factor[1][1], `lidx_factor[1][2]]
      ELSIF `lidx_factor[1][0] == "LE":
        `logical_factor = ["GT", `lidx_factor[1][1], `lidx_factor[1][2]]
      ELSIF `lidx_factor[1][0] == "GT":
        `logical_factor = ["LE", `lidx_factor[1][1], `lidx_factor[1][2]]
      ELSIF `lidx_factor[1][0] == "GE":
        `logical_factor = ["LT", `lidx_factor[1][1], `lidx_factor[1][2]]
      ELSIF `lidx_factor[1][0] == "IS_VAR":
        `logical_factor = ["IS_NOT_VAR", `lidx_factor[1][1], `lidx_factor[1][2]]
      ELSIF `lidx_factor[1][0] == "IS_NOT_VAR":
        `logical_factor = ["IS_VAR", `lidx_factor[1][1], `lidx_factor[1][2]]
      ELSE:
        `logical_factor = ["NOT", `lidx_factor[1]]
      ENDIF
      return `logical_factor
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "LPAR":
      `lidx_logexpr = THIS.`_parseLogicalExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_logexpr) == 1:
        return `lidx_logexpr
      ENDIF
      IF `lexer.`tokenName(`tokens[`lidxs[`lidx_logexpr[0]]]) == "RPAR":
        return [`lidx_logexpr[0]+1, `lidx_logexpr[1]]
      ENDIF
      return [["ERROR", NULL, "EXPECTED"+" "+"RPAR"+" "+"IN"+" "+"LOGICAL"+" "+"FACTOR", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_logexpr[0]]]), []]]
    ENDIF
    return THIS.`_parseRelationalExpression(`tokens, `lidxs, `lidx)

  METHOD `_parseRelationalExpression(`tokens `lidxs `lidx):
    VAR `rel_op
    IF (`lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "VAR") AND ((`lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "IS") OR (`lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "IS_NOT")):
      IF (`lexer.`tokenName(`tokens[`lidxs[`lidx+2]]) == "INTEGER") OR (`lexer.`tokenName(`tokens[`lidxs[`lidx+2]]) == "LIST") OR (`lexer.`tokenName(`tokens[`lidxs[`lidx+2]]) == "UNDEFINED"):
        return [`lidx+3, [TERNARY{`lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "IS"}{"IS_VAR"}{"IS_NOT_VAR"}, ["VAR", `lexer.`tokenValue(`tokens[`lidxs[`lidx]])], `lexer.`tokenName(`tokens[`lidxs[`lidx+2]])]]
      ENDIF
      IF `lexer.`tokenName(`tokens[`lidxs[`lidx+2]]) == "PROCEDURE":
        `rel_op = TERNARY{`lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "IS"}{"NE"}{"EQ"}
        return [`lidx+3, [`rel_op, ["INTEGER", 1], ["INTEGER", 1]]]
      ENDIF
      return [["ERROR", NULL, "EXPECTED"+" "+"TYPE"+" "+"IN"+" "+"RELATIONAL"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+2]]), []]]
    ENDIF
    IF (`lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "QUALVAR") AND ((`lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "IS") OR (`lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "IS_NOT")):
      IF (`lexer.`tokenName(`tokens[`lidxs[`lidx+2]]) == "INTEGER") OR (`lexer.`tokenName(`tokens[`lidxs[`lidx+2]]) == "LIST") OR (`lexer.`tokenName(`tokens[`lidxs[`lidx+2]]) == "PROCEDURE") OR (`lexer.`tokenName(`tokens[`lidxs[`lidx+2]]) == "UNDEFINED"):
        return [`lidx+3, [TERNARY{`lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "IS"}{"IS_VAR"}{"IS_NOT_VAR"}, ["QUALVAR", `lexer.`tokenValue(`tokens[`lidxs[`lidx]])], `lexer.`tokenName(`tokens[`lidxs[`lidx+2]])]]
      ENDIF
      return [["ERROR", NULL, "EXPECTED"+" "+"TYPE"+" "+"IN"+" "+"RELATIONAL"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+2]]), []]]
    ENDIF
    VAR `lidx_sfxexpr = THIS.`_parseVarSuffix(`tokens, `lidxs, `lidx)
    IF (`length(`lidx_sfxexpr) > 1) AND (`lidx_sfxexpr[1][1] == "") AND ((`lidx_sfxexpr[1][2][0] == "LIST_AT_VAR") OR (`lidx_sfxexpr[1][2][0] == "LIST_AT_QUALVAR")) AND ((`lexer.`tokenName(`tokens[`lidxs[`lidx_sfxexpr[0]]]) == "IS") OR (`lexer.`tokenName(`tokens[`lidxs[`lidx_sfxexpr[0]]]) == "IS_NOT")):
      IF (`lexer.`tokenName(`tokens[`lidxs[`lidx_sfxexpr[0]+1]]) == "INTEGER") OR (`lexer.`tokenName(`tokens[`lidxs[`lidx_sfxexpr[0]+1]]) == "LIST"):
        return [`lidx_sfxexpr[0]+2, [TERNARY{`lexer.`tokenName(`tokens[`lidxs[`lidx_sfxexpr[0]]]) == "IS"}{"IS_VAR"}{"IS_NOT_VAR"}, `lidx_sfxexpr[1][2], `lexer.`tokenName(`tokens[`lidxs[`lidx_sfxexpr[0]+1]])]]
      ENDIF
      return [["ERROR", NULL, "EXPECTED"+" "+"DATATYPE"+" "+"IN"+" "+"RELATIONAL"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_sfxexpr[0]+1]]), []]]
    ENDIF
    VAR `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx)
    IF `length(`lidx_ariexpr) == 1:
      return `lidx_ariexpr
    ENDIF
    `rel_op = `lexer.`tokenName(`tokens[`lidxs[`lidx_ariexpr[0]]])
    IF (`rel_op != "EQ") AND (`rel_op != "NE") AND (`rel_op != "LT") AND (`rel_op != "LE") AND (`rel_op != "GT") AND (`rel_op != "GE"):
      return [["ERROR", NULL, "EXPECTED"+" "+"OPERATOR"+" "+"IN"+" "+"RELATIONAL"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_ariexpr[0]]]), []]]
    ENDIF
    VAR `lidx_ariexpr2 = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx_ariexpr[0]+1)
    IF `length(`lidx_ariexpr2) == 1:
      return `lidx_ariexpr2
    ENDIF
    return [`lidx_ariexpr2[0], [`rel_op, `lidx_ariexpr[1], `lidx_ariexpr2[1]]]

  METHOD `_parseArithmeticOrListExpression(`tokens `lidxs `lidx):
    VAR `exprs
    VAR `lidx_expr
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "LSQR":
      IF `lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "RSQR":
        return [`lidx+2, ["LIST", []]]
      ENDIF
      `exprs = []
      `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr
      ENDIF
      `push(`exprs, `lidx_expr[1])
      `lidx = `lidx_expr[0]
      WHILE `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "COMMA":
        IF `lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) == "RSQR":
          `lidx += 1
          break
        ENDIF
        `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx+1)
        IF `length(`lidx_expr) == 1:
          return `lidx_expr
        ENDIF
        `push(`exprs, `lidx_expr[1])
        `lidx = `lidx_expr[0]
      ENDWHILE
      IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) != "RSQR":
        return [["ERROR", NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
      ENDIF
      return [`lidx+1, ["LIST", `exprs]]
    ENDIF
    return THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx)

  METHOD `_parseArithmeticExpression(`tokens `lidxs `lidx):
    VAR `unary_op
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "MINUS":
      `unary_op = "UNARY_MINUS"
      `lidx += 1
    ELSIF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "BIT_NOT":
      `unary_op = "BIT_NOT"
      `lidx += 1
    ELSIF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "PLUS":
      `unary_op = NULL
      `lidx += 1
    ELSE:
      `unary_op = NULL
    ENDIF
    VAR `lidx_term = THIS.`_parseArithmeticTerm(`tokens, `lidxs, `lidx)
    IF `length(`lidx_term) == 1:
      return `lidx_term
    ENDIF
    VAR `expr = `lidx_term[1]
    IF `unary_op == "UNARY_MINUS":
      `expr = ["NEG", `expr]
    ELSIF `unary_op == "BIT_NOT":
      `expr = ["BIT_NOT", `expr]
    ENDIF
    `lidx = `lidx_term[0]
    WHILE (`lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "PLUS") OR (`lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "MINUS") OR (`lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "BIT_OR") OR (`lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "BIT_XOR"):
      `lidx_term = THIS.`_parseArithmeticTerm(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_term) == 1:
        return `lidx_term
      ENDIF
      `expr = [`lexer.`tokenName(`tokens[`lidxs[`lidx]]), `expr, `lidx_term[1]]
      `lidx = `lidx_term[0]
    ENDWHILE
    return [`lidx, `expr]

  METHOD `_parseArithmeticTerm(`tokens `lidxs `lidx):
    VAR `lidx_factor = THIS.`_parseArithmeticFactor(`tokens, `lidxs, `lidx)
    IF `length(`lidx_factor) == 1:
      return `lidx_factor
    ENDIF
    VAR `term = `lidx_factor[1]
    `lidx = `lidx_factor[0]
    WHILE (`lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "MUL") OR (`lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "DIV") OR (`lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "MOD") OR (`lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "BIT_AND") OR (`lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "BIT_SHL") OR (`lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "BIT_SHR"):
      `lidx_factor = THIS.`_parseArithmeticFactor(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_factor) == 1:
        return `lidx_factor
      ENDIF
      `term = [`lexer.`tokenName(`tokens[`lidxs[`lidx]]), `term, `lidx_factor[1]]
      `lidx = `lidx_factor[0]
    ENDWHILE
    return [`lidx, `term]

  METHOD `_parseArithmeticFactor(`tokens `lidxs `lidx):
    VAR `lidx_ariexpr
    VAR `length_var
    VAR `size_var
    VAR `isize_var
    VAR `lsize_var
    VAR `lidx_expr
    VAR `indexof_var
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "DECIMAL":
      return [`lidx+1, ["INTEGER", `int32(`parse_int(`lexer.`tokenValue(`tokens[`lidxs[`lidx]]), 10) & 0xffffffff)]]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "HEXADECIMAL":
      return [`lidx+1, ["INTEGER", `int32(`parse_int(`lexer.`tokenValue(`tokens[`lidxs[`lidx]]), 16) & 0xffffffff)]]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "LPAR":
      `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_ariexpr) == 1:
        return `lidx_ariexpr
      ENDIF
      IF `lexer.`tokenName(`tokens[`lidxs[`lidx_ariexpr[0]]]) == "RPAR":
        return [`lidx_ariexpr[0]+1, `lidx_ariexpr[1]]
      ENDIF
      return [["ERROR", NULL, "EXPECTED"+" "+"RPAR"+" "+"IN"+" "+"ARITHMETIC"+" "+"FACTOR", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_ariexpr[0]]]), []]]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "LENGTH":
      `length_var = `lexer.`tokenExtra(`tokens[`lidxs[`lidx]])
      return [`lidx+1, ["LENGTH_VAR", [TERNARY{`indexof(`length_var, ".") < 0}{"VAR"}{"QUALVAR"}, `length_var]]]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "SIZE":
      `size_var = `lexer.`tokenExtra(`tokens[`lidxs[`lidx]])
      return [`lidx+1, ["SIZE_VAR", [TERNARY{`indexof(`size_var, ".") < 0}{"VAR"}{"QUALVAR"}, `size_var]]]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "ISIZE":
      `isize_var = `lexer.`tokenExtra(`tokens[`lidxs[`lidx]])
      return [`lidx+1, ["ISIZE_VAR", [TERNARY{`indexof(`isize_var, ".") < 0}{"VAR"}{"QUALVAR"}, `isize_var]]]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "LSIZE":
      `lsize_var = `lexer.`tokenExtra(`tokens[`lidxs[`lidx]])
      return [`lidx+1, ["LSIZE_VAR", [TERNARY{`indexof(`lsize_var, ".") < 0}{"VAR"}{"QUALVAR"}, `lsize_var]]]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "INDEXOF":
      `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr
      ENDIF
      `indexof_var = `lexer.`tokenExtra(`tokens[`lidxs[`lidx]])
      `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx_expr[0])
      IF `length(`lidx_ariexpr) == 1:
        return [`lidx_expr[0], ["INDEXOF_VAR", [TERNARY{`indexof(`indexof_var, ".") < 0}{"VAR"}{"QUALVAR"}, `indexof_var], `lidx_expr[1], ["INTEGER", 0]]]
      ENDIF
      return [`lidx_ariexpr[0], ["INDEXOF_VAR", [TERNARY{`indexof(`indexof_var, ".") < 0}{"VAR"}{"QUALVAR"}, `indexof_var], `lidx_expr[1], `lidx_ariexpr[1]]]
    ENDIF
    VAR `lidx_sfxexpr = THIS.`_parseVarSuffix(`tokens, `lidxs, `lidx)
    IF (`length(`lidx_sfxexpr) > 1) AND ((`lidx_sfxexpr[1][1] == "") OR (`lidx_sfxexpr[1][1] == "LENGTH") OR (`lidx_sfxexpr[1][1] == "SIZE") OR (`lidx_sfxexpr[1][1] == "ISIZE") OR (`lidx_sfxexpr[1][1] == "LSIZE") OR (`lidx_sfxexpr[1][1] == "INDEXOF")):
      return [`lidx_sfxexpr[0], `lidx_sfxexpr[1][2]]
    ENDIF
    return [["ERROR", NULL, "EXPECTED"+" "+"ARITHMETIC"+" "+"FACTOR", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]

  METHOD `_parseVarSuffix(`tokens `lidxs `lidx):
    VAR `vvar
    VAR `exprs
    VAR `lidx_ariexpr
    VAR `suffix
    VAR `lidx_expr
    VAR `qualvar
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "VAR":
      `vvar = `lexer.`tokenValue(`tokens[`lidxs[`lidx]])
      IF `lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) != "LSQR":
        return [`lidx+1, ["SUFFIX", "", ["VAR", `vvar]]]
      ENDIF
      `lidx += 1
      `exprs = []
      WHILE `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "LSQR":
        `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
        IF `length(`lidx_ariexpr) == 1:
          return `lidx_ariexpr
        ENDIF
        `lidx = `lidx_ariexpr[0]
        IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) != "RSQR":
          return [["ERROR", NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST"+" "+"INDEX", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
        ENDIF
        `push(`exprs, `lidx_ariexpr[1])
        `lidx += 1
      ENDWHILE
      IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) != "SUFFIX":
        return [`lidx, ["SUFFIX", "", ["LIST_AT_VAR", `vvar, `exprs]]]
      ENDIF
      `suffix = `lexer.`tokenExtra(`tokens[`lidxs[`lidx]])
      IF `suffix == "LENGTH":
        return [`lidx+1, ["SUFFIX", "LENGTH", ["LENGTH_VAR", ["LIST_AT_VAR", `vvar, `exprs]]]]
      ELSIF `suffix == "SIZE":
        return [`lidx+1, ["SUFFIX", "SIZE", ["SIZE_VAR", ["LIST_AT_VAR", `vvar, `exprs]]]]
      ELSIF `suffix == "ISIZE":
        return [`lidx+1, ["SUFFIX", "ISIZE", ["ISIZE_VAR", ["LIST_AT_VAR", `vvar, `exprs]]]]
      ELSIF `suffix == "LSIZE":
        return [`lidx+1, ["SUFFIX", "LSIZE", ["LSIZE_VAR", ["LIST_AT_VAR", `vvar, `exprs]]]]
      ELSIF `suffix == "INDEXOF":
        `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx+1)
        IF `length(`lidx_expr) == 1:
          return `lidx_expr
        ENDIF
        `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx_expr[0])
        IF `length(`lidx_ariexpr) == 1:
          return [`lidx_expr[0], ["SUFFIX", "INDEXOF", ["INDEXOF_VAR", ["LIST_AT_VAR", `vvar, `exprs], `lidx_expr[1], ["INTEGER", 0]]]]
        ENDIF
        return [`lidx_ariexpr[0], ["SUFFIX", "INDEXOF", ["INDEXOF_VAR", ["LIST_AT_VAR", `vvar, `exprs], `lidx_expr[1], `lidx_ariexpr[1]]]]
      ENDIF
      IF `suffix == "PUSH":
        return [`lidx+1, ["SUFFIX", "PUSH", ["LIST_AT_VAR", `vvar, `exprs]]]
      ELSIF `suffix == "QUEUE":
        return [`lidx+1, ["SUFFIX", "QUEUE", ["LIST_AT_VAR", `vvar, `exprs]]]
      ELSIF `suffix == "POP":
        return [`lidx+1, ["SUFFIX", "POP", ["LIST_AT_VAR", `vvar, `exprs]]]
      ELSIF `suffix == "UNQUEUE":
        return [`lidx+1, ["SUFFIX", "UNQUEUE", ["LIST_AT_VAR", `vvar, `exprs]]]
      ENDIF
      return [`lidx, ["SUFFIX", "", ["LIST_AT_VAR", `vvar, `exprs]]]
    ENDIF
    IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "QUALVAR":
      `qualvar = `lexer.`tokenValue(`tokens[`lidxs[`lidx]])
      IF `lexer.`tokenName(`tokens[`lidxs[`lidx+1]]) != "LSQR":
        return [`lidx+1, ["SUFFIX", "", ["QUALVAR", `qualvar]]]
      ENDIF
      `lidx += 1
      `exprs = []
      WHILE `lexer.`tokenName(`tokens[`lidxs[`lidx]]) == "LSQR":
        `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
        IF `length(`lidx_ariexpr) == 1:
          return `lidx_ariexpr
        ENDIF
        `lidx = `lidx_ariexpr[0]
        IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) != "RSQR":
          return [["ERROR", NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST"+" "+"INDEX", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
        ENDIF
        `push(`exprs, `lidx_ariexpr[1])
        `lidx += 1
      ENDWHILE
      IF `lexer.`tokenName(`tokens[`lidxs[`lidx]]) != "SUFFIX":
        return [`lidx, ["SUFFIX", "", ["LIST_AT_QUALVAR", `qualvar, `exprs]]]
      ENDIF
      `suffix = `lexer.`tokenExtra(`tokens[`lidxs[`lidx]])
      IF `suffix == "LENGTH":
        return [`lidx+1, ["SUFFIX", "LENGTH", ["LENGTH_VAR", ["LIST_AT_QUALVAR", `qualvar, `exprs]]]]
      ELSIF `suffix == "SIZE":
        return [`lidx+1, ["SUFFIX", "SIZE", ["SIZE_VAR", ["LIST_AT_QUALVAR", `qualvar, `exprs]]]]
      ELSIF `suffix == "ISIZE":
        return [`lidx+1, ["SUFFIX", "ISIZE", ["ISIZE_VAR", ["LIST_AT_QUALVAR", `qualvar, `exprs]]]]
      ELSIF `suffix == "LSIZE":
        return [`lidx+1, ["SUFFIX", "LSIZE", ["LSIZE_VAR", ["LIST_AT_QUALVAR", `qualvar, `exprs]]]]
      ELSIF `suffix == "INDEXOF":
        `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx+1)
        IF `length(`lidx_expr) == 1:
          return `lidx_expr
        ENDIF
        `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx_expr[0])
        IF `length(`lidx_ariexpr) == 1:
          return [`lidx_expr[0], ["SUFFIX", "INDEXOF", ["INDEXOF_VAR", ["LIST_AT_QUALVAR", `qualvar, `exprs], `lidx_expr[1], ["INTEGER", 0]]]]
        ENDIF
        return [`lidx_ariexpr[0], ["SUFFIX", "INDEXOF", ["INDEXOF_VAR", ["LIST_AT_QUALVAR", `qualvar, `exprs], `lidx_expr[1], `lidx_ariexpr[1]]]]
      ENDIF
      return [`lidx, ["SUFFIX", "", ["LIST_AT_QUALVAR", `qualvar, `exprs]]]
    ENDIF
    return [["ERROR", NULL, "EXPECTED"+" "+"VARIABLE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]

ENDCLASS

VAR `parser = NEW `Parser()

VAR `UtilsEditorM_control_tokens = ["IF", "ELSIF", "ELSE", "ENDIF", "REPEAT", "ENDREP", "REPNEXT", "REPSTOP"]
VAR `UtilsEditorM_indent_ignored = ["COMMENT", "NEWLINE", "ERROR"]

CLASS `UtilsEditorM:

  METHOD_INIT():
    THIS.`_control_tokens_if = ["IF", "ELSIF", "ELSE", "ENDIF"]
    THIS.`_control_tokens_repeat = ["REPEAT", "ENDREP"]
    THIS.`_control_tokens_repstop = ["REPNEXT", "REPSTOP"]
    THIS.`_indent_stmts = {}
    THIS.`_indent_stmts["IF"] = [0, 2]
    THIS.`_indent_stmts["ELSIF"] = [-2, 2]
    THIS.`_indent_stmts["ELSE"] = [-2, 2]
    THIS.`_indent_stmts["ENDIF"] = [-2, 0]
    THIS.`_indent_stmts["REPEAT"] = [0, 2]
    THIS.`_indent_stmts["ENDREP"] = [-2, 0]

  METHOD `lineastLine(`line_ast):
    return `line_ast[0]

  METHOD `lineastTokens(`line_ast):
    return `line_ast[1]

  METHOD `lineastAst(`line_ast):
    return `line_ast[2]

  METHOD `lineastControl(`line_ast):
    IF `length(`line_ast) <= 3:
      return NULL
    ENDIF
    return `line_ast[3]

  METHOD `indentStmts(`token):
    IF `not(`token in THIS.`_indent_stmts):
      return [0, 0]
    ENDIF
    VAR `indent_stmt = THIS.`_indent_stmts[`token]
    return [`indent_stmt[0], `indent_stmt[1]]

  METHOD `mkControlSets(`lines_control `sets_control `error_control `lines_id `lines_ast):
    VAR `processed_indexes = []
    VAR `j1
    VAR `set_control_indexes
    VAR `sets_control_index
    VAR `set_control
    VAR `j2
    VAR `lnid_j
    VAR `token_indent_j
    VAR `line_ast_j
    VAR `control_node_j
    VAR `error_data
    VAR `error_lnid
    VAR `error_message
    VAR `error_line_ast
    VAR `error_control_node
    FORINCR `j1(0 `length(`lines_control)):
      IF `indexof(`processed_indexes, `j1) >= 0:
        continue
      ENDIF
      `set_control_indexes = THIS.`_extractControlSetIndexes(`j1, `lines_control)
      `sets_control_index = `length(`sets_control)
      `set_control = []
      FORINCR `j2(0 `length(`set_control_indexes)):
        `lnid_j = `lines_control[`set_control_indexes[`j2]][0]
        `token_indent_j = `lines_control[`set_control_indexes[`j2]][1]
        `push(`set_control, [`lnid_j, `token_indent_j])
        `line_ast_j = `lines_ast[`lnid_j]
        `control_node_j = [`set_control_indexes[`j2], `sets_control_index]
        `push(`line_ast_j, `control_node_j)
      ENDFOR
      `push(`sets_control, `set_control)
      `error_data = THIS.`_mkControlError(`set_control)
      `error_lnid = `error_data[0]
      `error_message = `error_data[1]
      IF `not(`isnull(`error_lnid)):
        THIS.`setInsertLineId(`error_lnid, `error_control, `lines_id)
        `error_line_ast = `lines_ast[`error_lnid]
        `error_control_node = THIS.`lineastControl(`error_line_ast)
        `push(`error_control_node, `error_message)
      ENDIF
      `processed_indexes = `concat(`processed_indexes, `set_control_indexes)
      IF `length(`processed_indexes) >= `length(`lines_control):
        IF `length(`processed_indexes) > `length(`lines_control):
          `warning("Prequel"+" "+"UtilsEditorM"+" "+"mkControlSets"+":"+" "+"unhandled"+" "+"value"+":", [`processed_indexes, `lines_control])
        ENDIF
        break
      ENDIF
    ENDFOR

  METHOD `_extractControlSetIndexes(`index `lines_control):
    VAR `line_control = `lines_control[`index]
    VAR `lnid = `line_control[0]
    VAR `token_indent = `line_control[1]
    VAR `indent = `line_control[2]
    VAR `set_control = [`index]
    VAR `last_token_indent
    VAR `j
    VAR `lnid_j
    VAR `token_indent_j
    VAR `indent_j
    VAR `min_indent_repstop
    `index += 1
    IF `index >= `length(`lines_control):
      return `set_control
    ENDIF
    IF `token_indent == "IF":
      `last_token_indent = "IF"
      `j = `index
      WHILE `j < `length(`lines_control):
        `lnid_j = `lines_control[`j][0]
        `token_indent_j = `lines_control[`j][1]
        `indent_j = `lines_control[`j][2]
        IF `indent_j < `indent:
          break
        ENDIF
        IF `indent_j > `indent:
          `j += 1
          continue
        ENDIF
        IF `indexof(THIS.`_control_tokens_if, `token_indent_j) < 0:
          break
        ENDIF
        IF `token_indent_j == "IF":
          break
        ENDIF
        IF `token_indent_j == "ENDIF":
          `push(`set_control, `j)
          break
        ENDIF
        IF `last_token_indent == "ELSE":
          break
        ENDIF
        `push(`set_control, `j)
        `last_token_indent = `token_indent_j
        `j += 1
      ENDWHILE
    ELSIF `token_indent == "REPEAT":
      `min_indent_repstop = -1
      `j = `index
      WHILE `j < `length(`lines_control):
        `lnid_j = `lines_control[`j][0]
        `token_indent_j = `lines_control[`j][1]
        `indent_j = `lines_control[`j][2]
        IF `indent_j < `indent:
          break
        ENDIF
        IF `indent_j == `indent:
          IF `token_indent_j == "ENDREP":
            `push(`set_control, `j)
          ENDIF
          break
        ENDIF
        IF `token_indent_j == "REPEAT":
          IF (`min_indent_repstop < 0) OR (`min_indent_repstop > `indent_j):
            `min_indent_repstop = `indent_j
          ENDIF
          `j += 1
          continue
        ENDIF
        IF `indexof(THIS.`_control_tokens_repstop, `token_indent_j) < 0:
          IF `indent_j <= `min_indent_repstop:
            `min_indent_repstop = -1
          ENDIF
          `j += 1
          continue
        ENDIF
        IF (`min_indent_repstop >= 0) AND (`min_indent_repstop < `indent_j):
          `j += 1
          continue
        ENDIF
        `push(`set_control, `j)
        `j += 1
      ENDWHILE
    ENDIF
    return `set_control

  METHOD `_mkControlError(`set_control):
    VAR `error_lnid
    VAR `error_message
    IF `set_control[0][1] == "IF":
      IF `set_control[`length(`set_control)-1][1] == "ENDIF":
        return [NULL, NULL]
      ENDIF
      `error_lnid = `set_control[`length(`set_control)-1][0]
      IF `set_control[`length(`set_control)-1][1] == "IF":
        `error_message = "IF"+" "+"WITHOUT"+" "+"ENDIF"
      ELSIF `set_control[`length(`set_control)-1][1] == "ELSIF":
        `error_message = "ELSIF"+" "+"WITHOUT"+" "+"ENDIF"
      ELSE:
        `error_message = "ELSE"+" "+"WITHOUT"+" "+"ENDIF"
      ENDIF
      return [`error_lnid, `error_message]
    ENDIF
    IF `set_control[0][1] == "REPEAT":
      IF `set_control[`length(`set_control)-1][1] == "ENDREP":
        return [NULL, NULL]
      ENDIF
      return [`set_control[0][0], "REPEAT"+" "+"WITHOUT"+" "+"ENDREP"]
    ENDIF
    `error_lnid = `set_control[0][0]
    IF `set_control[0][1] == "ELSIF":
      `error_message = "ELSIF"+" "+"WITHOUT"+" "+"IF"
    ELSIF `set_control[0][1] == "ELSE":
      `error_message = "ELSE"+" "+"WITHOUT"+" "+"IF"
    ELSIF `set_control[0][1] == "ENDIF":
      `error_message = "ENDIF"+" "+"WITHOUT"+" "+"IF"
    ELSIF `set_control[0][1] == "REPNEXT":
      `error_message = "REPNEXT"+" "+"WITHOUT"+" "+"REPEAT"
    ELSIF `set_control[0][1] == "REPSTOP":
      `error_message = "REPSTOP"+" "+"WITHOUT"+" "+"REPEAT"
    ELSE:
      `error_message = "ENDREP"+" "+"WITHOUT"+" "+"REPEAT"
    ENDIF
    return [`error_lnid, `error_message]

  METHOD `setInsertLineId(`lnid `set_ `lines_id):
    VAR `index = `indexof(`set_, `lnid)
    IF `index >= 0:
      return
    ENDIF
    VAR `lnno = `indexof(`lines_id, `lnid)
    `index = 0
    VAR `j
    FORDECR `j(`length(`set_)-1 0):
      IF `lnno <= `indexof(`lines_id, `set_[`j]):
        continue
      ENDIF
      `index = `j+1
      break
    ENDFOR
    `poke(`set_, `index, `lnid)

  METHOD `setDeleteLineId(`lnid `set_):
    VAR `index = `indexof(`set_, `lnid)
    WHILE `index >= 0:
      `pick(`set_, `index)
      `index = `indexof(`set_, `lnid)
    ENDWHILE

ENDCLASS

VAR `utils_editor_m = NEW `UtilsEditorM()

CLASS `EditorM:

  METHOD_INIT(`source_code):
    THIS.`_lnids = NEW `ResourceIds()
    THIS.`_lines_id = []
    THIS.`setSourceCode(`source_code)

  METHOD `setSourceCode(`source_code):
    VAR `ast_node
    VAR `bptn_lnid
    VAR `indent
    VAR `indent_stmt
    VAR `is_breakpoint
    VAR `j
    VAR `j1
    VAR `line_indent
    VAR `lines
    VAR `lnid
    VAR `lnno
    VAR `token_indent
    VAR `tokens
    FORINCR `j(0 `length(THIS.`_lines_id)):
      `lnid = THIS.`_lines_id[`j]
      THIS.`_lnids.`free(`lnid)
    ENDFOR
    IF (`length(`source_code) > 0) AND (`source_code[`length(`source_code)-1] != `chr_lf):
      `source_code += `chr_lf
    ENDIF
    `source_code = `lexer.`normalize(`source_code)
    `lines = `split(`source_code, `chr_lf)
    `push(`lines, "")
    THIS.`_lines_id = []
    THIS.`_lines_ast = {}
    THIS.`_error_lines = []
    THIS.`_lines_indent = [[0, 0]]
    THIS.`_error_indents = []
    THIS.`_lines_control = []
    THIS.`_sets_control = []
    THIS.`_error_control = []
    THIS.`_cut_lines = []
    THIS.`_cut_lnno = -1
    THIS.`_breakpoints = []
    `is_breakpoint = FALSE
    FORINCR `j1(0 `length(`lines)-1):
      IF `lines[`j1] == "#pragma"+" "+"breakpoint":
        `is_breakpoint = TRUE
        continue
      ENDIF
      `lnid = THIS.`_lnids.`alloc()
      `lnno = `length(THIS.`_lines_id)
      `tokens = `lexer.`lexLine(`lines[`j1])
      `ast_node = `parser.`parseLine(`tokens)
      IF `not(`isnull(`ast_node)) AND (`ast_node[0] == "ERROR"):
        `push(THIS.`_error_lines, `lnid)
      ENDIF
      `line_indent = THIS.`_lines_indent[`lnno]
      `indent = `length(`lexer.`tokenValue(`tokens[0]))
      `token_indent = `lexer.`tokenName(`tokens[1])
      IF `indexof(`UtilsEditorM_indent_ignored, `token_indent) >= 0:
        `push(THIS.`_lines_indent, [`line_indent[0], `line_indent[1]])
      ELSE:
        `indent_stmt = `utils_editor_m.`indentStmts(`token_indent)
        `push(THIS.`_lines_indent, [`indent, `indent_stmt[1]])
        IF `indent != `line_indent[0]+`line_indent[1]+`indent_stmt[0]:
          `push(THIS.`_error_indents, `lnid)
        ENDIF
      ENDIF
      `push(THIS.`_lines_id, `lnid)
      THIS.`_lines_ast[`lnid] = [`lines[`j1], `tokens, `ast_node]
      IF `indexof(`UtilsEditorM_control_tokens, `token_indent) >= 0:
        `push(THIS.`_lines_control, [`lnid, `token_indent, `indent])
      ENDIF
      IF `is_breakpoint:
        `push(THIS.`_breakpoints, `lnid)
        `is_breakpoint = FALSE
      ENDIF
    ENDFOR
    `unqueue(THIS.`_lines_indent)
    `utils_editor_m.`mkControlSets(THIS.`_lines_control, THIS.`_sets_control, THIS.`_error_control, THIS.`_lines_id, THIS.`_lines_ast)
    THIS.`_inactive_breakpoints = []
    FORINCR `j(0 `length(THIS.`_breakpoints)):
      `bptn_lnid = THIS.`_breakpoints[`j]
      IF `not(`isnull(`utils_editor_m.`lineastAst(THIS.`_lines_ast[`bptn_lnid]))) AND (`indexof(THIS.`_error_lines, `bptn_lnid) < 0) AND (`indexof(THIS.`_error_indents, `bptn_lnid) < 0) AND (`indexof(THIS.`_error_control, `bptn_lnid) < 0):
        continue
      ENDIF
      `push(THIS.`_inactive_breakpoints, `bptn_lnid)
    ENDFOR
    THIS.`_parser_error = THIS.`_mkTopError()
    THIS.`_entry_lnid = NULL
    THIS.`_is_compiled = FALSE

  METHOD `getSourceCode():
    VAR `source_code = ""
    VAR `j
    VAR `lnid
    VAR `line
    FORINCR `j(0 `length(THIS.`_lines_id)-1):
      `lnid = THIS.`_lines_id[`j]
      `line = `utils_editor_m.`lineastLine(THIS.`_lines_ast[`lnid])
      `source_code += `line+`chr_lf
    ENDFOR
    return `source_code

  METHOD `getLnnoCount():
    return (`length(THIS.`_lines_id)-1)

  METHOD `getTokens(`lnno):
    VAR `lnid = THIS.`_lines_id[`lnno]
    return `utils_editor_m.`lineastTokens(THIS.`_lines_ast[`lnid])

  METHOD `getParserError():
    return THIS.`_parser_error

  METHOD `getEntryLnno():
    IF `isnull(THIS.`_entry_lnid):
      return -1
    ENDIF
    return `indexof(THIS.`_lines_id, THIS.`_entry_lnid)

  METHOD `_mkTopError():
    VAR `error_lnid
    VAR `error_lnno
    VAR `terr_lnid
    VAR `terr_lnno
    VAR `terr_startcol
    VAR `terr_endcol
    VAR `terr_message
    VAR `tokens
    IF `length(THIS.`_error_lines) > 0:
      `terr_lnid = THIS.`_error_lines[0]
      `terr_lnno = `indexof(THIS.`_lines_id, `terr_lnid)
      `terr_startcol = `utils_editor_m.`lineastAst(THIS.`_lines_ast[`terr_lnid])[3]
      `terr_endcol = `terr_startcol
      `terr_message = `utils_editor_m.`lineastAst(THIS.`_lines_ast[`terr_lnid])[2]
      `tokens = `utils_editor_m.`lineastTokens(THIS.`_lines_ast[`terr_lnid])
      IF (`length(`tokens) >= 4) AND (`lexer.`tokenName(`tokens[`length(`tokens)-3]) == "ERROR"):
        `terr_endcol = `terr_startcol+`length(`lexer.`tokenValue(`tokens[`length(`tokens)-3]))
      ENDIF
    ELSE:
      `terr_lnno = `length(THIS.`_lines_id)
    ENDIF
    IF `length(THIS.`_error_control) > 0:
      `error_lnid = THIS.`_error_control[0]
      `error_lnno = `indexof(THIS.`_lines_id, `error_lnid)
      IF `terr_lnno > `error_lnno:
        `terr_lnid = `error_lnid
        `terr_lnno = `error_lnno
        `tokens = `utils_editor_m.`lineastTokens(THIS.`_lines_ast[`terr_lnid])
        `terr_startcol = `length(`lexer.`tokenValue(`tokens[0]))
        `terr_endcol = `terr_startcol
        `terr_message = `utils_editor_m.`lineastControl(THIS.`_lines_ast[`terr_lnid])[2]
      ENDIF
    ENDIF
    IF `length(THIS.`_error_indents) > 0:
      `error_lnid = THIS.`_error_indents[0]
      `error_lnno = `indexof(THIS.`_lines_id, `error_lnid)
      IF `terr_lnno > `error_lnno:
        `terr_lnid = `error_lnid
        `terr_lnno = `error_lnno
        `tokens = `utils_editor_m.`lineastTokens(THIS.`_lines_ast[`terr_lnid])
        `terr_startcol = `length(`lexer.`tokenValue(`tokens[0]))
        `terr_endcol = `terr_startcol
        `terr_message = "INVALID"+" "+"INDENTATION"
      ENDIF
    ENDIF
    IF `terr_lnno >= `length(THIS.`_lines_id):
      return NULL
    ENDIF
    return [`terr_lnid, `terr_lnno, `terr_startcol, `terr_endcol, `terr_message]

  METHOD `getBreakpointsInfo():
    return [THIS.`_breakpoints, THIS.`_inactive_breakpoints]

  METHOD `hasBreakpoint(`lnno):
    VAR `lnid = THIS.`_lines_id[`lnno]
    return ((`indexof(THIS.`_breakpoints, `lnid) >= 0) AND (`indexof(THIS.`_inactive_breakpoints, `lnid) < 0))

  METHOD `setBreakpoint(`lnno):
    VAR `lnid = THIS.`_lines_id[`lnno]
    IF `indexof(THIS.`_breakpoints, `lnid) >= 0:
      return
    ENDIF
    `utils_editor_m.`setInsertLineId(`lnid, THIS.`_breakpoints, THIS.`_lines_id)
    IF `not(`isnull(`utils_editor_m.`lineastAst(THIS.`_lines_ast[`lnid]))) AND (`indexof(THIS.`_error_lines, `lnid) < 0) AND (`indexof(THIS.`_error_indents, `lnid) < 0) AND (`indexof(THIS.`_error_control, `lnid) < 0):
      return
    ENDIF
    `utils_editor_m.`setInsertLineId(`lnid, THIS.`_inactive_breakpoints, THIS.`_lines_id)

  METHOD `clearBreakpoint(`lnno):
    VAR `lnid = THIS.`_lines_id[`lnno]
    VAR `index = `indexof(THIS.`_breakpoints, `lnid)
    IF `index < 0:
      return
    ENDIF
    `pick(THIS.`_breakpoints, `index)
    `index = `indexof(THIS.`_inactive_breakpoints, `lnid)
    IF `index < 0:
      return
    ENDIF
    `pick(THIS.`_inactive_breakpoints, `index)

  METHOD `getLinesId():
    return THIS.`_lines_id

  METHOD `getLinesAst():
    return THIS.`_lines_ast

  METHOD `getEntryLnid():
    return THIS.`_entry_lnid

  METHOD `isCompiled():
    return THIS.`_is_compiled

  METHOD `compile():
    IF THIS.`_is_compiled:
      return
    ENDIF
    VAR `ast_node_endrep
    VAR `ast_node_if
    VAR `ast_node_j
    VAR `ast_node_prev_elsif_else
    VAR `ast_node_prev_if
    VAR `ast_node_repeat
    VAR `ast_node_repstop
    VAR `control_type_j_0
    VAR `j
    VAR `j1
    VAR `j2
    VAR `lnid_elsif_else
    VAR `lnid_endif
    VAR `lnid_endrep
    VAR `lnid_if
    VAR `lnid_j
    VAR `lnid_prev_elsif_else
    VAR `lnid_prev_if
    VAR `lnid_repeat
    VAR `lnid_repstop
    VAR `lnno_elsif_else
    VAR `lnno_prev_elsif_else
    VAR `prev_ast_node
    VAR `prev_lnid
    VAR `set_control_j
    VAR `type_if
    THIS.`_is_compiled = TRUE
    THIS.`_entry_lnid = NULL
    FORINCR `j(0 `length(THIS.`_lines_id)):
      `lnid_j = THIS.`_lines_id[`j]
      IF `isnull(`utils_editor_m.`lineastAst(THIS.`_lines_ast[`lnid_j])):
        continue
      ENDIF
      THIS.`_entry_lnid = `lnid_j
      break
    ENDFOR
    IF `isnull(THIS.`_entry_lnid):
      return
    ENDIF
    `prev_lnid = THIS.`_entry_lnid
    `prev_ast_node = `utils_editor_m.`lineastAst(THIS.`_lines_ast[`prev_lnid])
    VAR `start_j = `indexof(THIS.`_lines_id, THIS.`_entry_lnid)+1
    FORINCR `j(`start_j `length(THIS.`_lines_id)):
      `lnid_j = THIS.`_lines_id[`j]
      `ast_node_j = `utils_editor_m.`lineastAst(THIS.`_lines_ast[`lnid_j])
      IF `isnull(`ast_node_j):
        continue
      ENDIF
      `prev_ast_node[1] = `lnid_j
      `prev_lnid = `lnid_j
      `prev_ast_node = `ast_node_j
    ENDFOR
    `prev_ast_node[1] = NULL
    FORINCR `j1(0 `length(THIS.`_sets_control)):
      `set_control_j = THIS.`_sets_control[`j1]
      `control_type_j_0 = `set_control_j[0][1]
      IF `control_type_j_0 == "IF":
        `lnid_prev_if = `set_control_j[0][0]
        `ast_node_prev_if = `utils_editor_m.`lineastAst(THIS.`_lines_ast[`lnid_prev_if])
        FORINCR `j2(1 `length(`set_control_j)):
          `lnid_if  = `set_control_j[`j2][0]
          `ast_node_if = `utils_editor_m.`lineastAst(THIS.`_lines_ast[`lnid_if])
          `ast_node_prev_if[2] = `lnid_if
          `type_if = `set_control_j[`j2][1]
          IF (`type_if != "IF") AND (`type_if != "ELSIF"):
            break
          ENDIF
          `lnid_prev_if = `lnid_if
          `ast_node_prev_if = `ast_node_if
        ENDFOR
        `lnid_endif = `set_control_j[`length(`set_control_j)-1][0]
        FORINCR `j2(1 `length(`set_control_j)-1):
          `lnid_elsif_else = `set_control_j[`j2][0]
          `lnno_elsif_else = `indexof(THIS.`_lines_id, `lnid_elsif_else)
          `lnno_prev_elsif_else = `lnno_elsif_else-1
          WHILE TRUE:
            `lnid_prev_elsif_else = THIS.`_lines_id[`lnno_prev_elsif_else]
            `ast_node_prev_elsif_else = `utils_editor_m.`lineastAst(THIS.`_lines_ast[`lnid_prev_elsif_else])
            IF `isnull(`ast_node_prev_elsif_else):
              `lnno_prev_elsif_else -= 1
              continue
            ENDIF
            IF `ast_node_prev_elsif_else[0] == "IF":
              break
            ELSIF `ast_node_prev_elsif_else[0] == "REPNEXT":
              break
            ELSIF `ast_node_prev_elsif_else[0] == "REPSTOP":
              break
            ENDIF
            `ast_node_prev_elsif_else[1] = `lnid_endif
            break
          ENDWHILE
        ENDFOR
      ELSE:
        `lnid_repeat = `set_control_j[0][0]
        `ast_node_repeat = `utils_editor_m.`lineastAst(THIS.`_lines_ast[`lnid_repeat])
        `lnid_endrep = `set_control_j[`length(`set_control_j)-1][0]
        `ast_node_endrep = `utils_editor_m.`lineastAst(THIS.`_lines_ast[`lnid_endrep])
        `ast_node_repeat[2] = `lnid_endrep
        `ast_node_endrep[2] = `lnid_repeat
        FORINCR `j2(1 `length(`set_control_j)-1):
          `lnid_repstop = `set_control_j[`j2][0]
          `ast_node_repstop = `utils_editor_m.`lineastAst(THIS.`_lines_ast[`lnid_repstop])
          `ast_node_repstop[1] = `lnid_endrep
        ENDFOR
      ENDIF
    ENDFOR

  METHOD `destroy():
    VAR `x = NULL

ENDCLASS

CLASS `Environment:

  METHOD_INIT():
    THIS.`reset()

  METHOD `reset():
    THIS.`_env = []

  METHOD `vars():
    VAR `vs = []
    VAR `j
    FORINCR `j(0 `length(THIS.`_env)):
      `push(`vs, THIS.`_env[`j][0])
    ENDFOR
    return `vs

  METHOD `set(`evar `evalue):
    VAR `j
    FORINCR `j(0 `length(THIS.`_env)):
      IF THIS.`_env[`j][0] == `evar:
        THIS.`_env[`j][1] = `evalue
        return
      ENDIF
    ENDFOR
    `push(THIS.`_env, [`evar, `evalue, 0])

  METHOD `overwrite(`evar `varvalue):
    VAR `j
    FORINCR `j(0 `length(THIS.`_env)):
      IF THIS.`_env[`j][0] == `evar:
        IF `not(`utils.`encodeOverwriteData(THIS.`_env[`j][1], `varvalue)):
          `pick(THIS.`_env, `j)
          return FALSE
        ENDIF
        return TRUE
      ENDIF
    ENDFOR
    return FALSE

  METHOD `get(`evar):
    VAR `count = 0
    VAR `evalue = NULL
    VAR `e
    VAR `j
    VAR `j2
    FORINCR `j(0 `length(THIS.`_env)):
      `count += 1
      IF THIS.`_env[`j][0] == `evar:
        THIS.`_env[`j][2] += `count
        `evalue = THIS.`_env[`j][1]
        `j2 = `j
        WHILE (`j2-1 >= 0) AND (THIS.`_env[`j2-1][2] < THIS.`_env[`j][2]):
          `j2 -= 1
        ENDWHILE
        IF `j2 == `j:
          break
        ENDIF
        `e = `pick(THIS.`_env, `j)
        `poke(THIS.`_env, `j2, `e)
        break
      ENDIF
    ENDFOR
    IF `not(`isnull(`evalue)) AND (THIS.`_env[0][2] >= 120000):
      FORINCR `j(0 `length(THIS.`_env)):
        IF THIS.`_env[`j][2] > 80000:
          THIS.`_env[`j][2] -= 80000
        ELSE:
          THIS.`_env[`j][2] = 0
        ENDIF
      ENDFOR
    ENDIF
    return `evalue

  METHOD `del(`evar):
    VAR `j
    FORINCR `j(0 `length(THIS.`_env)):
      IF THIS.`_env[`j][0] == `evar:
        `pick(THIS.`_env, `j)
        break
      ENDIF
    ENDFOR

  METHOD `destroy():
    WHILE `length(THIS.`_env) > 0:
      `pop(THIS.`_env)
    ENDWHILE
    THIS.`_env = NULL

ENDCLASS

VAR `INTERP_STATE_READY = 0
VAR `INTERP_STATE_LIMIT = 1
VAR `INTERP_STATE_PAUSE = 2
VAR `INTERP_STATE_YIELD = 3
VAR `INTERP_STATE_ERROR = 4
VAR `INTERP_STATE_ENDED = 5

FUNC `func_iexpr_rel_op_eq(`v1 `v2):
  return (`v1 == `v2)
ENDFUNC

FUNC `func_iexpr_rel_op_ne(`v1 `v2):
  return (`v1 != `v2)
ENDFUNC

FUNC `func_iexpr_rel_op_lt(`v1 `v2):
  return (`v1 < `v2)
ENDFUNC

FUNC `func_iexpr_rel_op_le(`v1 `v2):
  return (`v1 <= `v2)
ENDFUNC

FUNC `func_iexpr_rel_op_gt(`v1 `v2):
  return (`v1 > `v2)
ENDFUNC

FUNC `func_iexpr_rel_op_ge(`v1 `v2):
  return (`v1 >= `v2)
ENDFUNC

FUNC `func_iexpr_unary_op_neg(`v):
  return `int32((-`v) & 0xffffffff)
ENDFUNC

FUNC `func_iexpr_unary_op_bit_not(`v):
  return (~`v)
ENDFUNC

FUNC `func_iexpr_add_op_plus(`v1 `v2):
  return `int32((`v1+`v2) & 0xffffffff)
ENDFUNC

FUNC `func_iexpr_add_op_minus(`v1 `v2):
  return `int32((`v1-`v2) & 0xffffffff)
ENDFUNC

FUNC `func_iexpr_add_op_bit_or(`v1 `v2):
  return (`v1 | `v2)
ENDFUNC

FUNC `func_iexpr_add_op_bit_xor(`v1 `v2):
  return (`v1 ^ `v2)
ENDFUNC

FUNC `func_iexpr_mul_op_mul(`v1 `v2):
  return `int32((((`v1 & 0xffff) * (`v2 & 0xffff)) + ((`v1 & 0xffff0000) * (`v2 & 0xffff)) + ((`v1 & 0xffff) * (`v2 & 0xffff0000))) & 0xffffffff)
ENDFUNC

FUNC `func_iexpr_mul_op_div(`v1 `v2):
  return `int32(`trunc(`v1 / `v2) & 0xffffffff)
ENDFUNC

FUNC `func_iexpr_mul_op_mod(`v1 `v2):
  return `int32((`v1 % `v2) & 0xffffffff)
ENDFUNC

FUNC `func_iexpr_mul_op_bit_and(`v1 `v2):
  return (`v1 & `v2)
ENDFUNC

FUNC `func_iexpr_mul_op_bit_shl(`v1 `v2):
  IF `v2 >= 32:
    return 0
  ELSIF `v2 >= 0:
    return `int32(`v1 << `v2)
  ELSIF `v2 <= -31:
    return TERNARY{(`v1 & 0x80000000) == 0}{0}{-1}
  ENDIF
  return `int32(`v1 >> (-`v2))
ENDFUNC

FUNC `func_iexpr_mul_op_bit_shr(`v1 `v2):
  IF `v2 >= 31:
    return TERNARY{(`v1 & 0x80000000) == 0}{0}{-1}
  ELSIF `v2 >= 0:
    return `int32(`v1 >> `v2)
  ELSIF `v2 <= -32:
    return 0
  ENDIF
  return `int32(`v1 << (-`v2))
ENDFUNC

FUNC `func_iexpr_size_var_size(`lsize `isize):
  return (`lsize+`isize)
ENDFUNC

FUNC `func_iexpr_size_var_isize(`lsize `isize):
  return `isize
ENDFUNC

FUNC `func_iexpr_size_var_lsize(`lsize `isize):
  return `lsize
ENDFUNC

CLASS `InterpM:

  METHOD_INIT(`editor_m `getQualvar `onProcedure `onYieldResume `rnd32b `now):
    THIS.`_lines_id = `editor_m.`getLinesId()
    THIS.`_lines_ast = `editor_m.`getLinesAst()
    VAR `breakpoints_info = `editor_m.`getBreakpointsInfo()
    THIS.`_breakpoints = `breakpoints_info[0]
    THIS.`_entry_pcounter = `editor_m.`getEntryLnid()
    THIS.`_getQualvar = `getQualvar
    THIS.`_onProcedure = `onProcedure
    THIS.`_onYieldResume = `onYieldResume
    THIS.`_rnd32b = `rnd32b
    THIS.`_now = `now
    THIS.`_max_log_lines = NULL
    THIS.`_max_log_chars_per_line = NULL
    THIS.`_environment = NEW `Environment()
    THIS.`_varnames = []
    THIS.`_prev_pcounter = NULL
    THIS.`_pcounter = THIS.`_entry_pcounter
    THIS.`_repeat_vars = []
    THIS.`_has_repstop = FALSE
    THIS.`_log_lines = []
    THIS.`_changed_vars = []
    THIS.`_error = NULL
    THIS.`_status_code = NULL
    THIS.`_memory_delta_i = 0
    THIS.`_memory_delta_l = 0
    THIS.`_yield = FALSE
    THIS.`_procedure = NULL
    THIS.`_limits = `utils.`getNormalizedLimits(NULL)
    THIS.`_count = {}
    THIS.`_count[`key_limits_instructions] = NULL
    THIS.`_count[`key_limits_max_memory] = NULL
    THIS.`_count[`key_limits_memory] = NULL
    THIS.`_count[`key_limits_memory_i] = NULL
    THIS.`_count[`key_limits_memory_l] = NULL
    THIS.`_count[`key_limits_time] = NULL
    THIS.`_tmpInteger = [`key_interp_integer, 0, 0, 1]
    THIS.`_tmpBoolean = [`key_interp_boolean, TRUE]
    THIS.`_tmpByRef = [`key_interp_by_ref, NULL]
    THIS.`_tmpModuleName = [`key_interp_module_name, NULL]
    THIS.`_tmpString = [`key_interp_string, NULL]
    VAR `that = THIS
    CLOSURE `closure_istmt_assign_op(`instruction):
      `that.`_istmtAssignOp(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_assign_op_random(`instruction):
      `that.`_istmtAssignOpRandom(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_assign_pop(`instruction):
      `that.`_istmtAssignPop(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_assign_unqueue(`instruction):
      `that.`_istmtAssignUnqueue(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_if(`instruction):
      `that.`_istmtIf(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_elsif(`instruction):
      `that.`_istmtElsif(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_else(`instruction):
      `that.`_istmtElse(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_endif(`instruction):
      `that.`_istmtEndif(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_repeat(`instruction):
      `that.`_istmtRepeat(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_repnext(`instruction):
      `that.`_istmtRepnext(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_repstop(`instruction):
      `that.`_istmtRepstop(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_endrep(`instruction):
      `that.`_istmtEndrep(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_procedure(`instruction):
      `that.`_istmtProcedure(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_push(`instruction):
      `that.`_istmtPush(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_queue(`instruction):
      `that.`_istmtQueue(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_unassign(`instruction):
      `that.`_istmtUnassign(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_log(`instruction):
      `that.`_istmtLog(`instruction)
    ENDCLOSURE
    THIS.`_dispatch_stmt = {}
    THIS.`_dispatch_stmt["ASSIGN_OP"] = `closure_istmt_assign_op
    THIS.`_dispatch_stmt["ASSIGN_OP_RANDOM"] = `closure_istmt_assign_op_random
    THIS.`_dispatch_stmt["ASSIGN_POP"] = `closure_istmt_assign_pop
    THIS.`_dispatch_stmt["ASSIGN_UNQUEUE"] = `closure_istmt_assign_unqueue
    THIS.`_dispatch_stmt["IF"] = `closure_istmt_if
    THIS.`_dispatch_stmt["ELSIF"] = `closure_istmt_elsif
    THIS.`_dispatch_stmt["ELSE"] = `closure_istmt_else
    THIS.`_dispatch_stmt["ENDIF"] = `closure_istmt_endif
    THIS.`_dispatch_stmt["REPEAT"] = `closure_istmt_repeat
    THIS.`_dispatch_stmt["REPNEXT"] = `closure_istmt_repnext
    THIS.`_dispatch_stmt["REPSTOP"] = `closure_istmt_repstop
    THIS.`_dispatch_stmt["ENDREP"] = `closure_istmt_endrep
    THIS.`_dispatch_stmt["PROCEDURE"] = `closure_istmt_procedure
    THIS.`_dispatch_stmt["PUSH"] = `closure_istmt_push
    THIS.`_dispatch_stmt["QUEUE"] = `closure_istmt_queue
    THIS.`_dispatch_stmt["UNASSIGN"] = `closure_istmt_unassign
    THIS.`_dispatch_stmt["LOG"] = `closure_istmt_log
    CLOSURE `closure_iexpr_integer(`expression):
      return `that.`_iexprInteger(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_list(`expression):
      return `that.`_iexprList(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_by_ref(`expression):
      return `that.`_iexprByRef(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_module_name(`expression):
      return `that.`_iexprModuleName(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_string(`expression):
      return `that.`_iexprString(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_or(`expression):
      return `that.`_iexprOr(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_and(`expression):
      return `that.`_iexprAnd(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_not(`expression):
      return `that.`_iexprNot(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_rel_op_eq(`expression):
      return `that.`_iexprRelOp(`expression, `func_iexpr_rel_op_eq)
    ENDCLOSURE
    CLOSURE `closure_iexpr_rel_op_ne(`expression):
      return `that.`_iexprRelOp(`expression, `func_iexpr_rel_op_ne)
    ENDCLOSURE
    CLOSURE `closure_iexpr_rel_op_lt(`expression):
      return `that.`_iexprRelOp(`expression, `func_iexpr_rel_op_lt)
    ENDCLOSURE
    CLOSURE `closure_iexpr_rel_op_le(`expression):
      return `that.`_iexprRelOp(`expression, `func_iexpr_rel_op_le)
    ENDCLOSURE
    CLOSURE `closure_iexpr_rel_op_gt(`expression):
      return `that.`_iexprRelOp(`expression, `func_iexpr_rel_op_gt)
    ENDCLOSURE
    CLOSURE `closure_iexpr_rel_op_ge(`expression):
      return `that.`_iexprRelOp(`expression, `func_iexpr_rel_op_ge)
    ENDCLOSURE
    CLOSURE `closure_iexpr_unary_op_neg(`expression):
      return `that.`_iexprUnaryOp(`expression, `func_iexpr_unary_op_neg)
    ENDCLOSURE
    CLOSURE `closure_iexpr_unary_op_bit_not(`expression):
      return `that.`_iexprUnaryOp(`expression, `func_iexpr_unary_op_bit_not)
    ENDCLOSURE
    CLOSURE `closure_iexpr_add_op_plus(`expression):
      return `that.`_iexprAddOp(`expression, `func_iexpr_add_op_plus)
    ENDCLOSURE
    CLOSURE `closure_iexpr_add_op_minus(`expression):
      return `that.`_iexprAddOp(`expression, `func_iexpr_add_op_minus)
    ENDCLOSURE
    CLOSURE `closure_iexpr_add_op_bit_or(`expression):
      return `that.`_iexprAddOp(`expression, `func_iexpr_add_op_bit_or)
    ENDCLOSURE
    CLOSURE `closure_iexpr_add_op_bit_xor(`expression):
      return `that.`_iexprAddOp(`expression, `func_iexpr_add_op_bit_xor)
    ENDCLOSURE
    CLOSURE `closure_iexpr_mul_op_mul(`expression):
      return `that.`_iexprMulOp(`expression, `func_iexpr_mul_op_mul, NULL)
    ENDCLOSURE
    CLOSURE `closure_iexpr_mul_op_div(`expression):
      return `that.`_iexprMulOp(`expression, `func_iexpr_mul_op_div, "DIVISION"+" "+"BY"+" "+"ZERO")
    ENDCLOSURE
    CLOSURE `closure_iexpr_mul_op_mod(`expression):
      return `that.`_iexprMulOp(`expression, `func_iexpr_mul_op_mod, "MODULO"+" "+"BY"+" "+"ZERO")
    ENDCLOSURE
    CLOSURE `closure_iexpr_mul_op_bit_and(`expression):
      return `that.`_iexprMulOp(`expression, `func_iexpr_mul_op_bit_and, NULL)
    ENDCLOSURE
    CLOSURE `closure_iexpr_mul_op_bit_shl(`expression):
      return `that.`_iexprMulOp(`expression, `func_iexpr_mul_op_bit_shl, NULL)
    ENDCLOSURE
    CLOSURE `closure_iexpr_mul_op_bit_shr(`expression):
      return `that.`_iexprMulOp(`expression, `func_iexpr_mul_op_bit_shr, NULL)
    ENDCLOSURE
    CLOSURE `closure_iexpr_var(`expression):
      return `that.`_iexprVar(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_qualvar(`expression):
      return `that.`_iexprQualvar(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_is_var(`expression):
      return `that.`_iexprIsVar(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_is_not_var(`expression):
      return `that.`_iexprIsNotVar(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_length_var(`expression):
      return `that.`_iexprLengthVar(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_size_var_size(`expression):
      return `that.`_iexprSizeVar(`expression, `func_iexpr_size_var_size)
    ENDCLOSURE
    CLOSURE `closure_iexpr_size_var_isize(`expression):
      return `that.`_iexprSizeVar(`expression, `func_iexpr_size_var_isize)
    ENDCLOSURE
    CLOSURE `closure_iexpr_size_var_lsize(`expression):
      return `that.`_iexprSizeVar(`expression, `func_iexpr_size_var_lsize)
    ENDCLOSURE
    CLOSURE `closure_iexpr_indexof_var(`expression):
      return `that.`_iexprIndexofVar(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_list_at_var(`expression):
      return `that.`_iexprListAtVar(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_list_at_qualvar(`expression):
      return `that.`_iexprListAtQualvar(`expression)
    ENDCLOSURE
    THIS.`_dispatch_expr = {}
    THIS.`_dispatch_expr["INTEGER"] = `closure_iexpr_integer
    THIS.`_dispatch_expr["LIST"] = `closure_iexpr_list
    THIS.`_dispatch_expr["BY_REF"] = `closure_iexpr_by_ref
    THIS.`_dispatch_expr["MODULE_NAME"] = `closure_iexpr_module_name
    THIS.`_dispatch_expr["STRING"] = `closure_iexpr_string
    THIS.`_dispatch_expr["OR"] = `closure_iexpr_or
    THIS.`_dispatch_expr["AND"] = `closure_iexpr_and
    THIS.`_dispatch_expr["NOT"] = `closure_iexpr_not
    THIS.`_dispatch_expr["EQ"] = `closure_iexpr_rel_op_eq
    THIS.`_dispatch_expr["NE"] = `closure_iexpr_rel_op_ne
    THIS.`_dispatch_expr["LT"] = `closure_iexpr_rel_op_lt
    THIS.`_dispatch_expr["LE"] = `closure_iexpr_rel_op_le
    THIS.`_dispatch_expr["GT"] = `closure_iexpr_rel_op_gt
    THIS.`_dispatch_expr["GE"] = `closure_iexpr_rel_op_ge
    THIS.`_dispatch_expr["NEG"] = `closure_iexpr_unary_op_neg
    THIS.`_dispatch_expr["BIT_NOT"] = `closure_iexpr_unary_op_bit_not
    THIS.`_dispatch_expr["PLUS"] = `closure_iexpr_add_op_plus
    THIS.`_dispatch_expr["MINUS"] = `closure_iexpr_add_op_minus
    THIS.`_dispatch_expr["BIT_OR"] = `closure_iexpr_add_op_bit_or
    THIS.`_dispatch_expr["BIT_XOR"] = `closure_iexpr_add_op_bit_xor
    THIS.`_dispatch_expr["MUL"] = `closure_iexpr_mul_op_mul
    THIS.`_dispatch_expr["DIV"] = `closure_iexpr_mul_op_div
    THIS.`_dispatch_expr["MOD"] = `closure_iexpr_mul_op_mod
    THIS.`_dispatch_expr["BIT_AND"] = `closure_iexpr_mul_op_bit_and
    THIS.`_dispatch_expr["BIT_SHL"] = `closure_iexpr_mul_op_bit_shl
    THIS.`_dispatch_expr["BIT_SHR"] = `closure_iexpr_mul_op_bit_shr
    THIS.`_dispatch_expr["VAR"] = `closure_iexpr_var
    THIS.`_dispatch_expr["QUALVAR"] = `closure_iexpr_qualvar
    THIS.`_dispatch_expr["IS_VAR"] = `closure_iexpr_is_var
    THIS.`_dispatch_expr["IS_NOT_VAR"] = `closure_iexpr_is_not_var
    THIS.`_dispatch_expr["LENGTH_VAR"] = `closure_iexpr_length_var
    THIS.`_dispatch_expr["SIZE_VAR"] = `closure_iexpr_size_var_size
    THIS.`_dispatch_expr["ISIZE_VAR"] = `closure_iexpr_size_var_isize
    THIS.`_dispatch_expr["LSIZE_VAR"] = `closure_iexpr_size_var_lsize
    THIS.`_dispatch_expr["INDEXOF_VAR"] = `closure_iexpr_indexof_var
    THIS.`_dispatch_expr["LIST_AT_VAR"] = `closure_iexpr_list_at_var
    THIS.`_dispatch_expr["LIST_AT_QUALVAR"] = `closure_iexpr_list_at_qualvar
    THIS.`_data_v = NULL

  METHOD `readLog():
    VAR `log_lines = THIS.`_log_lines
    THIS.`_log_lines = []
    return `log_lines

  METHOD `readChangedVars():
    VAR `changed_vars = THIS.`_changed_vars
    THIS.`_changed_vars = []
    return `changed_vars

  METHOD `_addChangedVar(`varname):
    IF `indexof(THIS.`_changed_vars, `varname) >= 0:
      return
    ENDIF
    `push(THIS.`_changed_vars, `varname)

  METHOD `_getLnno(`lnid):
    IF `isnull(`lnid):
      return -1
    ENDIF
    return `indexof(THIS.`_lines_id, `lnid)

  METHOD `_setRuntimeError(`error_message):
    THIS.`_error = `error_message

  METHOD `getVarNames():
    return THIS.`_varnames

  METHOD `addVar(`varname `evalue):
    VAR `delta_cost_i = `utils.`isizeEvalue(`evalue)
    VAR `delta_cost_l = `utils.`lsizeEvalue(`evalue)
    THIS.`_memory_delta_i += `delta_cost_i
    THIS.`_memory_delta_l += `delta_cost_l
    THIS.`_addChangedVar(`varname)
    THIS.`_addVar(`varname, `evalue)

  METHOD `getVar(`varname):
    return THIS.`_environment.`get(`varname)

  METHOD `removeVar(`varname):
    VAR `evalue = THIS.`getVar(`varname)
    VAR `delta_cost_i = -`utils.`isizeEvalue(`evalue)
    VAR `delta_cost_l = -`utils.`lsizeEvalue(`evalue)
    THIS.`_memory_delta_i += `delta_cost_i
    THIS.`_memory_delta_l += `delta_cost_l
    THIS.`_addChangedVar(`varname)
    THIS.`_removeVar(`varname)

  METHOD `_addVar(`varname `evalue):
    IF `indexof(THIS.`_varnames, `varname) < 0:
      `push(THIS.`_varnames, `varname)
    ENDIF
    THIS.`_environment.`set(`varname, `evalue)

  METHOD `_removeVar(`varname):
    VAR `idx = `indexof(THIS.`_varnames, `varname)
    IF `idx >= 0:
      `pick(THIS.`_varnames, `idx)
    ENDIF
    THIS.`_environment.`del(`varname)

  METHOD `inRepeatVars(`varname):
    return (`indexof(THIS.`_repeat_vars, `varname) >= 0)

  METHOD `run(`instance `stepping `limits):
    return THIS.`_run(`instance, FALSE, `stepping, `limits)

  METHOD `resume(`instance `resume_yield `stepping `limits_):
    VAR `limits
    IF `not(`isnull(`limits_)):
      `limits = `limits_
    ELSE:
      `limits = THIS.`_limits
      IF `not(`isnull(`limits[`key_limits_instructions])):
        `limits[`key_limits_instructions] -= THIS.`_count[`key_limits_instructions]
      ENDIF
      IF `not(`isnull(`limits[`key_limits_memory])):
        `limits[`key_limits_memory] -= THIS.`_count[`key_limits_memory]
      ENDIF
      IF `not(`isnull(`limits[`key_limits_memory_i])):
        `limits[`key_limits_memory_i] -= THIS.`_count[`key_limits_memory_i]
      ENDIF
      IF `not(`isnull(`limits[`key_limits_memory_l])):
        `limits[`key_limits_memory_l] -= THIS.`_count[`key_limits_memory_l]
      ENDIF
      IF `not(`isnull(`limits[`key_limits_time])):
        `limits[`key_limits_time] -= THIS.`_count[`key_limits_time]
      ENDIF
    ENDIF
    return THIS.`_run(`instance, `resume_yield, `stepping, `limits)

  METHOD `reap():
    THIS.`_prev_pcounter = NULL
    THIS.`_pcounter = THIS.`_entry_pcounter
    THIS.`_repeat_vars = []
    THIS.`_has_repstop = FALSE
    THIS.`_log_lines = []
    THIS.`_changed_vars = []
    THIS.`_error = NULL
    THIS.`_status_code = NULL
    THIS.`_memory_delta_i = 0
    THIS.`_memory_delta_l = 0
    THIS.`_yield = FALSE
    THIS.`_procedure = NULL

  METHOD `reset():
    THIS.`_environment.`reset()
    THIS.`_varnames = []

  METHOD `getStatusCode():
    return THIS.`_status_code

  METHOD `returnWithStatus(`status_code):
    THIS.`_status_code = `status_code

  METHOD `prequelYield():
    THIS.`_yield = TRUE

  METHOD `runtimeError(`error_message):
    THIS.`_setRuntimeError(`error_message)

  METHOD `_run(`instance `resume_yield `stepping `limits):
    THIS.`_limits = `limits
    THIS.`_count[`key_limits_instructions] = 0
    THIS.`_count[`key_limits_max_memory] = 0
    THIS.`_count[`key_limits_memory] = 0
    THIS.`_count[`key_limits_memory_i] = 0
    THIS.`_count[`key_limits_memory_l] = 0
    THIS.`_count[`key_limits_time] = 0
    THIS.`_yield = FALSE
    VAR `force
    VAR `instruction
    VAR `next_pcounter
    VAR `status_code
    VAR `time_start
    VAR `was_procedure
    IF `resume_yield:
      THIS.`_error = NULL
      THIS.`_status_code = NULL
      THIS.`_memory_delta_i = 0
      THIS.`_memory_delta_l = 0
      `time_start = THIS.`_now()
      THIS.`_onYieldResume(`instance)
      IF `not(`isnull(THIS.`_error)):
        return [`INTERP_STATE_ERROR, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter), THIS.`_error]
      ENDIF
      THIS.`_count[`key_limits_memory] += (THIS.`_memory_delta_l+THIS.`_memory_delta_i)
      THIS.`_count[`key_limits_memory_i] += THIS.`_memory_delta_i
      THIS.`_count[`key_limits_memory_l] += THIS.`_memory_delta_l
      IF THIS.`_count[`key_limits_max_memory] < THIS.`_count[`key_limits_memory]:
        THIS.`_count[`key_limits_max_memory] = THIS.`_count[`key_limits_memory]
      ENDIF
      THIS.`_count[`key_limits_time] = THIS.`_now()-`time_start
      IF THIS.`_yield:
        return [`INTERP_STATE_YIELD, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter)]
      ENDIF
      `instruction = `utils_editor_m.`lineastAst(THIS.`_lines_ast[THIS.`_pcounter])
      `next_pcounter = `instruction[1]
      THIS.`_pcounter = `next_pcounter
      THIS.`_count[`key_limits_instructions] += 1
      IF `not(`isnull(THIS.`_status_code)):
        THIS.`_pcounter = NULL
        return [`INTERP_STATE_ENDED, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter), THIS.`_status_code]
      ENDIF
      IF `isnull(THIS.`_pcounter):
        `status_code = 0
        return [`INTERP_STATE_ENDED, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter), `status_code]
      ENDIF
      IF (`not(`isnull(THIS.`_limits[`key_limits_instructions])) AND (THIS.`_limits[`key_limits_instructions] <= THIS.`_count[`key_limits_instructions])) OR (`not(`isnull(THIS.`_limits[`key_limits_memory])) AND (THIS.`_limits[`key_limits_memory] <= THIS.`_count[`key_limits_memory])) OR (`not(`isnull(THIS.`_limits[`key_limits_memory_i])) AND (THIS.`_limits[`key_limits_memory_i] <= THIS.`_count[`key_limits_memory_i])) OR (`not(`isnull(THIS.`_limits[`key_limits_memory_l])) AND (THIS.`_limits[`key_limits_memory_l] <= THIS.`_count[`key_limits_memory_l])) OR (`not(`isnull(THIS.`_limits[`key_limits_time])) AND (THIS.`_limits[`key_limits_time] <= THIS.`_count[`key_limits_time])):
        return [`INTERP_STATE_LIMIT, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter)]
      ENDIF
    ENDIF
    IF `isnull(THIS.`_pcounter):
      `status_code = 0
      return [`INTERP_STATE_ENDED, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter), `status_code]
    ENDIF
    `force = (THIS.`_pcounter == THIS.`_prev_pcounter)
    `was_procedure = FALSE
    `time_start = THIS.`_now()
    WHILE TRUE:
      `instruction = `utils_editor_m.`lineastAst(THIS.`_lines_ast[THIS.`_pcounter])
      IF (`stepping OR (`indexof(THIS.`_breakpoints, THIS.`_pcounter) >= 0)) AND `not(`force):
        THIS.`_prev_pcounter = THIS.`_pcounter
        return [`INTERP_STATE_PAUSE, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter)]
      ENDIF
      THIS.`_interpStmt(`instruction)
      THIS.`_prev_pcounter = NULL
      `force = FALSE
      IF `not(`isnull(THIS.`_error)):
        return [`INTERP_STATE_ERROR, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter), THIS.`_error]
      ENDIF
      IF `not(`isnull(THIS.`_procedure)):
        THIS.`_onProcedure(`instance, THIS.`_procedure[0], THIS.`_procedure[1])
        THIS.`_procedure = NULL
        IF `not(`isnull(THIS.`_error)):
          return [`INTERP_STATE_ERROR, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter), THIS.`_error]
        ENDIF
        `was_procedure = TRUE
      ENDIF
      THIS.`_count[`key_limits_memory] += (THIS.`_memory_delta_l+THIS.`_memory_delta_i)
      THIS.`_count[`key_limits_memory_i] += THIS.`_memory_delta_i
      THIS.`_count[`key_limits_memory_l] += THIS.`_memory_delta_l
      IF THIS.`_count[`key_limits_max_memory] < THIS.`_count[`key_limits_memory]:
        THIS.`_count[`key_limits_max_memory] = THIS.`_count[`key_limits_memory]
      ENDIF
      THIS.`_count[`key_limits_time] = THIS.`_now()-`time_start
      IF THIS.`_yield:
        return [`INTERP_STATE_YIELD, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter)]
      ENDIF
      THIS.`_count[`key_limits_instructions] += 1
      IF `was_procedure:
        `was_procedure = FALSE
        `next_pcounter = `instruction[1]
        THIS.`_pcounter = `next_pcounter
      ENDIF
      IF `not(`isnull(THIS.`_status_code)):
        THIS.`_pcounter = NULL
        return [`INTERP_STATE_ENDED, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter), THIS.`_status_code]
      ENDIF
      IF `isnull(THIS.`_pcounter):
        `status_code = 0
        return [`INTERP_STATE_ENDED, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter), `status_code]
      ENDIF
      IF (`not(`isnull(THIS.`_limits[`key_limits_instructions])) AND (THIS.`_limits[`key_limits_instructions] <= THIS.`_count[`key_limits_instructions])) OR (`not(`isnull(THIS.`_limits[`key_limits_memory])) AND (THIS.`_limits[`key_limits_memory] <= THIS.`_count[`key_limits_memory])) OR (`not(`isnull(THIS.`_limits[`key_limits_memory_i])) AND (THIS.`_limits[`key_limits_memory_i] <= THIS.`_count[`key_limits_memory_i])) OR (`not(`isnull(THIS.`_limits[`key_limits_memory_l])) AND (THIS.`_limits[`key_limits_memory_l] <= THIS.`_count[`key_limits_memory_l])) OR (`not(`isnull(THIS.`_limits[`key_limits_time])) AND (THIS.`_limits[`key_limits_time] <= THIS.`_count[`key_limits_time])):
        return [`INTERP_STATE_LIMIT, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter)]
      ENDIF
    ENDWHILE

  METHOD `_interpStmt(`instruction):
    THIS.`_error = NULL
    THIS.`_status_code = NULL
    THIS.`_memory_delta_i = 0
    THIS.`_memory_delta_l = 0
    THIS.`_procedure = NULL
    VAR `opcode = `instruction[0]
    THIS.`_dispatch_stmt[`opcode](`instruction)

  METHOD `_istmtAssignOp(`instruction):
    VAR `that = THIS
    VAR `next_pcounter = `instruction[1]
    VAR `vvar = `instruction[2]
    VAR `exprs = `instruction[3]
    VAR `expr = `instruction[4]
    CLOSURE `getExpr():
      return `utils.`deepCopy(`that.`_interpExpr(`expr))
    ENDCLOSURE
    IF `length(`exprs) == 0:
      THIS.`_istmtAssignToVar(`vvar, `getExpr, `next_pcounter)
    ELSE:
      THIS.`_istmtAssignToListAt(`vvar, `exprs, `getExpr, `next_pcounter)
    ENDIF

  METHOD `_istmtAssignOpRandom(`instruction):
    VAR `that = THIS
    VAR `next_pcounter = `instruction[1]
    VAR `vvar = `instruction[2]
    VAR `exprs = `instruction[3]
    VAR `expr = `instruction[4]
    CLOSURE `getExpr():
      VAR `evalue
      VAR `r
      IF `isnull(`expr):
        `r = `int32(`that.`_rnd32b[0]() | 0)
        return `utils.`encodeData(`r)
      ENDIF
      `evalue = `that.`_interpExpr(`expr)
      IF `isnull(`evalue):
        return NULL
      ENDIF
      IF `evalue[0] != `key_interp_integer:
        `that.`_setRuntimeError("EXPECTED"+" "+"INTEGER"+" "+"IN"+" "+"RHS")
        return NULL
      ENDIF
      IF `evalue[1] < 2:
        `r = 0
        return `utils.`encodeData(`r)
      ENDIF
      `r = `that.`_rnd32b[0]() | 0
      `r = (`r & 0x7fffffff) % `evalue[1]
      return `utils.`encodeData(`r)
    ENDCLOSURE
    IF `length(`exprs) == 0:
      THIS.`_istmtAssignToVar(`vvar, `getExpr, `next_pcounter)
    ELSE:
      THIS.`_istmtAssignToListAt(`vvar, `exprs, `getExpr, `next_pcounter)
    ENDIF

  METHOD `_istmtAssignPop(`instruction):
    VAR `that = THIS
    VAR `next_pcounter = `instruction[1]
    VAR `vvar = `instruction[2]
    VAR `exprs = `instruction[3]
    VAR `popvarexprs = `instruction[4]
    VAR `index = `instruction[5]
    CLOSURE `getExpr():
      VAR `evalue = `that.`_interpExpr(`popvarexprs)
      IF `isnull(`evalue):
        return NULL
      ENDIF
      IF `evalue[0] != `key_interp_list:
        `that.`_setRuntimeError("EXPECTED"+" "+"LIST")
        return NULL
      ENDIF
      IF `length(`evalue[1]) == 0:
        `that.`_setRuntimeError("POP"+" "+"EMPTY"+" "+"LIST")
        return NULL
      ENDIF
      VAR `popvar = `popvarexprs[1]
      VAR `popvalue
      VAR `lindex
      IF `isnull(`index):
        `popvalue = `pop(`evalue[1])
      ELSE:
        `lindex = `that.`_interpExpr(`index)
        IF `isnull(`lindex):
          return NULL
        ENDIF
        IF `lindex[0] != `key_interp_integer:
          `that.`_setRuntimeError("INVALID"+" "+"INDEX")
          return NULL
        ENDIF
        IF (`lindex[1] < 0) OR (`lindex[1] >= `length(`evalue[1])):
          `that.`_setRuntimeError("INDEX"+" "+"OUT-OF-RANGE")
          return NULL
        ENDIF
        `popvalue = `pick(`evalue[1], `lindex[1])
      ENDIF
      VAR `delta_cost_i = -`utils.`isizeEvalue(`popvalue)
      VAR `delta_cost_l = -`utils.`lsizeEvalue(`popvalue)
      VAR `popexprs
      VAR `popevalue
      VAR `poplindex
      VAR `j
      IF `popvarexprs[0] == "VAR":
        `evalue[2] += `delta_cost_l
        `evalue[3] += `delta_cost_i
      ELSE:
        `popexprs = `popvarexprs[2]
        `popevalue = `that.`getVar(`popvar)
        `popevalue[2] += `delta_cost_l
        `popevalue[3] += `delta_cost_i
        FORINCR `j(0 `length(`popexprs)):
          `poplindex = `that.`_interpExpr(`popexprs[`j])
          `popevalue = `popevalue[1][`poplindex[1]]
          `popevalue[2] += `delta_cost_l
          `popevalue[3] += `delta_cost_i
        ENDFOR
      ENDIF
      `that.`_memory_delta_i += `delta_cost_i
      `that.`_memory_delta_l += `delta_cost_l
      `that.`_addChangedVar(`popvar)
      return `popvalue
    ENDCLOSURE
    IF `isnull(`vvar):
      THIS.`_istmtAssignToDummy(`getExpr, `next_pcounter)
    ELSIF `length(`exprs) == 0:
      THIS.`_istmtAssignToVar(`vvar, `getExpr, `next_pcounter)
    ELSE:
      THIS.`_istmtAssignToListAt(`vvar, `exprs, `getExpr, `next_pcounter)
    ENDIF

  METHOD `_istmtAssignUnqueue(`instruction):
    VAR `that = THIS
    VAR `next_pcounter = `instruction[1]
    VAR `vvar = `instruction[2]
    VAR `exprs = `instruction[3]
    VAR `unqvarexprs = `instruction[4]
    CLOSURE `getExpr():
      VAR `evalue = `that.`_interpExpr(`unqvarexprs)
      IF `isnull(`evalue):
        return NULL
      ENDIF
      IF `evalue[0] != `key_interp_list:
        `that.`_setRuntimeError("EXPECTED"+" "+"LIST")
        return NULL
      ENDIF
      IF `length(`evalue[1]) == 0:
        `that.`_setRuntimeError("UNQUEUE"+" "+"EMPTY"+" "+"LIST")
        return NULL
      ENDIF
      VAR `unqvar = `unqvarexprs[1]
      VAR `unqvalue = `unqueue(`evalue[1])
      VAR `delta_cost_i = -`utils.`isizeEvalue(`unqvalue)
      VAR `delta_cost_l = -`utils.`lsizeEvalue(`unqvalue)
      VAR `unqexprs
      VAR `unqevalue
      VAR `unqlindex
      VAR `j
      IF `unqvarexprs[0] == "VAR":
        `evalue[2] += `delta_cost_l
        `evalue[3] += `delta_cost_i
      ELSE:
        `unqexprs = `unqvarexprs[2]
        `unqevalue = `that.`getVar(`unqvar)
        `unqevalue[2] += `delta_cost_l
        `unqevalue[3] += `delta_cost_i
        FORINCR `j(0 `length(`unqexprs)):
          `unqlindex = `that.`_interpExpr(`unqexprs[`j])
          `unqevalue = `unqevalue[1][`unqlindex[1]]
          `unqevalue[2] += `delta_cost_l
          `unqevalue[3] += `delta_cost_i
        ENDFOR
      ENDIF
      `that.`_memory_delta_i += `delta_cost_i
      `that.`_memory_delta_l += `delta_cost_l
      `that.`_addChangedVar(`unqvar)
      return `unqvalue
    ENDCLOSURE
    IF `isnull(`vvar):
      THIS.`_istmtAssignToDummy(`getExpr, `next_pcounter)
    ELSIF `length(`exprs) == 0:
      THIS.`_istmtAssignToVar(`vvar, `getExpr, `next_pcounter)
    ELSE:
      THIS.`_istmtAssignToListAt(`vvar, `exprs, `getExpr, `next_pcounter)
    ENDIF

  METHOD `_istmtAssignToDummy(`getExpr `next_pcounter):
    VAR `evalue = `getExpr()
    IF `isnull(`evalue):
      return
    ENDIF
    THIS.`_pcounter = `next_pcounter

  METHOD `_istmtAssignToVar(`vvar `getExpr `next_pcounter):
    IF `indexof(THIS.`_repeat_vars, `vvar) >= 0:
      THIS.`_setRuntimeError("REPEAT"+" "+"VARIABLE"+" "+"IN"+" "+"ASSIGNMENT")
      return
    ENDIF
    VAR `evalue = `getExpr()
    IF `isnull(`evalue):
      return
    ENDIF
    VAR `delta_cost_i = `utils.`isizeEvalue(`evalue)
    VAR `delta_cost_l = `utils.`lsizeEvalue(`evalue)
    VAR `old_evalue = THIS.`getVar(`vvar)
    IF `not(`isnull(`old_evalue)):
      `delta_cost_i += -`utils.`isizeEvalue(`old_evalue)
      `delta_cost_l += -`utils.`lsizeEvalue(`old_evalue)
    ENDIF
    THIS.`_addVar(`vvar, `evalue)
    THIS.`_memory_delta_i += `delta_cost_i
    THIS.`_memory_delta_l += `delta_cost_l
    THIS.`_addChangedVar(`vvar)
    THIS.`_pcounter = `next_pcounter

  METHOD `_istmtAssignToListAt(`vvar `exprs `getExpr `next_pcounter):
    VAR `vvalue = THIS.`getVar(`vvar)
    IF `isnull(`vvalue):
      THIS.`_setRuntimeError("UNDEFINED"+" "+"VARIABLE"+" "+"IN"+" "+"LHS")
      return
    ENDIF
    IF `vvalue[0] != `key_interp_list:
      THIS.`_setRuntimeError("EXPECTED"+" "+"LIST"+" "+"IN"+" "+"LHS")
      return
    ENDIF
    VAR `vvalues = []
    VAR `lindex = THIS.`_interpExpr(`exprs[0])
    IF `isnull(`lindex):
      return
    ENDIF
    IF `lindex[0] != `key_interp_integer:
      THIS.`_setRuntimeError("INVALID"+" "+"INDEX"+" "+"IN"+" "+"LHS")
      return
    ENDIF
    IF (`lindex[1] < 0) OR (`lindex[1] >= `length(`vvalue[1])):
      THIS.`_setRuntimeError("INDEX"+" "+"OUT-OF-RANGE"+" "+"IN"+" "+"LHS")
      return NULL
    ENDIF
    VAR `j
    FORINCR `j(1 `length(`exprs)):
      `push(`vvalues, `vvalue)
      `vvalue = `vvalue[1][`lindex[1]]
      IF `vvalue[0] != `key_interp_list:
        THIS.`_setRuntimeError("EXPECTED"+" "+"LIST"+" "+"IN"+" "+"LHS")
        return
      ENDIF
      `lindex = THIS.`_interpExpr(`exprs[`j])
      IF `isnull(`lindex):
        return
      ENDIF
      IF `lindex[0] != `key_interp_integer:
        THIS.`_setRuntimeError("INVALID"+" "+"INDEX"+" "+"IN"+" "+"LHS")
        return
      ENDIF
      IF (`lindex[1] < 0) OR (`lindex[1] >= `length(`vvalue[1])):
        THIS.`_setRuntimeError("INDEX"+" "+"OUT-OF-RANGE"+" "+"IN"+" "+"LHS")
        return NULL
      ENDIF
    ENDFOR
    VAR `lindexi = `lindex[1]
    VAR `evalue = `getExpr()
    IF `isnull(`evalue):
      return
    ENDIF
    VAR `delta_cost_i = -`utils.`isizeEvalue(`vvalue[1][`lindexi])+`utils.`isizeEvalue(`evalue)
    VAR `delta_cost_l = -`utils.`lsizeEvalue(`vvalue[1][`lindexi])+`utils.`lsizeEvalue(`evalue)
    `vvalue[1][`lindexi] = `evalue
    IF (`delta_cost_i != 0) OR (`delta_cost_l != 0):
      `push(`vvalues, `vvalue)
      FORINCR `j(0 `length(`vvalues)):
        `vvalues[`j][2] += `delta_cost_l
        `vvalues[`j][3] += `delta_cost_i
      ENDFOR
      THIS.`_memory_delta_i += `delta_cost_i
      THIS.`_memory_delta_l += `delta_cost_l
    ENDIF
    THIS.`_addChangedVar(`vvar)
    THIS.`_pcounter = `next_pcounter

  METHOD `_istmtIf(`instruction):
    VAR `next_pcounter = `instruction[1]
    VAR `alt_pcounter = `instruction[2]
    VAR `expr = `instruction[3]
    VAR `evalue = THIS.`_interpExpr(`expr)
    IF `isnull(`evalue):
      return
    ENDIF
    IF `evalue[1]:
      THIS.`_pcounter = `next_pcounter
    ELSE:
      THIS.`_pcounter = `alt_pcounter
    ENDIF

  METHOD `_istmtElsif(`instruction):
    VAR `next_pcounter = `instruction[1]
    VAR `alt_pcounter = `instruction[2]
    VAR `expr = `instruction[3]
    VAR `evalue = THIS.`_interpExpr(`expr)
    IF `isnull(`evalue):
      return
    ENDIF
    IF `evalue[1]:
      THIS.`_pcounter = `next_pcounter
    ELSE:
      THIS.`_pcounter = `alt_pcounter
    ENDIF

  METHOD `_istmtElse(`instruction):
    VAR `next_pcounter = `instruction[1]
    THIS.`_pcounter = `next_pcounter

  METHOD `_istmtEndif(`instruction):
    VAR `next_pcounter = `instruction[1]
    THIS.`_pcounter = `next_pcounter

  METHOD `_istmtRepeat(`instruction):
    VAR `next_pcounter = `instruction[1]
    VAR `alt_pcounter = `instruction[2]
    VAR `vvar = `instruction[3]
    IF `indexof(THIS.`_repeat_vars, `vvar) >= 0:
      THIS.`_setRuntimeError("REPEAT"+" "+"VARIABLE"+" "+"INSIDE"+" "+"REPEAT")
      return
    ENDIF
    VAR `evalue = THIS.`getVar(`vvar)
    IF `isnull(`evalue):
      THIS.`_setRuntimeError("UNDEFINED"+" "+"VARIABLE")
      return
    ENDIF
    IF `evalue[0] != `key_interp_integer:
      THIS.`_setRuntimeError("EXPECTED"+" "+"INTEGER")
      return
    ENDIF
    `push(THIS.`_repeat_vars, `vvar)
    IF `evalue[1] > 0:
      `evalue[1] -= 1
      THIS.`_addChangedVar(`vvar)
      THIS.`_has_repstop = FALSE
      THIS.`_pcounter = `next_pcounter
    ELSE:
      THIS.`_pcounter = `alt_pcounter
    ENDIF

  METHOD `_istmtRepnext(`instruction):
    VAR `next_pcounter = `instruction[1]
    THIS.`_pcounter = `next_pcounter

  METHOD `_istmtRepstop(`instruction):
    VAR `next_pcounter = `instruction[1]
    THIS.`_has_repstop = TRUE
    THIS.`_pcounter = `next_pcounter

  METHOD `_istmtEndrep(`instruction):
    VAR `next_pcounter = `instruction[1]
    VAR `alt_pcounter = `instruction[2]
    VAR `vvar = `pop(THIS.`_repeat_vars)
    VAR `evalue = THIS.`getVar(`vvar)
    IF (`evalue[1] <= 0) OR THIS.`_has_repstop:
      THIS.`_has_repstop = FALSE
      THIS.`_pcounter = `next_pcounter
    ELSE:
      THIS.`_pcounter = `alt_pcounter
    ENDIF

  METHOD `_istmtProcedure(`instruction):
    VAR `next_pcounter = `instruction[1]
    VAR `procname = `instruction[2]
    VAR `exprs = `instruction[3]
    VAR `procvalue = THIS.`_getQualvar(`procname)
    IF `isnull(`procvalue):
      THIS.`_setRuntimeError("UNDEFINED"+" "+"PROCEDURE")
      return
    ENDIF
    IF `procvalue[0] != `key_interp_procedure:
      THIS.`_setRuntimeError("EXPECTED"+" "+"PROCEDURE")
      return
    ENDIF
    VAR `args = []
    VAR `j
    VAR `evalue
    FORINCR `j(0 `length(`exprs)):
      `evalue = THIS.`_interpExpr(`exprs[`j])
      IF `isnull(`evalue):
        return
      ENDIF
      `push(`args, `utils.`decodeData(`evalue))
    ENDFOR
    THIS.`_procedure = [`procname, `args]

  METHOD `_istmtPush(`instruction):
    VAR `next_pcounter = `instruction[1]
    VAR `pvarexprs = `instruction[2]
    VAR `expr = `instruction[3]
    VAR `index = `instruction[4]
    VAR `pvar = `pvarexprs[1]
    VAR `pvalue = THIS.`_interpExpr(`pvarexprs)
    IF `isnull(`pvalue):
      return NULL
    ENDIF
    IF `pvalue[0] != `key_interp_list:
      THIS.`_setRuntimeError("EXPECTED"+" "+"LIST")
      return
    ENDIF
    VAR `evalue = `utils.`deepCopy(THIS.`_interpExpr(`expr))
    IF `isnull(`evalue):
      return
    ENDIF
    VAR `delta_cost_i = `utils.`isizeEvalue(`evalue)
    VAR `delta_cost_l = `utils.`lsizeEvalue(`evalue)
    VAR `lindex
    IF `isnull(`index):
      `push(`pvalue[1], `evalue)
    ELSE:
      `lindex = THIS.`_interpExpr(`index)
      IF `isnull(`lindex):
        return
      ENDIF
      IF `lindex[0] != `key_interp_integer:
        THIS.`_setRuntimeError("INVALID"+" "+"INDEX")
        return
      ENDIF
      IF (`lindex[1] < 0) OR (`lindex[1] > `length(`pvalue[1])):
        THIS.`_setRuntimeError("INDEX"+" "+"OUT-OF-RANGE")
        return
      ENDIF
      IF `lindex[1] < `length(`pvalue[1]):
        `poke(`pvalue[1], `lindex[1], `evalue)
      ELSE:
        `push(`pvalue[1], `evalue)
      ENDIF
    ENDIF
    VAR `pexprs
    VAR `pevalue
    VAR `plindex
    VAR `j
    IF `pvarexprs[0] == "VAR":
      `pvalue[2] += `delta_cost_l
      `pvalue[3] += `delta_cost_i
    ELSE:
      `pexprs = `pvarexprs[2]
      `pevalue = THIS.`getVar(`pvar)
      `pevalue[2] += `delta_cost_l
      `pevalue[3] += `delta_cost_i
      FORINCR `j(0 `length(`pexprs)):
        `plindex = THIS.`_interpExpr(`pexprs[`j])
        `pevalue = `pevalue[1][`plindex[1]]
        `pevalue[2] += `delta_cost_l
        `pevalue[3] += `delta_cost_i
      ENDFOR
    ENDIF
    THIS.`_memory_delta_i += `delta_cost_i
    THIS.`_memory_delta_l += `delta_cost_l
    THIS.`_addChangedVar(`pvar)
    THIS.`_pcounter = `next_pcounter

  METHOD `_istmtQueue(`instruction):
    VAR `next_pcounter = `instruction[1]
    VAR `qvarexprs = `instruction[2]
    VAR `expr = `instruction[3]
    VAR `qvar = `qvarexprs[1]
    VAR `qvalue = THIS.`_interpExpr(`qvarexprs)
    IF `isnull(`qvalue):
      return NULL
    ENDIF
    IF `qvalue[0] != `key_interp_list:
      THIS.`_setRuntimeError("EXPECTED"+" "+"LIST")
      return
    ENDIF
    VAR `evalue = `utils.`deepCopy(THIS.`_interpExpr(`expr))
    IF `isnull(`evalue):
      return
    ENDIF
    VAR `delta_cost_i = `utils.`isizeEvalue(`evalue)
    VAR `delta_cost_l = `utils.`lsizeEvalue(`evalue)
    `queue(`qvalue[1], `evalue)
    VAR `qexprs
    VAR `qevalue
    VAR `qlindex
    VAR `j
    IF `qvarexprs[0] == "VAR":
      `qvalue[2] += `delta_cost_l
      `qvalue[3] += `delta_cost_i
    ELSE:
      `qexprs = `qvarexprs[2]
      `qevalue = THIS.`getVar(`qvar)
      `qevalue[2] += `delta_cost_l
      `qevalue[3] += `delta_cost_i
      FORINCR `j(0 `length(`qexprs)):
        `qlindex = THIS.`_interpExpr(`qexprs[`j])
        `qevalue = `qevalue[1][`qlindex[1]]
        `qevalue[2] += `delta_cost_l
        `qevalue[3] += `delta_cost_i
      ENDFOR
    ENDIF
    THIS.`_memory_delta_i += `delta_cost_i
    THIS.`_memory_delta_l += `delta_cost_l
    THIS.`_addChangedVar(`qvar)
    THIS.`_pcounter = `next_pcounter

  METHOD `_istmtUnassign(`instruction):
    VAR `next_pcounter = `instruction[1]
    VAR `vvar = `instruction[2]
    IF `indexof(THIS.`_repeat_vars, `vvar) >= 0:
      THIS.`_setRuntimeError("REPEAT"+" "+"VARIABLE"+" "+"IN"+" "+"UNASSIGNMENT")
      return
    ENDIF
    VAR `evalue = THIS.`getVar(`vvar)
    IF `isnull(`evalue):
      THIS.`_setRuntimeError("UNDEFINED"+" "+"VARIABLE")
      return
    ENDIF
    VAR `delta_cost_i = -`utils.`isizeEvalue(`evalue)
    VAR `delta_cost_l = -`utils.`lsizeEvalue(`evalue)
    THIS.`_removeVar(`vvar)
    THIS.`_memory_delta_i += `delta_cost_i
    THIS.`_memory_delta_l += `delta_cost_l
    THIS.`_addChangedVar(`vvar)
    THIS.`_pcounter = `next_pcounter

  METHOD `_istmtLog(`instruction):
    VAR `next_pcounter = `instruction[1]
    VAR `logexprs = `instruction[2]
    VAR `log_message = ""
    VAR `j
    VAR `logexpr_j
    VAR `evalue_j
    FORINCR `j(0 `length(`logexprs)):
      `logexpr_j = `logexprs[`j]
      IF `logexpr_j[0] == "STRING":
        `log_message += `logexpr_j[1]
        continue
      ENDIF
      `evalue_j = THIS.`_interpExpr(`logexpr_j)
      `log_message += `utils.`stringify(`evalue_j)
    ENDFOR
    THIS.`_error = NULL
    VAR `log_lines = `split(`log_message, `chr_lf)
    VAR `log_line
    FORINCR `j(0 `length(`log_lines)):
      IF `not(`isnull(THIS.`_max_log_lines)) AND (`length(THIS.`_log_lines) >= THIS.`_max_log_lines):
        `unqueue(THIS.`_log_lines)
      ENDIF
      `log_line = `log_lines[`j]
      IF `not(`isnull(THIS.`_max_log_chars_per_line)) AND (`length(`log_line) > THIS.`_max_log_chars_per_line):
        `log_line = `substring(`log_line, 0, THIS.`_max_log_chars_per_line-3)+"..."
      ENDIF
      `push(THIS.`_log_lines, `log_line)
    ENDFOR
    THIS.`_pcounter = `next_pcounter

  METHOD `_interpExpr(`expression):
    VAR `opcode = `expression[0]
    return THIS.`_dispatch_expr[`opcode](`expression)

  METHOD `_iexprInteger(`expression):
    VAR `n = `expression[1]
    THIS.`_tmpInteger[1] = `n
    return THIS.`_tmpInteger

  METHOD `_iexprList(`expression):
    VAR `exprs = `expression[1]
    VAR `isize = 0
    VAR `lsize = 1
    VAR `lvalue = []
    VAR `j
    VAR `evalue
    FORINCR `j(0 `length(`exprs)):
      `evalue = `utils.`deepCopy(THIS.`_interpExpr(`exprs[`j]))
      IF `isnull(`evalue):
        return NULL
      ENDIF
      `push(`lvalue, `evalue)
      `isize += `utils.`isizeEvalue(`evalue)
      `lsize += `utils.`lsizeEvalue(`evalue)
    ENDFOR
    return [`key_interp_list, `lvalue, `lsize, `isize]

  METHOD `_iexprOr(`expression):
    VAR `exprs = `expression[1]
    VAR `j
    VAR `evalue
    FORINCR `j(0 `length(`exprs)):
      `evalue = THIS.`_interpExpr(`exprs[`j])
      IF `isnull(`evalue):
        return NULL
      ENDIF
      IF `evalue[1]:
        THIS.`_tmpBoolean[1] = TRUE
        return THIS.`_tmpBoolean
      ENDIF
    ENDFOR
    THIS.`_tmpBoolean[1] = FALSE
    return THIS.`_tmpBoolean

  METHOD `_iexprAnd(`expression):
    VAR `exprs = `expression[1]
    VAR `j
    VAR `evalue
    FORINCR `j(0 `length(`exprs)):
      `evalue = THIS.`_interpExpr(`exprs[`j])
      IF `isnull(`evalue):
        return NULL
      ENDIF
      IF `not(`evalue[1]):
        THIS.`_tmpBoolean[1] = FALSE
        return THIS.`_tmpBoolean
      ENDIF
    ENDFOR
    THIS.`_tmpBoolean[1] = TRUE
    return THIS.`_tmpBoolean

  METHOD `_iexprNot(`expression):
    VAR `expr = `expression[1]
    VAR `evalue = THIS.`_interpExpr(`expr)
    IF `isnull(`evalue):
      return NULL
    ENDIF
    THIS.`_tmpBoolean[1] = `not(`evalue[1])
    return THIS.`_tmpBoolean

  METHOD `_iexprRelOp(`expression `binOp):
    VAR `expr1 = `expression[1]
    VAR `expr2 = `expression[2]
    VAR `evalue1 = THIS.`_interpExpr(`expr1)
    IF `isnull(`evalue1):
      return NULL
    ENDIF
    IF `evalue1[0] != `key_interp_integer:
      THIS.`_setRuntimeError("EXPECTED"+" "+"INTEGER")
      return NULL
    ENDIF
    VAR `evalue1i = `evalue1[1]
    VAR `evalue2 = THIS.`_interpExpr(`expr2)
    IF `isnull(`evalue2):
      return NULL
    ENDIF
    IF `evalue2[0] != `key_interp_integer:
      THIS.`_setRuntimeError("EXPECTED"+" "+"INTEGER")
      return NULL
    ENDIF
    VAR `value = `binOp(`evalue1i, `evalue2[1])
    THIS.`_tmpBoolean[1] = `value
    return THIS.`_tmpBoolean

  METHOD `_iexprUnaryOp(`expression `unaryOp):
    VAR `expr = `expression[1]
    VAR `evalue = THIS.`_interpExpr(`expr)
    IF `isnull(`evalue):
      return NULL
    ENDIF
    IF `evalue[0] != `key_interp_integer:
      THIS.`_setRuntimeError("EXPECTED"+" "+"INTEGER")
      return NULL
    ENDIF
    VAR `value = `unaryOp(`evalue[1])
    THIS.`_tmpInteger[1] = `value
    return THIS.`_tmpInteger

  METHOD `_iexprAddOp(`expression `binOp):
    VAR `expr1 = `expression[1]
    VAR `expr2 = `expression[2]
    VAR `evalue1 = THIS.`_interpExpr(`expr1)
    IF `isnull(`evalue1):
      return NULL
    ENDIF
    IF `evalue1[0] != `key_interp_integer:
      THIS.`_setRuntimeError("EXPECTED"+" "+"INTEGER")
      return NULL
    ENDIF
    VAR `evalue1i = `evalue1[1]
    VAR `evalue2 = THIS.`_interpExpr(`expr2)
    IF `isnull(`evalue2):
      return NULL
    ENDIF
    IF `evalue2[0] != `key_interp_integer:
      THIS.`_setRuntimeError("EXPECTED"+" "+"INTEGER")
      return NULL
    ENDIF
    VAR `value = `binOp(`evalue1i, `evalue2[1])
    THIS.`_tmpInteger[1] = `value
    return THIS.`_tmpInteger

  METHOD `_iexprMulOp(`expression `binOp `zero_error):
    VAR `expr1 = `expression[1]
    VAR `expr2 = `expression[2]
    VAR `evalue1 = THIS.`_interpExpr(`expr1)
    IF `isnull(`evalue1):
      return NULL
    ENDIF
    IF `evalue1[0] != `key_interp_integer:
      THIS.`_setRuntimeError("EXPECTED"+" "+"INTEGER")
      return NULL
    ENDIF
    VAR `evalue1i = `evalue1[1]
    VAR `evalue2 = THIS.`_interpExpr(`expr2)
    IF `isnull(`evalue2):
      return NULL
    ENDIF
    IF `evalue2[0] != `key_interp_integer:
      THIS.`_setRuntimeError("EXPECTED"+" "+"INTEGER")
      return NULL
    ENDIF
    IF (`evalue2[1] == 0) AND `not(`isnull(`zero_error)):
      THIS.`_setRuntimeError(`zero_error)
      return NULL
    ENDIF
    VAR `value = `binOp(`evalue1i, `evalue2[1])
    THIS.`_tmpInteger[1] = `value
    return THIS.`_tmpInteger

  METHOD `_iexprByRef(`expression):
    VAR `vvar = `expression[1][0]
    VAR `values = [`vvar]
    VAR `lindex
    VAR `j
    FORINCR `j(1 `length(`expression[1])):
      `lindex = THIS.`_interpExpr(`expression[1][`j])
      IF `isnull(`lindex):
        return NULL
      ENDIF
      IF `lindex[0] != `key_interp_integer:
        THIS.`_setRuntimeError("INVALID"+" "+"INDEX")
        return NULL
      ENDIF
      `push(`values, `lindex[1])
    ENDFOR
    THIS.`_tmpByRef[1] = `values
    return THIS.`_tmpByRef

  METHOD `_iexprModuleName(`expression):
    VAR `module_name = `expression[1]
    THIS.`_tmpModuleName[1] = `module_name
    return THIS.`_tmpModuleName

  METHOD `_iexprString(`expression):
    VAR `str_ = `expression[1]
    THIS.`_tmpString[1] = `str_
    return THIS.`_tmpString

  METHOD `_iexprVar(`expression):
    VAR `vvar = `expression[1]
    VAR `evalue = THIS.`getVar(`vvar)
    IF `isnull(`evalue):
      THIS.`_setRuntimeError("UNDEFINED"+" "+"VARIABLE")
      return NULL
    ENDIF
    IF (`evalue[0] != `key_interp_integer) AND (`evalue[0] != `key_interp_list):
      THIS.`_setRuntimeError("EXPECTED"+" "+"INTEGER"+" "+"OR"+" "+"LIST")
      return NULL
    ENDIF
    return `evalue

  METHOD `_iexprQualvar(`expression):
    VAR `vvar = `expression[1]
    VAR `evalue = THIS.`_getQualvar(`vvar)
    IF `isnull(`evalue):
      THIS.`_setRuntimeError("UNDEFINED"+" "+"VARIABLE")
      return NULL
    ENDIF
    IF (`evalue[0] != `key_interp_integer) AND (`evalue[0] != `key_interp_list):
      THIS.`_setRuntimeError("EXPECTED"+" "+"INTEGER"+" "+"OR"+" "+"LIST")
      return NULL
    ENDIF
    return `evalue

  METHOD `_iexprIsVar(`expression):
    VAR `vvarexprs = `expression[1]
    VAR `vvar_typestr = `expression[2]
    VAR `vvar = `vvarexprs[1]
    VAR `evalue
    IF `vvarexprs[0] == "VAR":
        `evalue = THIS.`getVar(`vvar)
    ELSIF `vvarexprs[0] == "QUALVAR":
        `evalue = THIS.`_getQualvar(`vvar)
    ELSE:
        `evalue = THIS.`_interpExpr(`vvarexprs)
        IF `isnull(`evalue):
          return NULL
        ENDIF
    ENDIF
    IF `isnull(`evalue):
      THIS.`_tmpBoolean[1] = (`vvar_typestr == "UNDEFINED")
      return THIS.`_tmpBoolean
    ENDIF
    IF `evalue[0] == `key_interp_integer:
      THIS.`_tmpBoolean[1] = (`vvar_typestr == "INTEGER")
      return THIS.`_tmpBoolean
    ENDIF
    IF `evalue[0] == `key_interp_list:
      THIS.`_tmpBoolean[1] = (`vvar_typestr == "LIST")
      return THIS.`_tmpBoolean
    ENDIF
    IF `evalue[0] == `key_interp_procedure:
      THIS.`_tmpBoolean[1] = (`vvar_typestr == "PROCEDURE")
      return THIS.`_tmpBoolean
    ENDIF
    THIS.`_tmpBoolean[1] = FALSE
    return THIS.`_tmpBoolean

  METHOD `_iexprIsNotVar(`expression):
    VAR `vvarexprs = `expression[1]
    VAR `vvar_typestr = `expression[2]
    VAR `vvar = `vvarexprs[1]
    VAR `evalue
    IF `vvarexprs[0] == "VAR":
      `evalue = THIS.`getVar(`vvar)
    ELSIF `vvarexprs[0] == "QUALVAR":
      `evalue = THIS.`_getQualvar(`vvar)
    ELSE:
      `evalue = THIS.`_interpExpr(`vvarexprs)
      IF `isnull(`evalue):
        return NULL
      ENDIF
    ENDIF
    IF `isnull(`evalue):
      THIS.`_tmpBoolean[1] = (`vvar_typestr != "UNDEFINED")
      return THIS.`_tmpBoolean
    ENDIF
    IF `evalue[0] == `key_interp_integer:
      THIS.`_tmpBoolean[1] = (`vvar_typestr != "INTEGER")
      return THIS.`_tmpBoolean
    ENDIF
    IF `evalue[0] == `key_interp_list:
      THIS.`_tmpBoolean[1] = (`vvar_typestr != "LIST")
      return THIS.`_tmpBoolean
    ENDIF
    IF `evalue[0] == `key_interp_procedure:
      THIS.`_tmpBoolean[1] = (`vvar_typestr != "PROCEDURE")
      return THIS.`_tmpBoolean
    ENDIF
    THIS.`_tmpBoolean[1] = TRUE
    return THIS.`_tmpBoolean

  METHOD `_iexprLengthVar(`expression):
    VAR `vvarexprs = `expression[1]
    VAR `evalue = THIS.`_interpExpr(`vvarexprs)
    IF `isnull(`evalue):
      return NULL
    ENDIF
    IF `evalue[0] != `key_interp_list:
      THIS.`_setRuntimeError("EXPECTED"+" "+"LIST")
      return NULL
    ENDIF
    THIS.`_tmpInteger[1] = `length(`evalue[1])
    return THIS.`_tmpInteger

  METHOD `_iexprSizeVar(`expression `projection):
    VAR `vvarexprs = `expression[1]
    VAR `evalue = THIS.`_interpExpr(`vvarexprs)
    IF `isnull(`evalue):
      return NULL
    ENDIF
    IF (`evalue[0] != `key_interp_integer) AND (`evalue[0] != `key_interp_list):
      THIS.`_setRuntimeError("EXPECTED"+" "+"INTEGER"+" "+"OR"+" "+"LIST")
      return NULL
    ENDIF
    VAR `value = `projection(`utils.`lsizeEvalue(`evalue), `utils.`isizeEvalue(`evalue))
    THIS.`_tmpInteger[1] = `value
    return THIS.`_tmpInteger

  METHOD `_iexprIndexofVar(`expression):
    VAR `vvarexprs = `expression[1]
    VAR `expr = `expression[2]
    VAR `ariexpr = `expression[3]
    VAR `evalue = THIS.`_interpExpr(`vvarexprs)
    IF `isnull(`evalue):
      return NULL
    ENDIF
    IF `evalue[0] != `key_interp_list:
      THIS.`_setRuntimeError("EXPECTED"+" "+"LIST")
      return NULL
    ENDIF
    VAR `varvalue = `utils.`decodeData(`evalue)
    VAR `from = THIS.`_interpExpr(`ariexpr)
    IF `isnull(`from):
      return NULL
    ENDIF
    IF `from[0] != `key_interp_integer:
      THIS.`_setRuntimeError("EXPECTED"+" "+"INTEGER")
      return NULL
    ENDIF
    VAR `fromi = `from[1]
    VAR `indexof_ = THIS.`_interpExpr(`expr)
    IF `isnull(`indexof_):
      return NULL
    ENDIF
    IF (`indexof_[0] != `key_interp_integer) AND (`indexof_[0] != `key_interp_list):
      THIS.`_setRuntimeError("INVALID"+" "+"INDEXOF"+" "+"EXPRESSION")
      return NULL
    ENDIF
    VAR `indexofvalue = `utils.`decodeData(`indexof_)
    VAR `result
    IF `isnull(`varvalue) OR `isnull(`indexofvalue):
      `result = -1
    ELSE:
      `result = `utils.`structuralIndexOf(`varvalue[1], `indexofvalue[1], `fromi)
    ENDIF
    THIS.`_tmpInteger[1] = `result
    return THIS.`_tmpInteger

  METHOD `_iexprListAtVar(`expression):
    VAR `vvar = `expression[1]
    VAR `exprs = `expression[2]
    VAR `evalue = THIS.`getVar(`vvar)
    IF `isnull(`evalue):
      THIS.`_setRuntimeError("UNDEFINED"+" "+"VARIABLE")
      return NULL
    ENDIF
    VAR `lindex
    VAR `j
    FORINCR `j(0 `length(`exprs)):
      IF `evalue[0] != `key_interp_list:
        THIS.`_setRuntimeError("EXPECTED"+" "+"LIST")
        return NULL
      ENDIF
      `lindex = THIS.`_interpExpr(`exprs[`j])
      IF `isnull(`lindex):
        return NULL
      ENDIF
      IF `lindex[0] != `key_interp_integer:
        THIS.`_setRuntimeError("INVALID"+" "+"INDEX")
        return NULL
      ENDIF
      IF (`lindex[1] < 0) OR (`lindex[1] >= `length(`evalue[1])):
        THIS.`_setRuntimeError("INDEX"+" "+"OUT-OF-RANGE")
        return NULL
      ENDIF
      `evalue = `evalue[1][`lindex[1]]
    ENDFOR
    return `evalue

  METHOD `_iexprListAtQualvar(`expression):
    VAR `vvar = `expression[1]
    VAR `exprs = `expression[2]
    VAR `evalue = THIS.`_getQualvar(`vvar)
    IF `isnull(`evalue):
      THIS.`_setRuntimeError("UNDEFINED"+" "+"VARIABLE")
      return NULL
    ENDIF
    VAR `lindex
    VAR `j
    FORINCR `j(0 `length(`exprs)):
      IF `evalue[0] != `key_interp_list:
        THIS.`_setRuntimeError("EXPECTED"+" "+"LIST")
        return NULL
      ENDIF
      `lindex = THIS.`_interpExpr(`exprs[`j])
      IF `isnull(`lindex):
        return NULL
      ENDIF
      IF `lindex[0] != `key_interp_integer:
        THIS.`_setRuntimeError("INVALID"+" "+"INDEX")
        return NULL
      ENDIF
      IF (`lindex[1] < 0) OR (`lindex[1] >= `length(`evalue[1])):
        THIS.`_setRuntimeError("INDEX"+" "+"OUT-OF-RANGE")
        return NULL
      ENDIF
      `evalue = `evalue[1][`lindex[1]]
    ENDFOR
    return `evalue

  METHOD `destroy():
    VAR `x = NULL

ENDCLASS

VAR `key_modules_module_name = 0
VAR `key_modules_module_name_lcase = 1
VAR `key_modules_editor_m = 2
VAR `key_modules_instances = 3

VAR `key_envs_environment = 0
VAR `key_envs_varnames = 1
VAR `key_envs_procnames = 2
VAR `key_envs_instances = 3

VAR `key_instances_interp_m = 0
VAR `key_instances_module = 1
VAR `key_instances_envs = 2
VAR `key_instances_state = 3

CLASS `PrequelM:

  METHOD_INIT(`args):
    VAR `x = NULL

  METHOD `init(`onProcedure `onYieldResume `rnd32b `now):
    THIS.`_ihandle = NEW `ResourceIds()
    THIS.`_modules = {}
    THIS.`_module_list = []
    THIS.`_instances = {}
    THIS.`_instance_list = []
    THIS.`_envs = {}
    THIS.`_env_list = []
    THIS.`_running_instance = NULL
    THIS.`_ready_instances = []
    THIS.`_limit_instances = []
    THIS.`_pause_instances = []
    THIS.`_yield_instances = []
    THIS.`_error_instances = []
    THIS.`_ended_instances = []
    THIS.`_onProcedure = `onProcedure
    THIS.`_onYieldResume = `onYieldResume
    THIS.`_rnd32b = `rnd32b
    THIS.`_now = `now
    VAR `that = THIS
    CLOSURE `closure_getQualvar(`qualvar):
      IF `isnull(`that.`_running_instance):
        return NULL
      ENDIF
      VAR `instance = `that.`_running_instance
      VAR `envs = `that.`_instances[`instance][`key_instances_envs]
      VAR `j
      VAR `env
      VAR `evalue
      FORDECR `j(`length(`envs)-1 0):
        `env = `envs[`j]
        `evalue = `that.`_envs[`env][`key_envs_environment].`get(`qualvar)
        IF `not(`isnull(`evalue)):
          return `evalue
        ENDIF
      ENDFOR
      return NULL
    ENDCLOSURE
    THIS.`_getQualvar = `closure_getQualvar

  METHOD `setCallbacks(`onProcedure `onYieldResume `rnd32b `now):
    THIS.`_onProcedure = `onProcedure
    THIS.`_onYieldResume = `onYieldResume
    THIS.`_rnd32b = `rnd32b
    THIS.`_now = `now

  METHOD `getModules():
    return THIS.`_module_list

  METHOD `openModule(`source_code `module_name):
    VAR `extension
    VAR `j
    VAR `module_idx
    VAR `module_j
    VAR `module_name_lcase
    VAR `num
    VAR `ok
    VAR `prefix
    IF `isnull(`module_name):
      `prefix = "Untitled"
      `num = 1
      `extension = "."+"pre"
      WHILE TRUE:
        `ok = TRUE
        `module_name = `prefix+`str(`num)+`extension
        `module_name_lcase = `lowercase(`module_name)
        `module_idx = `length(THIS.`_module_list)
        FORINCR `j(0 `length(THIS.`_module_list)):
          `module_j = THIS.`_module_list[`j]
          IF THIS.`_modules[`module_j][`key_modules_module_name_lcase] < `module_name_lcase:
            continue
          ENDIF
          IF THIS.`_modules[`module_j][`key_modules_module_name_lcase] > `module_name_lcase:
            `module_idx = `j
            break
          ENDIF
          `ok = FALSE
          break
        ENDFOR
        IF `ok:
          break
        ENDIF
        `num += 1
      ENDWHILE
    ELSE:
      `module_name_lcase = `lowercase(`module_name)
      `module_idx = `length(THIS.`_module_list)
      FORINCR `j(0 `length(THIS.`_module_list)):
        `module_j = THIS.`_module_list[`j]
        IF THIS.`_modules[`module_j][`key_modules_module_name_lcase] < `module_name_lcase:
          continue
        ENDIF
        `module_idx = `j
        break
      ENDFOR
    ENDIF
    VAR `module = THIS.`_ihandle.`alloc()
    VAR `editor_m = NEW `EditorM(`source_code)
    `poke(THIS.`_module_list, `module_idx, `module)
    THIS.`_modules[`module] = {}
    THIS.`_modules[`module][`key_modules_module_name] = `module_name
    THIS.`_modules[`module][`key_modules_module_name_lcase] = `module_name_lcase
    THIS.`_modules[`module][`key_modules_editor_m] = `editor_m
    THIS.`_modules[`module][`key_modules_instances] = []
    return `module

  METHOD `getModuleName(`module):
    return THIS.`_modules[`module][`key_modules_module_name]

  METHOD `getModuleNameLcase(`module):
    return THIS.`_modules[`module][`key_modules_module_name_lcase]

  METHOD `renameModule(`module `module_name):
    THIS.`_modules[`module][`key_modules_module_name] = `module_name
    THIS.`_modules[`module][`key_modules_module_name_lcase] = `lowercase(`module_name)

  METHOD `getModuleInstances(`module):
    return THIS.`_modules[`module][`key_modules_instances]

  METHOD `getParserError(`module):
    return THIS.`_modules[`module][`key_modules_editor_m].`getParserError()

  METHOD `getEntryLnno(`module):
    return THIS.`_modules[`module][`key_modules_editor_m].`getEntryLnno()

  METHOD `getSourceCode(`module):
    return THIS.`_modules[`module][`key_modules_editor_m].`getSourceCode()

  METHOD `setSourceCode(`module `source_code):
    THIS.`_modules[`module][`key_modules_editor_m].`setSourceCode(`source_code)

  METHOD `getLnnoCount(`module):
    return THIS.`_modules[`module][`key_modules_editor_m].`getLnnoCount()

  METHOD `getTokens(`module `lnno):
    return THIS.`_modules[`module][`key_modules_editor_m].`getTokens(`lnno)

  METHOD `hasBreakpoint(`module `lnno):
    return THIS.`_modules[`module][`key_modules_editor_m].`hasBreakpoint(`lnno)

  METHOD `setBreakpoint(`module `lnno):
    THIS.`_modules[`module][`key_modules_editor_m].`setBreakpoint(`lnno)

  METHOD `clearBreakpoint(`module `lnno):
    THIS.`_modules[`module][`key_modules_editor_m].`clearBreakpoint(`lnno)

  METHOD `isCompiled(`module):
    return THIS.`_modules[`module][`key_modules_editor_m].`isCompiled()

  METHOD `compile(`module):
    THIS.`_modules[`module][`key_modules_editor_m].`compile()

  METHOD `closeModule(`module):
    VAR `module_idx = `indexof(THIS.`_module_list, `module)
    THIS.`_modules[`module][`key_modules_editor_m].`destroy()
    THIS.`_modules[`module][`key_modules_editor_m] = NULL
    `pick(THIS.`_module_list, `module_idx)
    `delete(THIS.`_modules, `module)
    THIS.`_ihandle.`free(`module)

  METHOD `getEnvs():
    return THIS.`_env_list

  METHOD `createEnv():
    VAR `env = THIS.`_ihandle.`alloc()
    `push(THIS.`_env_list, `env)
    THIS.`_envs[`env] = {}
    THIS.`_envs[`env][`key_envs_environment] = NEW `Environment()
    THIS.`_envs[`env][`key_envs_varnames] = []
    THIS.`_envs[`env][`key_envs_procnames] = []
    THIS.`_envs[`env][`key_envs_instances] = []
    return `env

  METHOD `getEnvInstances(`env):
    return THIS.`_envs[`env][`key_envs_instances]

  METHOD `deleteEnv(`env):
    VAR `env_idx = `indexof(THIS.`_env_list, `env)
    THIS.`_envs[`env][`key_envs_environment].`destroy()
    THIS.`_envs[`env][`key_envs_environment] = NULL
    THIS.`_envs[`env][`key_envs_varnames] = NULL
    THIS.`_envs[`env][`key_envs_procnames] = NULL
    THIS.`_envs[`env][`key_envs_instances] = NULL
    `pick(THIS.`_env_list, `env_idx)
    `delete(THIS.`_envs, `env)
    THIS.`_ihandle.`free(`env)

  METHOD `getInstances():
    return THIS.`_instance_list

  METHOD `addInstance(`module):
    VAR `instance = THIS.`_ihandle.`alloc()
    VAR `interp_m = NEW `InterpM(THIS.`_modules[`module][`key_modules_editor_m], THIS.`_getQualvar, THIS.`_onProcedure, THIS.`_onYieldResume, THIS.`_rnd32b, THIS.`_now)
    `push(THIS.`_instance_list, `instance)
    THIS.`_instances[`instance] = {}
    THIS.`_instances[`instance][`key_instances_interp_m] = `interp_m
    THIS.`_instances[`instance][`key_instances_module] = `module
    THIS.`_instances[`instance][`key_instances_envs] = []
    THIS.`_instances[`instance][`key_instances_state] = `INTERP_STATE_READY
    `push(THIS.`_modules[`module][`key_modules_instances], `instance)
    `push(THIS.`_ready_instances, `instance)
    return `instance

  METHOD `cloneInstance(`instance):
    VAR `module = THIS.`_instances[`instance][`key_instances_module]
    VAR `cloned_instance = THIS.`addInstance(`module)
    VAR `instance_envs = THIS.`_instances[`instance][`key_instances_envs]
    VAR `j
    VAR `env
    FORINCR `j(0 `length(`instance_envs)):
      `env = `instance_envs[`j]
      THIS.`pushEnv(`cloned_instance, `env)
    ENDFOR
    VAR `ivarnames = THIS.`getInstanceVarNames(`instance)
    VAR `ivarname
    VAR `ivarvalue
    FORINCR `j(0 `length(`ivarnames)):
      `ivarname = `ivarnames[`j]
      `ivarvalue = THIS.`getInstanceVar(`instance, `ivarname)
      THIS.`addInstanceVar(`cloned_instance, `ivarname, `ivarvalue)
    ENDFOR
    return `cloned_instance

  METHOD `getInstanceModule(`instance):
    return THIS.`_instances[`instance][`key_instances_module]

  METHOD `getInstanceEnvs(`instance):
    return THIS.`_instances[`instance][`key_instances_envs]

  METHOD `getInstanceState(`instance):
    return THIS.`_instances[`instance][`key_instances_state]

  METHOD `removeInstance(`instance):
    THIS.`_instances[`instance][`key_instances_interp_m].`destroy()
    VAR `module = THIS.`_instances[`instance][`key_instances_module]
    VAR `module_instance_idx = `indexof(THIS.`_modules[`module][`key_modules_instances], `instance)
    `pick(THIS.`_modules[`module][`key_modules_instances], `module_instance_idx)
    VAR `envs = THIS.`_instances[`instance][`key_instances_envs]
    VAR `j
    VAR `env
    VAR `env_instance_idx
    FORINCR `j(0 `length(`envs)):
      `env = `envs[`j]
      `env_instance_idx = `indexof(THIS.`_envs[`env][`key_envs_instances], `env)
      `pick(THIS.`_envs[`env][`key_envs_instances], `env_instance_idx)
    ENDFOR
    VAR `state = THIS.`_instances[`instance][`key_instances_state]
    VAR `ready_instance_idx
    VAR `limit_instance_idx
    VAR `pause_instance_idx
    VAR `yield_instance_idx
    VAR `error_instance_idx
    VAR `ended_instance_idx
    IF `state == `INTERP_STATE_READY:
      `ready_instance_idx = `indexof(THIS.`_ready_instances, `instance)
      `pick(THIS.`_ready_instances, `ready_instance_idx)
    ELSIF `state == `INTERP_STATE_LIMIT:
      `limit_instance_idx = `indexof(THIS.`_limit_instances, `instance)
      `pick(THIS.`_limit_instances, `limit_instance_idx)
    ELSIF `state == `INTERP_STATE_PAUSE:
      `pause_instance_idx = `indexof(THIS.`_pause_instances, `instance)
      `pick(THIS.`_pause_instances, `pause_instance_idx)
    ELSIF `state == `INTERP_STATE_YIELD:
      `yield_instance_idx = `indexof(THIS.`_yield_instances, `instance)
      `pick(THIS.`_yield_instances, `yield_instance_idx)
    ELSIF `state == `INTERP_STATE_ERROR:
      `error_instance_idx = `indexof(THIS.`_error_instances, `instance)
      `pick(THIS.`_error_instances, `error_instance_idx)
    ELSIF `state == `INTERP_STATE_ENDED:
      `ended_instance_idx = `indexof(THIS.`_ended_instances, `instance)
      `pick(THIS.`_ended_instances, `ended_instance_idx)
    ENDIF
    VAR `instance_idx = `indexof(THIS.`_instance_list, `instance)
    `pick(THIS.`_instance_list, `instance_idx)
    THIS.`_instances[`instance][`key_instances_interp_m] = NULL
    THIS.`_instances[`instance][`key_instances_module] = NULL
    THIS.`_instances[`instance][`key_instances_envs] = NULL
    THIS.`_instances[`instance][`key_instances_state] = NULL
    `delete(THIS.`_instances, `instance)
    THIS.`_ihandle.`free(`instance)

  METHOD `pushEnv(`instance `env):
    `push(THIS.`_instances[`instance][`key_instances_envs], `env)
    `push(THIS.`_envs[`env][`key_envs_instances], `instance)

  METHOD `removeEnv(`instance `env):
    VAR `instance_env_idx = `indexof(THIS.`_instances[`instance][`key_instances_envs], `env)
    `pick(THIS.`_instances[`instance][`key_instances_envs], `instance_env_idx)
    VAR `env_instance_idx = `indexof(THIS.`_envs[`env][`key_envs_instances], `instance)
    `pick(THIS.`_envs[`env][`key_envs_instances], `env_instance_idx)

  METHOD `getVarNames(`env):
    return THIS.`_envs[`env][`key_envs_varnames]

  METHOD `addVar(`env `varname `evalue):
    `push(THIS.`_envs[`env][`key_envs_varnames], `varname)
    THIS.`_envs[`env][`key_envs_environment].`set(`varname, `evalue)

  METHOD `overwriteVar(`env `varname `varvalue):
    return THIS.`_envs[`env][`key_envs_environment].`overwrite(`varname, `varvalue)

  METHOD `getVar(`env `varname):
    return THIS.`_envs[`env][`key_envs_environment].`get(`varname)

  METHOD `removeVar(`env `varname):
    VAR `idx = `indexof(THIS.`_envs[`env][`key_envs_varnames], `varname)
    `pick(THIS.`_envs[`env][`key_envs_varnames], `idx)
    THIS.`_envs[`env][`key_envs_environment].`del(`varname)

  METHOD `getProcedureNames(`env):
    return THIS.`_envs[`env][`key_envs_procnames]

  METHOD `addProcedure(`env `procname `evalue):
    `push(THIS.`_envs[`env][`key_envs_procnames], `procname)
    THIS.`_envs[`env][`key_envs_environment].`set(`procname, `evalue)

  METHOD `removeProcedure(`env `procname):
    VAR `idx = `indexof(THIS.`_envs[`env][`key_envs_procnames], `procname)
    `pick(THIS.`_envs[`env][`key_envs_procnames], `idx)
    THIS.`_envs[`env][`key_envs_environment].`del(`procname)

  METHOD `getInstanceVarNames(`instance):
    return THIS.`_instances[`instance][`key_instances_interp_m].`getVarNames()

  METHOD `addInstanceVar(`instance `ivarname `evalue):
    THIS.`_instances[`instance][`key_instances_interp_m].`addVar(`ivarname, `evalue)

  METHOD `getInstanceVar(`instance `ivarname):
    return THIS.`_instances[`instance][`key_instances_interp_m].`getVar(`ivarname)

  METHOD `removeInstanceVar(`instance `ivarname):
    THIS.`_instances[`instance][`key_instances_interp_m].`removeVar(`ivarname)

  METHOD `getRunningInstance():
    return THIS.`_running_instance

  METHOD `getReadyInstances():
    return THIS.`_ready_instances

  METHOD `getLimitInstances():
    return THIS.`_limit_instances

  METHOD `getPauseInstances():
    return THIS.`_pause_instances

  METHOD `getYieldInstances():
    return THIS.`_yield_instances

  METHOD `getErrorInstances():
    return THIS.`_error_instances

  METHOD `getEndedInstances():
    return THIS.`_ended_instances

  METHOD `inRepeatVars(`instance `ivarname):
    return THIS.`_instances[`instance][`key_instances_interp_m].`inRepeatVars(`ivarname)

  METHOD `run(`instance `stepping `limits):
    THIS.`_running_instance = `instance
    VAR `result_list = THIS.`_instances[`instance][`key_instances_interp_m].`run(`instance, `stepping, `limits)
    THIS.`_running_instance = NULL
    VAR `state = `result_list[0]
    THIS.`_updateInstanceState(`instance, `state)
    return `result_list

  METHOD `resume(`instance `stepping `limits):
    VAR `resume_yield = (THIS.`_instances[`instance][`key_instances_state] == `INTERP_STATE_YIELD)
    THIS.`_running_instance = `instance
    VAR `result_list = THIS.`_instances[`instance][`key_instances_interp_m].`resume(`instance, `resume_yield, `stepping, `limits)
    THIS.`_running_instance = NULL
    VAR `state = `result_list[0]
    THIS.`_updateInstanceState(`instance, `state)
    return `result_list

  METHOD `reap(`instance):
    THIS.`_instances[`instance][`key_instances_interp_m].`reap()
    THIS.`_updateInstanceState(`instance, `INTERP_STATE_READY)

  METHOD `reset(`instance):
    THIS.`_instances[`instance][`key_instances_interp_m].`reset()

  METHOD `returnWithStatus(`instance `status_code):
    THIS.`_instances[`instance][`key_instances_interp_m].`returnWithStatus(`status_code)

  METHOD `prequelYield(`instance):
    THIS.`_instances[`instance][`key_instances_interp_m].`prequelYield()

  METHOD `runtimeError(`instance `error_message):
    THIS.`_instances[`instance][`key_instances_interp_m].`runtimeError(`error_message)

  METHOD `getStatusCode(`instance):
    return THIS.`_instances[`instance][`key_instances_interp_m].`getStatusCode()

  METHOD `readLog(`instance):
    return THIS.`_instances[`instance][`key_instances_interp_m].`readLog()

  METHOD `readChangedVars(`instance):
    return THIS.`_instances[`instance][`key_instances_interp_m].`readChangedVars()

  METHOD `_updateInstanceState(`instance `state):
    VAR `old_state = THIS.`_instances[`instance][`key_instances_state]
    IF `old_state == `state:
      return
    ENDIF
    THIS.`_instances[`instance][`key_instances_state] = `state
    VAR `idx
    IF `old_state == `INTERP_STATE_READY:
      `idx = `indexof(THIS.`_ready_instances, `instance)
      `pick(THIS.`_ready_instances, `idx)
    ELSIF `old_state == `INTERP_STATE_LIMIT:
      `idx = `indexof(THIS.`_limit_instances, `instance)
      `pick(THIS.`_limit_instances, `idx)
    ELSIF `old_state == `INTERP_STATE_PAUSE:
      `idx = `indexof(THIS.`_pause_instances, `instance)
      `pick(THIS.`_pause_instances, `idx)
    ELSIF `old_state == `INTERP_STATE_YIELD:
      `idx = `indexof(THIS.`_yield_instances, `instance)
      `pick(THIS.`_yield_instances, `idx)
    ELSIF `old_state == `INTERP_STATE_ERROR:
      `idx = `indexof(THIS.`_error_instances, `instance)
      `pick(THIS.`_error_instances, `idx)
    ELSIF `old_state == `INTERP_STATE_ENDED:
      `idx = `indexof(THIS.`_ended_instances, `instance)
      `pick(THIS.`_ended_instances, `idx)
    ENDIF
    IF `state == `INTERP_STATE_READY:
      `push(THIS.`_ready_instances, `instance)
    ELSIF `state == `INTERP_STATE_LIMIT:
      `push(THIS.`_limit_instances, `instance)
    ELSIF `state == `INTERP_STATE_PAUSE:
      `push(THIS.`_pause_instances, `instance)
    ELSIF `state == `INTERP_STATE_YIELD:
      `push(THIS.`_yield_instances, `instance)
    ELSIF `state == `INTERP_STATE_ERROR:
      `push(THIS.`_error_instances, `instance)
    ELSIF `state == `INTERP_STATE_ENDED:
      `push(THIS.`_ended_instances, `instance)
    ENDIF

ENDCLASS

CLASS Prequel:

  METHOD_INIT(`onProcedure `onYieldResume `rnd32b `now):
    THIS.`_prequel_m = NEW `PrequelM({})
    THIS.`_prequel_m.`init(`onProcedure, `onYieldResume, `rnd32b, `now)
    THIS.`_error = NULL

  METHOD getVersion():
    return "1.0"

  METHOD setCallbacks(`onProcedure `onYieldResume `rnd32b `now):
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `length(`instances) > 0:
      THIS.`_error = "NON"+"-"+"EMPTY"+" "+"INSTANCES"
      return NULL
    ENDIF
    THIS.`_prequel_m.`setCallbacks(`onProcedure, `onYieldResume, `rnd32b, `now)
    return TRUE

  METHOD getModules():
    return `utils.`deepCopy(THIS.`_prequel_m.`getModules())

  METHOD openModule(`source_code `module_name):
    IF `not(`lexer.`isValidSourceCode(`source_code)):
      THIS.`_error = "INVALID"+" "+"SOURCE"+" "+"CODE"
      return NULL
    ENDIF
    VAR `module_name_lcase
    VAR `modules
    VAR `j
    VAR `module_name_lcase_j
    IF `is_type_str(`get_type(`module_name)):
      IF `length(`module_name) == 0:
        THIS.`_error = "EMPTY"+" "+"MODULE"+" "+"NAME"
        return NULL
      ENDIF
      IF `not(`lexer.`isValidModuleName(`module_name)):
        THIS.`_error = "INVALID"+" "+"CHARACTERS"+" "+"IN"+" "+"MODULE"+" "+"NAME"
        return NULL
      ENDIF
      `module_name_lcase = `lowercase(`module_name)
      `modules = THIS.`_prequel_m.`getModules()
      FORINCR `j(0 `length(`modules)):
        `module_name_lcase_j = THIS.`_prequel_m.`getModuleNameLcase(`modules[`j])
        IF `module_name_lcase_j > `module_name_lcase:
          break
        ENDIF
        IF `module_name_lcase_j == `module_name_lcase:
          THIS.`_error = "DUPLICATE"+" "+"MODULE"+" "+"NAME"
          return NULL
        ENDIF
      ENDFOR
    ELSIF `not(`isnull(`module_name)):
      THIS.`_error = "INVALID"+" "+"MODULE"+" "+"NAME"
      return NULL
    ENDIF
    VAR `module = THIS.`_prequel_m.`openModule(`source_code, `module_name)
    VAR `parser_error_info = THIS.`_prequel_m.`getParserError(`module)
    VAR `parser_error = {}
    VAR `entry_lnno
    IF `not(`isnull(`parser_error_info)):
      `parser_error["lnno"] = `parser_error_info[1]
      `parser_error["startcol"] = `parser_error_info[2]
      `parser_error["endcol"] = `parser_error_info[3]
      `parser_error["error_message"] = `parser_error_info[4]
    ELSE:
      IF `not(THIS.`_prequel_m.`isCompiled(`module)):
        THIS.`_prequel_m.`compile(`module)
      ENDIF
      `entry_lnno = THIS.`_prequel_m.`getEntryLnno(`module)
      IF `entry_lnno < 0:
        `parser_error["lnno"] = -1
        `parser_error["startcol"] = -1
        `parser_error["endcol"] = -1
        `parser_error["error_message"] = "NO"+" "+"INSTRUCTION"+" "+"FOUND"
      ELSE:
        `parser_error["error_message"] = ""
      ENDIF
    ENDIF
    VAR `result = {}
    `result["module"] = `module
    `result["parser_error"] = `parser_error
    `result["source_code"] = THIS.`_prequel_m.`getSourceCode(`module)
    `result["module_name"] = THIS.`_prequel_m.`getModuleName(`module)
    return `result

  METHOD closeModule(`module):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    VAR `module_instances = THIS.`_prequel_m.`getModuleInstances(`module)
    IF `length(`module_instances) > 0:
      THIS.`_error = "MODULE"+" "+"HAS"+" "+"INSTANCES"
      return NULL
    ENDIF
    THIS.`_prequel_m.`closeModule(`module)
    return TRUE

  METHOD getSourceCode(`module):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    return THIS.`_prequel_m.`getSourceCode(`module)

  METHOD setSourceCode(`module `source_code):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    IF `not(`lexer.`isValidSourceCode(`source_code)):
      THIS.`_error = "INVALID"+" "+"SOURCE"+" "+"CODE"
      return NULL
    ENDIF
    VAR `module_instances = THIS.`_prequel_m.`getModuleInstances(`module)
    IF `length(`module_instances) > 0:
      THIS.`_error = "MODULE"+" "+"HAS"+" "+"INSTANCES"
      return NULL
    ENDIF
    THIS.`_prequel_m.`setSourceCode(`module, `source_code)
    return THIS.`_prequel_m.`getSourceCode(`module)

  METHOD getModuleName(`module):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    return THIS.`_prequel_m.`getModuleName(`module)

  METHOD renameModule(`module `module_name):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    IF `not(`is_type_str(`get_type(`module_name))):
      THIS.`_error = "INVALID"+" "+"MODULE"+" "+"NAME"
      return NULL
    ENDIF
    IF `length(`module_name) == 0:
      THIS.`_error = "EMPTY"+" "+"MODULE"+" "+"NAME"
      return NULL
    ENDIF
    IF `not(`lexer.`isValidModuleName(`module_name)):
      THIS.`_error = "INVALID"+" "+"CHARACTERS"+" "+"IN"+" "+"MODULE"+" "+"NAME"
      return NULL
    ENDIF
    VAR `module_name_lcase = `lowercase(`module_name)
    VAR `old_module_name_lcase = THIS.`_prequel_m.`getModuleNameLcase(`module)
    VAR `j
    VAR `module_name_lcase_j
    IF `module_name_lcase != `old_module_name_lcase:
      FORINCR `j(0 `length(`modules)):
        `module_name_lcase_j = THIS.`_prequel_m.`getModuleNameLcase(`modules[`j])
        IF `module_name_lcase_j > `module_name_lcase:
          break
        ENDIF
        IF `module_name_lcase_j == `module_name_lcase:
          THIS.`_error = "DUPLICATE"+" "+"MODULE"+" "+"NAME"
          return NULL
        ENDIF
      ENDFOR
    ENDIF
    THIS.`_prequel_m.`renameModule(`module, `module_name)
    return TRUE

  METHOD getLnnoCount(`module):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    return THIS.`_prequel_m.`getLnnoCount(`module)

  METHOD getTokens(`module `lnno):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    IF `not(`is_type_num(`get_type(`lnno))) OR (`lnno != `trunc(`lnno)) OR (`lnno < 0):
      THIS.`_error = "INVALID"+" "+"LNNO"
      return NULL
    ENDIF
    VAR `lnno_count = THIS.`_prequel_m.`getLnnoCount(`module)
    IF `lnno >= `lnno_count:
      THIS.`_error = "INVALID"+" "+"LNNO"
      return NULL
    ENDIF
    VAR `raw_tokens = THIS.`_prequel_m.`getTokens(`module, `lnno)
    VAR `tokens = []
    VAR `j
    VAR `token_name
    VAR `token_value
    VAR `token_extra
    FORINCR `j(0 `length(`raw_tokens)-1):
      `token_name = `lexer.`tokenName(`raw_tokens[`j])
      `token_value = `lexer.`tokenValue(`raw_tokens[`j])
      IF `lexer.`isCompoundToken(`token_name):
        `token_extra = `lexer.`tokenExtra(`raw_tokens[`j])
        `push(`tokens, [TERNARY{`indexof(`token_extra, ".") >= 0}{"QUALVAR"}{"VAR"}, `token_extra])
        `push(`tokens, [`token_name, "."+`token_name])
      ELSE:
        `push(`tokens, [`token_name, `token_value])
      ENDIF
    ENDFOR
    return `tokens

  METHOD getParserError(`module):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    VAR `parser_error_info = THIS.`_prequel_m.`getParserError(`module)
    VAR `parser_error = {}
    VAR `entry_lnno
    IF `not(`isnull(`parser_error_info)):
      `parser_error["lnno"] = `parser_error_info[1]
      `parser_error["startcol"] = `parser_error_info[2]
      `parser_error["endcol"] = `parser_error_info[3]
      `parser_error["error_message"] = `parser_error_info[4]
    ELSE:
      IF `not(THIS.`_prequel_m.`isCompiled(`module)):
        THIS.`_prequel_m.`compile(`module)
      ENDIF
      `entry_lnno = THIS.`_prequel_m.`getEntryLnno(`module)
      IF `entry_lnno < 0:
        `parser_error["lnno"] = -1
        `parser_error["startcol"] = -1
        `parser_error["endcol"] = -1
        `parser_error["error_message"] = "NO"+" "+"INSTRUCTION"+" "+"FOUND"
      ELSE:
        `parser_error["error_message"] = ""
      ENDIF
    ENDIF
    return `parser_error

  METHOD getEntryLnno(`module):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    VAR `parser_error = THIS.`_prequel_m.`getParserError(`module)
    IF `not(`isnull(`parser_error)):
      THIS.`_error = "PARSER"+" "+"ERROR"
      return NULL
    ENDIF
    IF `not(THIS.`_prequel_m.`isCompiled(`module)):
      THIS.`_prequel_m.`compile(`module)
    ENDIF
    VAR `entry_lnno = THIS.`_prequel_m.`getEntryLnno(`module)
    IF `entry_lnno < 0:
      THIS.`_error = "PARSER"+" "+"ERROR"
      return NULL
    ENDIF
    return `entry_lnno

  METHOD hasBreakpoint(`module `lnno):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    IF `not(`is_type_num(`get_type(`lnno))) OR (`lnno != `trunc(`lnno)) OR (`lnno < 0):
      THIS.`_error = "INVALID"+" "+"LNNO"
      return NULL
    ENDIF
    VAR `lnno_count = THIS.`_prequel_m.`getLnnoCount(`module)
    IF `lnno >= `lnno_count:
      THIS.`_error = "INVALID"+" "+"LNNO"
      return NULL
    ENDIF
    return THIS.`_prequel_m.`hasBreakpoint(`module, `lnno)

  METHOD setBreakpoint(`module `lnno):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    IF `not(`is_type_num(`get_type(`lnno))) OR (`lnno != `trunc(`lnno)) OR (`lnno < 0):
      THIS.`_error = "INVALID"+" "+"LNNO"
      return NULL
    ENDIF
    VAR `lnno_count = THIS.`_prequel_m.`getLnnoCount(`module)
    IF `lnno >= `lnno_count:
      THIS.`_error = "INVALID"+" "+"LNNO"
      return NULL
    ENDIF
    THIS.`_prequel_m.`setBreakpoint(`module, `lnno)
    return TRUE

  METHOD clearBreakpoint(`module `lnno):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    IF `not(`is_type_num(`get_type(`lnno))) OR (`lnno != `trunc(`lnno)) OR (`lnno < 0):
      THIS.`_error = "INVALID"+" "+"LNNO"
      return NULL
    ENDIF
    VAR `lnno_count = THIS.`_prequel_m.`getLnnoCount(`module)
    IF `lnno >= `lnno_count:
      THIS.`_error = "INVALID"+" "+"LNNO"
      return NULL
    ENDIF
    THIS.`_prequel_m.`clearBreakpoint(`module, `lnno)
    return TRUE

  METHOD getEnvs():
    return `utils.`deepCopy(THIS.`_prequel_m.`getEnvs())

  METHOD createEnv():
    return THIS.`_prequel_m.`createEnv()

  METHOD deleteEnv(`env):
    VAR `envs = THIS.`_prequel_m.`getEnvs()
    IF `indexof(`envs, `env) < 0:
      THIS.`_error = "INVALID"+" "+"ENV"
      return NULL
    ENDIF
    VAR `env_instances = THIS.`_prequel_m.`getEnvInstances(`env)
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `not(`isnull(`running_instance)) AND (`indexof(`env_instances, `running_instance) >= 0):
      THIS.`_error = "ENV"+" "+"IN"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    THIS.`_prequel_m.`deleteEnv(`env)
    return TRUE

  METHOD getModuleInstances(`module):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    return `utils.`deepCopy(THIS.`_prequel_m.`getModuleInstances(`module))

  METHOD addInstance(`module):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    VAR `parser_error = THIS.`_prequel_m.`getParserError(`module)
    IF `not(`isnull(`parser_error)):
      THIS.`_error = "PARSER"+" "+"ERROR"
      return NULL
    ENDIF
    IF `not(THIS.`_prequel_m.`isCompiled(`module)):
      THIS.`_prequel_m.`compile(`module)
    ENDIF
    VAR `entry_lnno = THIS.`_prequel_m.`getEntryLnno(`module)
    IF `entry_lnno < 0:
      THIS.`_error = "PARSER"+" "+"ERROR"
      return NULL
    ENDIF
    VAR `instance = THIS.`_prequel_m.`addInstance(`module)
    return `instance

  METHOD cloneInstance(`instance):
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `running_instance == `instance:
      THIS.`_error = "RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `instance_state = THIS.`_prequel_m.`getInstanceState(`instance)
    IF `instance_state != `INTERP_STATE_READY:
      THIS.`_error = "ACTIVE"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `cloned_instance = THIS.`_prequel_m.`cloneInstance(`instance)
    return `cloned_instance

  METHOD removeInstance(`instance):
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `running_instance == `instance:
      THIS.`_error = "RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `instance_state = THIS.`_prequel_m.`getInstanceState(`instance)
    IF `instance_state != `INTERP_STATE_READY:
      THIS.`_error = "ACTIVE"+" "+"INSTANCE"
      return NULL
    ENDIF
    THIS.`_prequel_m.`removeInstance(`instance)
    return TRUE

  METHOD getInstanceEnvs(`instance):
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    return `utils.`deepCopy(THIS.`_prequel_m.`getInstanceEnvs(`instance))

  METHOD pushEnv(`instance `env):
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `envs = THIS.`_prequel_m.`getEnvs()
    IF `indexof(`envs, `env) < 0:
      THIS.`_error = "INVALID"+" "+"ENV"
      return NULL
    ENDIF
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `running_instance == `instance:
      THIS.`_error = "RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    THIS.`_prequel_m.`pushEnv(`instance, `env)
    return TRUE

  METHOD removeEnv(`instance `env):
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `envs = THIS.`_prequel_m.`getEnvs()
    IF `indexof(`envs, `env) < 0:
      THIS.`_error = "INVALID"+" "+"ENV"
      return NULL
    ENDIF
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `running_instance == `instance:
      THIS.`_error = "RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    THIS.`_prequel_m.`removeEnv(`instance, `env)
    return TRUE

  METHOD getVarNames(`env):
    VAR `envs = THIS.`_prequel_m.`getEnvs()
    IF `indexof(`envs, `env) < 0:
      THIS.`_error = "INVALID"+" "+"ENV"
      return NULL
    ENDIF
    return `utils.`deepCopy(THIS.`_prequel_m.`getVarNames(`env))

  METHOD addVar(`env `varname `varvalue):
    VAR `envs = THIS.`_prequel_m.`getEnvs()
    IF `indexof(`envs, `env) < 0:
      THIS.`_error = "INVALID"+" "+"ENV"
      return NULL
    ENDIF
    VAR `env_instances = THIS.`_prequel_m.`getEnvInstances(`env)
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `not(`isnull(`running_instance)) AND (`indexof(`env_instances, `running_instance) >= 0):
      THIS.`_error = "ENV"+" "+"IN"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    IF `not(`lexer.`isValidVarname(`varname)):
      THIS.`_error = "INVALID"+" "+"VARNAME"
      return NULL
    ENDIF
    VAR `varnames = THIS.`_prequel_m.`getVarNames(`env)
    IF `indexof(`varnames, `varname) >= 0:
      THIS.`_error = "DUPLICATE"+" "+"VARNAME"
      return NULL
    ENDIF
    VAR `procnames = THIS.`_prequel_m.`getProcedureNames(`env)
    IF `indexof(`procnames, `varname) >= 0:
      THIS.`_error = "PROCEDURE"+" "+"NAMED"+" "+"VARNAME"+" "+"ALREADY"+" "+"EXISTS"
      return NULL
    ENDIF
    VAR `evalue = `utils.`encodeData(`varvalue)
    IF `isnull(`evalue):
      THIS.`_error = "INVALID"+" "+"VARVALUE"
      return NULL
    ENDIF
    THIS.`_prequel_m.`addVar(`env, `varname, `evalue)
    return TRUE

  METHOD overwriteVar(`env `varname `varvalue):
    VAR `envs = THIS.`_prequel_m.`getEnvs()
    IF `indexof(`envs, `env) < 0:
      THIS.`_error = "INVALID"+" "+"ENV"
      return NULL
    ENDIF
    VAR `env_instances = THIS.`_prequel_m.`getEnvInstances(`env)
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `not(`isnull(`running_instance)) AND (`indexof(`env_instances, `running_instance) >= 0):
      THIS.`_error = "ENV"+" "+"IN"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `varnames = THIS.`_prequel_m.`getVarNames(`env)
    VAR `procnames
    VAR `evalue
    IF `indexof(`varnames, `varname) < 0:
      IF `not(`lexer.`isValidVarname(`varname)):
        THIS.`_error = "INVALID"+" "+"VARNAME"
        return NULL
      ENDIF
      `procnames = THIS.`_prequel_m.`getProcedureNames(`env)
      IF `indexof(`procnames, `varname) >= 0:
        THIS.`_error = "PROCEDURE"+" "+"NAMED"+" "+"VARNAME"+" "+"ALREADY"+" "+"EXISTS"
        return NULL
      ENDIF
      `evalue = `utils.`encodeData(`varvalue)
      IF `isnull(`evalue):
        THIS.`_error = "INVALID"+" "+"VARVALUE"
        return NULL
      ENDIF
      THIS.`_prequel_m.`addVar(`env, `varname, `evalue)
      return TRUE
    ENDIF
    IF `not(THIS.`_prequel_m.`overwriteVar(`env, `varname, `varvalue)):
      THIS.`_error = "INVALID"+" "+"VARVALUE"
      return NULL
    ENDIF
    return TRUE

  METHOD getVar(`env `varname):
    VAR `envs = THIS.`_prequel_m.`getEnvs()
    IF `indexof(`envs, `env) < 0:
      THIS.`_error = "INVALID"+" "+"ENV"
      return NULL
    ENDIF
    VAR `varnames = THIS.`_prequel_m.`getVarNames(`env)
    IF `indexof(`varnames, `varname) < 0:
      IF `not(`lexer.`isValidVarname(`varname)):
        THIS.`_error = "INVALID"+" "+"VARNAME"
        return NULL
      ENDIF
      return ""
    ENDIF
    VAR `evalue = THIS.`_prequel_m.`getVar(`env, `varname)
    VAR `varvalue = `utils.`decodeData(`evalue)
    IF `isnull(`varvalue):
      THIS.`_error = "INVALID"+" "+"VARVALUE"
      return NULL
    ENDIF
    return `varvalue[1]

  METHOD removeVar(`env `varname):
    VAR `envs = THIS.`_prequel_m.`getEnvs()
    IF `indexof(`envs, `env) < 0:
      THIS.`_error = "INVALID"+" "+"ENV"
      return NULL
    ENDIF
    VAR `env_instances = THIS.`_prequel_m.`getEnvInstances(`env)
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `not(`isnull(`running_instance)) AND (`indexof(`env_instances, `running_instance) >= 0) AND `isnull(THIS.`_prequel_m.`getStatusCode(`running_instance)):
      THIS.`_error = "ENV"+" "+"IN"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `varnames = THIS.`_prequel_m.`getVarNames(`env)
    IF `indexof(`varnames, `varname) < 0:
      IF `not(`lexer.`isValidVarname(`varname)):
        THIS.`_error = "INVALID"+" "+"VARNAME"
        return NULL
      ENDIF
      THIS.`_error = "UNKNOWN"+" "+"VARNAME"
      return NULL
    ENDIF
    THIS.`_prequel_m.`removeVar(`env, `varname)
    return TRUE

  METHOD getProcedureNames(`env):
    VAR `envs = THIS.`_prequel_m.`getEnvs()
    IF `indexof(`envs, `env) < 0:
      THIS.`_error = "INVALID"+" "+"ENV"
      return NULL
    ENDIF
    return `utils.`deepCopy(THIS.`_prequel_m.`getProcedureNames(`env))

  METHOD addProcedure(`env `procname `args_synopsis):
    VAR `envs = THIS.`_prequel_m.`getEnvs()
    IF `indexof(`envs, `env) < 0:
      THIS.`_error = "INVALID"+" "+"ENV"
      return NULL
    ENDIF
    VAR `env_instances = THIS.`_prequel_m.`getEnvInstances(`env)
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `not(`isnull(`running_instance)) AND (`indexof(`env_instances, `running_instance) >= 0):
      THIS.`_error = "ENV"+" "+"IN"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    IF `not(`lexer.`isValidVarname(`procname)):
      THIS.`_error = "INVALID"+" "+"PROCNAME"
      return NULL
    ENDIF
    VAR `procnames = THIS.`_prequel_m.`getProcedureNames(`env)
    IF `indexof(`procnames, `procname) >= 0:
      THIS.`_error = "DUPLICATE"+" "+"PROCNAME"
      return NULL
    ENDIF
    VAR `varnames = THIS.`_prequel_m.`getVarNames(`env)
    IF `indexof(`varnames, `procname) >= 0:
      THIS.`_error = "VAR"+" "+"NAMED"+" "+"PROCNAME"+" "+"ALREADY"+" "+"EXISTS"
      return NULL
    ENDIF
    VAR `evalue = `utils.`encodeProcedure(`args_synopsis)
    IF `isnull(`evalue):
      THIS.`_error = "INVALID"+" "+"ARGS"+" "+"SYNOPSIS"
      return NULL
    ENDIF
    THIS.`_prequel_m.`addProcedure(`env, `procname, `evalue)
    return TRUE

  METHOD existsProcedure(`env `procname):
    VAR `envs = THIS.`_prequel_m.`getEnvs()
    IF `indexof(`envs, `env) < 0:
      THIS.`_error = "INVALID"+" "+"ENV"
      return NULL
    ENDIF
    VAR `procnames = THIS.`_prequel_m.`getProcedureNames(`env)
    IF `indexof(`procnames, `procname) < 0:
      IF `not(`lexer.`isValidVarname(`procname)):
        THIS.`_error = "INVALID"+" "+"PROCNAME"
        return NULL
      ENDIF
      return FALSE
    ENDIF
    return TRUE

  METHOD removeProcedure(`env `procname):
    VAR `envs = THIS.`_prequel_m.`getEnvs()
    IF `indexof(`envs, `env) < 0:
      THIS.`_error = "INVALID"+" "+"ENV"
      return NULL
    ENDIF
    VAR `env_instances = THIS.`_prequel_m.`getEnvInstances(`env)
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `not(`isnull(`running_instance)) AND (`indexof(`env_instances, `running_instance) >= 0):
      THIS.`_error = "ENV"+" "+"IN"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `procnames = THIS.`_prequel_m.`getProcedureNames(`env)
    IF `indexof(`procnames, `procname) < 0:
      IF `not(`lexer.`isValidVarname(`procname)):
        THIS.`_error = "INVALID"+" "+"PROCNAME"
        return NULL
      ENDIF
      THIS.`_error = "UNKNOWN"+" "+"PROCNAME"
      return NULL
    ENDIF
    THIS.`_prequel_m.`removeProcedure(`env, `procname)
    return TRUE

  METHOD getInstanceVarNames(`instance):
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    return `utils.`deepCopy(THIS.`_prequel_m.`getInstanceVarNames(`instance))

  METHOD addInstanceVar(`ivarname `ivarvalue):
    VAR `instance = THIS.`_prequel_m.`getRunningInstance()
    IF `isnull(`instance):
      THIS.`_error = "NOT"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    IF `not(`lexer.`isValidIvarname(`ivarname)):
      THIS.`_error = "INVALID"+" "+"IVARNAME"
      return NULL
    ENDIF
    VAR `ivarnames = THIS.`_prequel_m.`getInstanceVarNames(`instance)
    IF `indexof(`ivarnames, `ivarname) >= 0:
      THIS.`_error = "DUPLICATE"+" "+"IVARNAME"
      return NULL
    ENDIF
    VAR `evalue = `utils.`encodeData(`ivarvalue)
    IF `isnull(`evalue):
      THIS.`_error = "INVALID"+" "+"IVARVALUE"
      return NULL
    ENDIF
    THIS.`_prequel_m.`addInstanceVar(`instance, `ivarname, `evalue)
    return TRUE

  METHOD getInstanceVar(`instance `ivarname):
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    IF `not(`lexer.`isValidIvarname(`ivarname)):
      THIS.`_error = "INVALID"+" "+"IVARNAME"
      return NULL
    ENDIF
    VAR `evalue = THIS.`_prequel_m.`getInstanceVar(`instance, `ivarname)
    VAR `ivarvalue
    IF `not(`isnull(`evalue)):
      `ivarvalue = `utils.`decodeData(`evalue)
      IF `isnull(`ivarvalue):
        THIS.`_error = "INVALID"+" "+"IVARVALUE"
        return NULL
      ENDIF
      return `ivarvalue[1]
    ENDIF
    return ""

  METHOD removeInstanceVar(`ivarname):
    VAR `instance = THIS.`_prequel_m.`getRunningInstance()
    IF `isnull(`instance):
      THIS.`_error = "NOT"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `ivarnames = THIS.`_prequel_m.`getInstanceVarNames(`instance)
    IF `indexof(`ivarnames, `ivarname) < 0:
      IF `not(`lexer.`isValidIvarname(`ivarname)):
        THIS.`_error = "INVALID"+" "+"IVARNAME"
        return NULL
      ENDIF
      THIS.`_error = "UNKNOWN"+" "+"IVARNAME"
      return NULL
    ENDIF
    IF THIS.`_prequel_m.`inRepeatVars(`instance, `ivarname) AND `isnull(THIS.`_prequel_m.`getStatusCode(`instance)):
      THIS.`_error = "IVARNAME"+" "+"IN"+" "+"REPEAT"+" "+"VARIABLES"
      return NULL
    ENDIF
    THIS.`_prequel_m.`removeInstanceVar(`instance, `ivarname)
    return TRUE

  METHOD getInstanceState(`instance):
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    return THIS.`_prequel_m.`getInstanceState(`instance)

  METHOD run(`instance `stepping `limits):
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `not(`isnull(`running_instance)):
      THIS.`_error = "ALREADY"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `instance_state = THIS.`_prequel_m.`getInstanceState(`instance)
    IF `instance_state != `INTERP_STATE_READY:
      THIS.`_error = "NOT"+" "+"READY"+" "+"INSTANCE"
      return NULL
    ENDIF
    IF `not(`is_type_bool(`get_type(`stepping))):
      THIS.`_error = "STEPPING"+" "+"IS"+" "+"NOT"+" "+"BOOLEAN"
      return NULL
    ENDIF
    `limits = `utils.`getNormalizedLimits(`limits)
    IF `isnull(`limits):
      THIS.`_error = "INVALID"+" "+"LIMITS"
      return NULL
    ENDIF
    VAR `result_list = THIS.`_prequel_m.`run(`instance, `stepping, `limits)
    `instance_state = `result_list[0]
    VAR `result = {}
    `result["state"] = `instance_state
    `result["count"] = `utils.`setNormalizedLimits(`result_list[1])
    `result["lnno"] = `result_list[2]
    IF `instance_state == `INTERP_STATE_ENDED:
      `result["status_code"] = `result_list[3]
    ELSIF `instance_state == `INTERP_STATE_ERROR:
      `result["error_message"] = `result_list[3]
    ENDIF
    return `result

  METHOD resume(`instance `stepping `limits):
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `not(`isnull(`running_instance)):
      THIS.`_error = "ALREADY"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `instance_state = THIS.`_prequel_m.`getInstanceState(`instance)
    IF (`instance_state < `INTERP_STATE_LIMIT) OR (`instance_state > `INTERP_STATE_YIELD):
      THIS.`_error = "INVALID"+" "+"INSTANCE"+" "+"STATE"
      return NULL
    ENDIF
    IF `not(`is_type_bool(`get_type(`stepping))):
      THIS.`_error = "STEPPING"+" "+"IS"+" "+"NOT"+" "+"BOOLEAN"
      return NULL
    ENDIF
    IF `not(`isnull(`limits)):
      `limits = `utils.`getNormalizedLimits(`limits)
      IF `isnull(`limits):
        THIS.`_error = "INVALID"+" "+"LIMITS"
        return NULL
      ENDIF
    ENDIF
    VAR `result_list = THIS.`_prequel_m.`resume(`instance, `stepping, `limits)
    `instance_state = `result_list[0]
    VAR `result = {}
    `result["state"] = `instance_state
    `result["count"] = `utils.`setNormalizedLimits(`result_list[1])
    `result["lnno"] = `result_list[2]
    IF `instance_state == `INTERP_STATE_ENDED:
      `result["status_code"] = `result_list[3]
    ELSIF `instance_state == `INTERP_STATE_ERROR:
      `result["error_message"] = `result_list[3]
    ENDIF
    return `result

  METHOD reap(`instance):
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `not(`isnull(`running_instance)):
      THIS.`_error = "RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    THIS.`_prequel_m.`reap(`instance)
    return TRUE

  METHOD reset(`instance):
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `not(`isnull(`running_instance)):
      THIS.`_error = "RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `instance_state = THIS.`_prequel_m.`getInstanceState(`instance)
    IF `instance_state != `INTERP_STATE_READY:
      THIS.`_error = "NOT"+" "+"READY"+" "+"INSTANCE"
      return NULL
    ENDIF
    THIS.`_prequel_m.`reset(`instance)
    return TRUE

  METHOD returnWithStatus(`status_code):
    VAR `instance = THIS.`_prequel_m.`getRunningInstance()
    IF `isnull(`instance):
      THIS.`_error = "NOT"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    IF `not(`is_type_num(`get_type(`status_code))) OR (`status_code != `trunc(`status_code)) OR (`status_code != `int32(`status_code & 0xffffffff)):
      THIS.`_error = "INVALID"+" "+"STATUS"+" "+"CODE"
      return NULL
    ENDIF
    THIS.`_prequel_m.`returnWithStatus(`instance, `status_code)
    return TRUE

  METHOD prequelYield():
    VAR `instance = THIS.`_prequel_m.`getRunningInstance()
    IF `isnull(`instance):
      THIS.`_error = "NOT"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    THIS.`_prequel_m.`prequelYield(`instance)
    return TRUE

  METHOD runtimeError(`error_message):
    VAR `instance = THIS.`_prequel_m.`getRunningInstance()
    IF `isnull(`instance):
      THIS.`_error = "NOT"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    IF `not(`utils.`isValidErrorMessage(`error_message)):
      THIS.`_error = "INVALID"+" "+"ERROR"+" "+"MESSAGE"
      return NULL
    ENDIF
    THIS.`_prequel_m.`runtimeError(`instance, `error_message)
    return TRUE

  METHOD readLog(`instance):
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    return THIS.`_prequel_m.`readLog(`instance)

  METHOD readChangedVars(`instance):
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    return THIS.`_prequel_m.`readChangedVars(`instance)

  METHOD edAddLine(`module `lnno):
    THIS.`_error = "NOT"+" "+"IMPLEMENTED"
    return NULL

  METHOD edSetLine(`module `lnno `line):
    THIS.`_error = "NOT"+" "+"IMPLEMENTED"
    return NULL

  METHOD edDelLine(`module `lnno):
    THIS.`_error = "NOT"+" "+"IMPLEMENTED"
    return NULL

  METHOD edAddLineAfter(`module `lnno):
    THIS.`_error = "NOT"+" "+"IMPLEMENTED"
    return NULL

  METHOD edCutLine(`module `lnno):
    THIS.`_error = "NOT"+" "+"IMPLEMENTED"
    return NULL

  METHOD edPasteLines(`module `lnno):
    THIS.`_error = "NOT"+" "+"IMPLEMENTED"
    return NULL

  METHOD edIndentLine(`module `lnno):
    THIS.`_error = "NOT"+" "+"IMPLEMENTED"
    return NULL

  METHOD edCanUndo(`module):
    THIS.`_error = "NOT"+" "+"IMPLEMENTED"
    return NULL

  METHOD edCanRedo(`module):
    THIS.`_error = "NOT"+" "+"IMPLEMENTED"
    return NULL

  METHOD edUndo(`module):
    THIS.`_error = "NOT"+" "+"IMPLEMENTED"
    return NULL

  METHOD edRedo(`module):
    THIS.`_error = "NOT"+" "+"IMPLEMENTED"
    return NULL

  METHOD isInstanceStateReady(`instance_state):
    return (`instance_state == `INTERP_STATE_READY)

  METHOD isInstanceStateLimit(`instance_state):
    return (`instance_state == `INTERP_STATE_LIMIT)

  METHOD isInstanceStatePause(`instance_state):
    return (`instance_state == `INTERP_STATE_PAUSE)

  METHOD isInstanceStateYield(`instance_state):
    return (`instance_state == `INTERP_STATE_YIELD)

  METHOD isInstanceStateError(`instance_state):
    return (`instance_state == `INTERP_STATE_ERROR)

  METHOD isInstanceStateEnded(`instance_state):
    return (`instance_state == `INTERP_STATE_ENDED)

  METHOD isArgTypeInteger(`arg):
    IF `not(`utils.`isArgData(`arg)):
      THIS.`_error = "INVALID"+" "+"ARG"
      return NULL
    ENDIF
    return (`arg[0] == `ARG_TYPE_INTEGER)

  METHOD isArgTypeList(`arg):
    IF `not(`utils.`isArgData(`arg)):
      THIS.`_error = "INVALID"+" "+"ARG"
      return NULL
    ENDIF
    return (`arg[0] == `ARG_TYPE_LIST)

  METHOD isArgTypeString(`arg):
    IF `not(`utils.`isArgData(`arg)):
      THIS.`_error = "INVALID"+" "+"ARG"
      return NULL
    ENDIF
    return (`arg[0] == `ARG_TYPE_STRING)

  METHOD isArgTypeVarname(`arg):
    IF `not(`utils.`isArgData(`arg)):
      THIS.`_error = "INVALID"+" "+"ARG"
      return NULL
    ENDIF
    return (`arg[0] == `ARG_TYPE_VARNAME)

  METHOD isArgTypeModname(`arg):
    IF `not(`utils.`isArgData(`arg)):
      THIS.`_error = "INVALID"+" "+"ARG"
      return NULL
    ENDIF
    return (`arg[0] == `ARG_TYPE_MODNAME)

  METHOD getArgValue(`arg):
    IF `not(`utils.`isArgData(`arg)):
      THIS.`_error = "INVALID"+" "+"ARG"
      return NULL
    ENDIF
    return `arg[1]

  METHOD getCostValue(`varvalue):
    VAR `evalue = `utils.`encodeData(`varvalue)
    IF `isnull(`evalue):
      THIS.`_error = "INVALID"+" "+"VARVALUE"
      return NULL
    ENDIF
    VAR `isize = `utils.`isizeEvalue(`evalue)
    VAR `lsize = `utils.`lsizeEvalue(`evalue)
    VAR `cost = {}
    `cost["memory"] = `lsize+`isize
    `cost["memory_i"] = `isize
    `cost["memory_l"] = `lsize
    return `cost

  METHOD isValidSourceCode(`source_code):
    return `lexer.`isValidSourceCode(`source_code)

  METHOD isValidModuleName(`module_name):
    return `lexer.`isValidModuleName(`module_name)

  METHOD isValidVarname(`varname):
    return `lexer.`isValidVarname(`varname)

  METHOD isValidIvarname(`ivarname):
    return `lexer.`isValidIvarname(`ivarname)

  METHOD readError():
    VAR `error = THIS.`_error
    THIS.`_error = NULL
    return `error

  METHOD clearError():
    THIS.`_error = NULL
    return TRUE

ENDCLASS
