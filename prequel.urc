COMMENT FP class available at https://github.com/simoesh/FixPointCS/tree/urcode
VAR `fp = [NULL]

CLASS `ResourceIds:

  METHOD_INIT():
    THIS.`_ids = []
    THIS.`_cur_id = 1+`trunc(0.5+`random()*1000)
    THIS.`_free_ids = []

  METHOD `alloc():
    VAR `an_id
    IF `length(THIS.`_free_ids) > 0:
      `an_id = `pop(THIS.`_free_ids)
    ELSE:
      `an_id = THIS.`_cur_id
      THIS.`_cur_id += 1
    ENDIF
    `queue(THIS.`_ids, `an_id)
    return `an_id

  METHOD `free(`an_id):
    VAR `index = `indexof(THIS.`_ids, `an_id)
    IF `index < 0:
      `warning("Prequel"+" "+"ResourceIds"+" "+"free"+":"+" "+"id"+" "+"does"+" "+"not"+" "+"exist"+":", `an_id)
      return
    ENDIF
    `push(THIS.`_free_ids, THIS.`_ids[`index])
    `pick(THIS.`_ids, `index)

ENDCLASS

VAR `ARG_TYPE_NUMBER = 0
VAR `ARG_TYPE_LIST = 1
VAR `ARG_TYPE_STRING = 2
VAR `ARG_TYPE_VARNAME = 3
VAR `ARG_TYPE_MODNAME = 4

VAR `key_limits_instructions = 0
VAR `key_limits_max_memory = 1
VAR `key_limits_memory = 2
VAR `key_limits_memory_n = 3
VAR `key_limits_memory_l = 4

VAR `key_interp_boolean = 0
VAR `key_interp_by_ref = 1
VAR `key_interp_number = 2
VAR `key_interp_list = 3
VAR `key_interp_module_name = 4
VAR `key_interp_procedure = 5
VAR `key_interp_string = 6

CLASS `Utils:

  METHOD_INIT():
    VAR `x = NULL

  METHOD `deepCopy(`val):
    VAR `val_type = `get_type(`val)
    VAR `arr
    VAR `obj
    VAR `j
    VAR `k
    IF `is_type_list(`val_type):
      `arr = []
      FORINCR `j(0 `length(`val)):
        `push(`arr, THIS.`deepCopy(`val[`j]))
      ENDFOR
      return `arr
    ENDIF
    IF `is_type_dict(`val_type):
      `obj = {}
      FOREACH `k(`val):
        `obj[`k] = THIS.`deepCopy(`val[`k])
      ENDFOR
      return `obj
    ENDIF
    return `val

  METHOD `isValidErrorMessage(`error_message):
    IF `not(`is_type_str(`get_type(`error_message))):
      return FALSE
    ENDIF
    IF `length(`error_message) == 0:
      return FALSE
    ENDIF
    IF `length(`error_message) != `length(`strip(`error_message)):
      return FALSE
    ENDIF
    VAR `j
    VAR `code
    FORINCR `j(0 `length(`error_message)):
      `code = `char_code_at(`error_message, `j)
      IF (`code < 32) OR (`code > 126):
        return FALSE
      ENDIF
    ENDFOR
    return TRUE

  METHOD `isValidArgsSynopsis(`args_synopsis):
    IF `not(`is_type_list(`get_type(`args_synopsis))):
      return FALSE
    ENDIF
    VAR `j
    FORINCR `j(0 `length(`args_synopsis)):
      IF `not(THIS.`isValidErrorMessage(`args_synopsis[`j])):
        return FALSE
      ENDIF
    ENDFOR
    return TRUE

  METHOD `isInt32b(`val):
    return (`is_type_num(`get_type(`val)) AND (`val == `trunc(`val)) AND (`val == `int32(`val)))

  METHOD `isArgData(`arg):
    return (`is_type_list(`get_type(`arg)) AND `length(`arg) == 2 AND `is_type_num(`get_type(`arg[0])) AND `arg[0] >= `ARG_TYPE_NUMBER AND `arg[0] <= `ARG_TYPE_MODNAME)

  METHOD `getNormalizedLimits(`limits_):
    VAR `limits = {}
    `limits[`key_limits_instructions] = NULL
    `limits[`key_limits_memory] = NULL
    `limits[`key_limits_memory_n] = NULL
    `limits[`key_limits_memory_l] = NULL
    IF `is_type_dict(`get_type(`limits_)):
      IF "instructions" in `limits_:
        IF `not(THIS.`isInt32b(`limits_["instructions"])):
          return NULL
        ENDIF
        `limits[`key_limits_instructions] = `limits_["instructions"]
      ENDIF
      IF "memory" in `limits_:
        IF `not(THIS.`isInt32b(`limits_["memory"])):
          return NULL
        ENDIF
        `limits[`key_limits_memory] = `limits_["memory"]
      ENDIF
      IF "memory_n" in `limits_:
        IF `not(THIS.`isInt32b(`limits_["memory_n"])):
          return NULL
        ENDIF
        `limits[`key_limits_memory_n] = `limits_["memory_n"]
      ENDIF
      IF "memory_l" in `limits_:
        IF `not(THIS.`isInt32b(`limits_["memory_l"])):
          return NULL
        ENDIF
        `limits[`key_limits_memory_l] = `limits_["memory_l"]
      ENDIF
    ELSIF `not(`isnull(`limits_)):
      return NULL
    ENDIF
    return `limits

  METHOD `setNormalizedLimits(`limits_):
    VAR `limits = {}
    `limits["instructions"] = `limits_[`key_limits_instructions]
    `limits["max_memory"] = `limits_[`key_limits_max_memory]
    `limits["memory"] = `limits_[`key_limits_memory]
    `limits["memory_n"] = `limits_[`key_limits_memory_n]
    `limits["memory_l"] = `limits_[`key_limits_memory_l]
    return `limits

  METHOD `elemEqElem(`xs `ys):
    VAR `j
    IF `is_type_list(`get_type(`xs)):
      IF `not(`is_type_list(`get_type(`ys))):
        return FALSE
      ENDIF
      IF `length(`xs) != `length(`ys):
        return FALSE
      ENDIF
      FORINCR `j(0 `length(`xs)):
        IF `not(THIS.`elemEqElem(`xs[`j], `ys[`j])):
          return FALSE
        ENDIF
      ENDFOR
      return TRUE
    ENDIF
    IF `is_type_list(`get_type(`ys)):
      return FALSE
    ENDIF
    return (`xs == `ys)

  METHOD `structuralIndexOf(`l `e `from):
    VAR `j
    IF `from >= 0:
      FORINCR `j(`from `length(`l)):
        IF THIS.`elemEqElem(`l[`j], `e):
          return `j
        ENDIF
      ENDFOR
    ELSE:
      FORDECR `j(`length(`l)+`from 0):
        IF THIS.`elemEqElem(`l[`j], `e):
          return `j
        ENDIF
      ENDFOR
    ENDIF
    return -1

  METHOD `nsizeEvalue(`evalue):
    return `evalue[3]

  METHOD `lsizeEvalue(`evalue):
    return `evalue[2]

  METHOD `encodeProcedure(`args_synopsis):
    IF `not(THIS.`isValidArgsSynopsis(`args_synopsis)):
      return NULL
    ENDIF
    return [`key_interp_procedure, THIS.`deepCopy(`args_synopsis)]

  METHOD `encodeData(`data):
    VAR `data_type = `get_type(`data)
    VAR `nsize
    VAR `lsize
    VAR `elist
    VAR `evalue
    IF `is_type_num(`data_type):
      `nsize = 1
      `lsize = 0
      return [`key_interp_number, `data, `lsize, `nsize]
    ENDIF
    VAR `j
    IF `is_type_list(`data_type):
      `nsize = 0
      `lsize = 1
      `elist = []
      FORINCR `j(0 `length(`data)):
        `evalue = THIS.`encodeData(`data[`j])
        IF `isnull(`evalue):
          return NULL
        ENDIF
        `push(`elist, `evalue)
        `nsize += THIS.`nsizeEvalue(`evalue)
        `lsize += THIS.`lsizeEvalue(`evalue)
      ENDFOR
      return [`key_interp_list, `elist, `lsize, `nsize]
    ENDIF
    IF `is_type_bool(`data_type):
      `nsize = 1
      `lsize = 0
      return [`key_interp_number, `fp[0].FromFloat(`data), `lsize, `nsize]
    ENDIF
    `warning("Prequel"+" "+"Utils"+" "+"encodeData"+":"+" "+"invalid"+" "+"data"+":", `data)
    return NULL

  METHOD `encodeOverwriteData(`evalue `data):
    VAR `data_type = `get_type(`data)
    VAR `nsize
    VAR `lsize
    VAR `elist
    VAR `j
    VAR `evalueE
    IF `is_type_num(`data_type):
      IF `length(`evalue) == 0:
        `nsize = 1
        `lsize = 0
        `push(`evalue, `key_interp_number)
        `push(`evalue, `data)
        `push(`evalue, `lsize)
        `push(`evalue, `nsize)
      ELSE:
        IF `evalue[0] != `key_interp_number:
          `nsize = 1
          `lsize = 0
          `evalue[0] = `key_interp_number
          `evalue[2] = `lsize
          `evalue[3] = `nsize
        ENDIF
        `evalue[1] = `data
      ENDIF
      return TRUE
    ENDIF
    IF `is_type_list(`data_type):
      `nsize = 0
      `lsize = 1
      IF `length(`evalue) == 0:
        `elist = []
        FORINCR `j(0 `length(`data)):
          `evalueE = THIS.`encodeData(`data[`j])
          IF `isnull(`evalueE):
            return FALSE
          ENDIF
          `push(`elist, `evalueE)
          `nsize += THIS.`nsizeEvalue(`evalueE)
          `lsize += THIS.`lsizeEvalue(`evalueE)
        ENDFOR
        `push(`evalue, `key_interp_list)
        `push(`evalue, `elist)
        `push(`evalue, `lsize)
        `push(`evalue, `nsize)
      ELSIF `evalue[0] != `key_interp_list:
        `elist = []
        FORINCR `j(0 `length(`data)):
          `evalueE = THIS.`encodeData(`data[`j])
          IF `isnull(`evalueE):
            return FALSE
          ENDIF
          `push(`elist, `evalueE)
          `nsize += THIS.`nsizeEvalue(`evalueE)
          `lsize += THIS.`lsizeEvalue(`evalueE)
        ENDFOR
        `evalue[0] = `key_interp_list
        `evalue[1] = `elist
        `evalue[2] = `lsize
        `evalue[3] = `nsize
      ELSE:
        IF `length(`evalue[1]) == `length(`data):
          FORINCR `j(0 `length(`data)):
            IF `not(THIS.`encodeOverwriteData(`evalue[1][`j], `data[`j])):
              return FALSE
            ENDIF
            `nsize += THIS.`nsizeEvalue(`evalue[1][`j])
            `lsize += THIS.`lsizeEvalue(`evalue[1][`j])
          ENDFOR
        ELSIF `length(`evalue[1]) > `length(`data):
          FORDECR `j(`length(`evalue[1])-`length(`data)-1 0):
            `pick(`evalue[1], `length(`data))
          ENDFOR
          FORINCR `j(0 `length(`data)):
            IF `not(THIS.`encodeOverwriteData(`evalue[1][`j], `data[`j])):
              return FALSE
            ENDIF
            `nsize += THIS.`nsizeEvalue(`evalue[1][`j])
            `lsize += THIS.`lsizeEvalue(`evalue[1][`j])
          ENDFOR
        ELSE:
          FORINCR `j(0 `length(`evalue[1])):
            IF `not(THIS.`encodeOverwriteData(`evalue[1][`j], `data[`j])):
              return FALSE
            ENDIF
            `nsize += THIS.`nsizeEvalue(`evalue[1][`j])
            `lsize += THIS.`lsizeEvalue(`evalue[1][`j])
          ENDFOR
          FORINCR `j(`length(`evalue[1]) `length(`data)):
            `evalueE = THIS.`encodeData(`data[`j])
            IF `isnull(`evalueE):
              return FALSE
            ENDIF
            `push(`evalue[1], `evalueE)
            `nsize += THIS.`nsizeEvalue(`evalueE)
            `lsize += THIS.`lsizeEvalue(`evalueE)
          ENDFOR
        ENDIF
        `evalue[2] = `lsize
        `evalue[3] = `nsize
      ENDIF
      return TRUE
    ENDIF
    IF `is_type_bool(`data_type):
      IF `length(`evalue) == 0:
        `nsize = 1
        `lsize = 0
        `push(`evalue, `key_interp_number)
        `push(`evalue, `fp[0].FromFloat(`data))
        `push(`evalue, `lsize)
        `push(`evalue, `nsize)
      ELSE:
        IF `evalue[0] != `key_interp_number:
          `nsize = 1
          `lsize = 0
          `evalue[0] = `key_interp_number
          `evalue[2] = `lsize
          `evalue[3] = `nsize
        ENDIF
        `evalue[1] = `fp[0].FromFloat(`data)
      ENDIF
      return TRUE
    ENDIF
    `warning("Prequel"+" "+"Utils"+" "+"encodeOverwriteData"+":"+" "+"invalid"+" "+"data"+":", `data)
    return FALSE

  METHOD `decodeData(`edata):
    VAR `dlist
    VAR `j
    VAR `dvalue
    IF `not(`is_type_list(`get_type(`edata))) OR `length(`edata) < 2:
      `warning("Prequel"+" "+"Utils"+" "+"decodeData"+":"+" "+"invalid"+" "+"data"+":", `edata)
      return NULL
    ENDIF
    IF `edata[0] == `key_interp_number:
      return [`ARG_TYPE_NUMBER, `edata[1]]
    ENDIF
    IF `edata[0] == `key_interp_list:
      IF `not(`is_type_list(`get_type(`edata[1]))):
        `warning("Prequel"+" "+"Utils"+" "+"decodeData"+":"+" "+"invalid"+" "+"data"+":", `edata)
        return NULL
      ENDIF
      `dlist = []
      FORINCR `j(0 `length(`edata[1])):
        `dvalue = THIS.`decodeData(`edata[1][`j])
        IF `isnull(`dvalue):
          return NULL
        ENDIF
        `push(`dlist, `dvalue[1])
      ENDFOR
      return [`ARG_TYPE_LIST, `dlist]
    ENDIF
    IF `edata[0] == `key_interp_by_ref:
      IF `not(`is_type_list(`get_type(`edata[1]))) OR `length(`edata[1]) <= 1:
        `warning("Prequel"+" "+"Utils"+" "+"decodeData"+":"+" "+"invalid"+" "+"data"+":", `edata)
        return NULL
      ENDIF
      IF `not(`is_type_str(`get_type(`edata[1][0]))):
        `warning("Prequel"+" "+"Utils"+" "+"decodeData"+":"+" "+"invalid"+" "+"data"+":", `edata)
        return NULL
      ENDIF
      IF `not(`isnull(`edata[1][1])) AND `not(`is_type_str(`get_type(`edata[1][1]))):
        `warning("Prequel"+" "+"Utils"+" "+"decodeData"+":"+" "+"invalid"+" "+"data"+":", `edata)
        return NULL
      ENDIF
      `dlist = [`edata[1][0], `edata[1][1]]
      FORINCR `j(2 `length(`edata[1])):
        `push(`dlist, `trunc(`edata[1][`j]))
      ENDFOR
      return [`ARG_TYPE_VARNAME, `dlist]
    ENDIF
    IF `edata[0] == `key_interp_module_name:
      IF `not(`is_type_str(`get_type(`edata[1]))):
        `warning("Prequel"+" "+"Utils"+" "+"decodeData"+":"+" "+"invalid"+" "+"data"+":", `edata)
        return NULL
      ENDIF
      return [`ARG_TYPE_MODNAME, `edata[1]]
    ENDIF
    IF `edata[0] == `key_interp_string:
      IF `not(`is_type_str(`get_type(`edata[1]))):
        `warning("Prequel"+" "+"Utils"+" "+"decodeData"+":"+" "+"invalid"+" "+"data"+":", `edata)
        return NULL
      ENDIF
      return [`ARG_TYPE_STRING, `edata[1]]
    ENDIF
    `warning("Prequel"+" "+"Utils"+" "+"decodeData"+":"+" "+"invalid"+" "+"data"+":", `edata)
    return NULL

  METHOD `stringify(`evalue):
    VAR `lstr
    VAR `j
    IF `isnull(`evalue):
      return "<NULL>"
    ENDIF
    IF `evalue[0] == `key_interp_number:
      return `str(`fp[0].ToFloat(`evalue[1]))
    ENDIF
    IF `evalue[0] == `key_interp_list:
      IF `length(`evalue[1]) == 0:
        return "[]"
      ENDIF
      `lstr = "["
      `lstr += THIS.`stringify(`evalue[1][0])
      FORINCR `j(1 `length(`evalue[1])):
        `lstr += ","+" "+THIS.`stringify(`evalue[1][`j])
      ENDFOR
      `lstr += "]"
      return `lstr
    ENDIF
    IF `evalue[0] == `key_interp_boolean:
      return TERNARY{`evalue[1]}{"<TRUE>"}{"<FALSE>"}
    ENDIF
    IF `evalue[0] == `key_interp_procedure:
      return "<PROCEDURE>"
    ENDIF
    `warning("Prequel"+" "+"Utils"+" "+"stringify"+":"+" "+"unknown"+" "+"value"+":", `evalue)
    return "<UNKNOWN>"

ENDCLASS

VAR `utils = NEW `Utils()

VAR `key_token_AND = 1
VAR `key_token_ASSIGN_OP = 2
VAR `key_token_ASSIGN_OP_BIT_AND = 3
VAR `key_token_ASSIGN_OP_BIT_OR = 4
VAR `key_token_ASSIGN_OP_BIT_SHL = 5
VAR `key_token_ASSIGN_OP_BIT_SHR = 6
VAR `key_token_ASSIGN_OP_BIT_XOR = 7
VAR `key_token_ASSIGN_OP_DECR = 8
VAR `key_token_ASSIGN_OP_DIV = 9
VAR `key_token_ASSIGN_OP_IDV = 10
VAR `key_token_ASSIGN_OP_INCR = 11
VAR `key_token_ASSIGN_OP_MINUS = 12
VAR `key_token_ASSIGN_OP_MOD = 13
VAR `key_token_ASSIGN_OP_MUL = 14
VAR `key_token_ASSIGN_OP_PLUS = 15
VAR `key_token_ASSIGN_OP_RANDOM = 16
VAR `key_token_ASSIGN_OP_TOGGLE = 17
VAR `key_token_BINARY = 18
VAR `key_token_BIT_AND = 19
VAR `key_token_BIT_NOT = 20
VAR `key_token_BIT_OR = 21
VAR `key_token_BIT_SHL = 22
VAR `key_token_BIT_SHR = 23
VAR `key_token_BIT_XOR = 24
VAR `key_token_COMMA = 25
VAR `key_token_COMMENT = 26
VAR `key_token_CSVAR = 27
VAR `key_token_DEBUGL = 28
VAR `key_token_DECIMAL = 29
VAR `key_token_DIV = 30
VAR `key_token_ELSE = 31
VAR `key_token_ELSIF = 32
VAR `key_token_EMPTY = 33
VAR `key_token_ENDIF = 34
VAR `key_token_ENDREP = 35
VAR `key_token_EQ = 36
VAR `key_token_ERROR = 37
VAR `key_token_EVAR = 38
VAR `key_token_GE = 39
VAR `key_token_GT = 40
VAR `key_token_HEXADECIMAL = 41
VAR `key_token_IDV = 42
VAR `key_token_IF = 43
VAR `key_token_INDENT = 44
VAR `key_token_INDEXOF = 45
VAR `key_token_IS = 46
VAR `key_token_IS_NOT = 47
VAR `key_token_IVAR = 48
VAR `key_token_LE = 49
VAR `key_token_LENGTH = 50
VAR `key_token_LIST = 51
VAR `key_token_LPAR = 52
VAR `key_token_LSIZE = 53
VAR `key_token_LSQR = 54
VAR `key_token_LT = 55
VAR `key_token_MATH_ABS = 56
VAR `key_token_MATH_ACOS = 57
VAR `key_token_MATH_ASIN = 58
VAR `key_token_MATH_ATAN = 59
VAR `key_token_MATH_ATAN2 = 60
VAR `key_token_MATH_CEIL = 61
VAR `key_token_MATH_COS = 62
VAR `key_token_MATH_E = 63
VAR `key_token_MATH_EXP = 64
VAR `key_token_MATH_EXP2 = 65
VAR `key_token_MATH_FLOOR = 66
VAR `key_token_MATH_LOG = 67
VAR `key_token_MATH_LOG2 = 68
VAR `key_token_MATH_MAX = 69
VAR `key_token_MATH_MIN = 70
VAR `key_token_MATH_PI = 71
VAR `key_token_MATH_POW = 72
VAR `key_token_MATH_ROUND = 73
VAR `key_token_MATH_SIGN = 74
VAR `key_token_MATH_SIN = 75
VAR `key_token_MATH_SQRT = 76
VAR `key_token_MATH_TAN = 77
VAR `key_token_MINUS = 78
VAR `key_token_MOD = 79
VAR `key_token_MODULE_NAME = 80
VAR `key_token_MUL = 81
VAR `key_token_NE = 82
VAR `key_token_NEWLINE = 83
VAR `key_token_NOT = 84
VAR `key_token_NSIZE = 85
VAR `key_token_NUMBER = 86
VAR `key_token_OR = 87
VAR `key_token_PLUS = 88
VAR `key_token_POP = 89
VAR `key_token_POSTERROR = 90
VAR `key_token_PROCEDURE = 91
VAR `key_token_PUSH = 92
VAR `key_token_QUEUE = 93
VAR `key_token_RANDOM = 94
VAR `key_token_REPEAT = 95
VAR `key_token_REPNEXT = 96
VAR `key_token_REPSTOP = 97
VAR `key_token_RPAR = 98
VAR `key_token_RSQR = 99
VAR `key_token_SIZE = 100
VAR `key_token_SPACES = 101
VAR `key_token_STRING = 102
VAR `key_token_SUFFIX = 103
VAR `key_token_UNASSIGN = 104
VAR `key_token_UNDEFINED = 105
VAR `key_token_UNQUEUE = 106

VAR `SUFFIX_ = 0
VAR `SUFFIX_LENGTH = 1
VAR `SUFFIX_SIZE = 2
VAR `SUFFIX_NSIZE = 3
VAR `SUFFIX_LSIZE = 4
VAR `SUFFIX_PUSH = 5
VAR `SUFFIX_QUEUE = 6
VAR `SUFFIX_POP = 7
VAR `SUFFIX_UNQUEUE = 8
VAR `SUFFIX_INDEXOF = 9

CLASS `Lexer:

  METHOD_INIT():
    THIS.`_reserved_words = []
    `push(THIS.`_reserved_words, "IF")
    `push(THIS.`_reserved_words, "ELSIF")
    `push(THIS.`_reserved_words, "ELSE")
    `push(THIS.`_reserved_words, "ENDIF")
    `push(THIS.`_reserved_words, "REPEAT")
    `push(THIS.`_reserved_words, "REPSTOP")
    `push(THIS.`_reserved_words, "REPNEXT")
    `push(THIS.`_reserved_words, "ENDREP")
    `push(THIS.`_reserved_words, "DEBUGL")
    `push(THIS.`_reserved_words, "OR")
    `push(THIS.`_reserved_words, "AND")
    `push(THIS.`_reserved_words, "NOT")
    `push(THIS.`_reserved_words, "IS")
    `push(THIS.`_reserved_words, "NUMBER")
    `push(THIS.`_reserved_words, "LIST")
    `push(THIS.`_reserved_words, "EMPTY")
    `push(THIS.`_reserved_words, "PROCEDURE")
    `push(THIS.`_reserved_words, "RANDOM")
    `push(THIS.`_reserved_words, "UNDEFINED")

    THIS.`_reserved_vlast_words = []
    `push(THIS.`_reserved_vlast_words, "UNASSIGN")
    `push(THIS.`_reserved_vlast_words, "LENGTH")
    `push(THIS.`_reserved_vlast_words, "SIZE")
    `push(THIS.`_reserved_vlast_words, "NSIZE")
    `push(THIS.`_reserved_vlast_words, "LSIZE")
    `push(THIS.`_reserved_vlast_words, "PUSH")
    `push(THIS.`_reserved_vlast_words, "QUEUE")
    `push(THIS.`_reserved_vlast_words, "POP")
    `push(THIS.`_reserved_vlast_words, "UNQUEUE")
    `push(THIS.`_reserved_vlast_words, "INDEXOF")

    THIS.`_reserved_qlast_words = []
    `push(THIS.`_reserved_qlast_words, "LENGTH")
    `push(THIS.`_reserved_qlast_words, "SIZE")
    `push(THIS.`_reserved_qlast_words, "NSIZE")
    `push(THIS.`_reserved_qlast_words, "LSIZE")
    `push(THIS.`_reserved_qlast_words, "INDEXOF")

    THIS.`_token_strs = []
    `push(THIS.`_token_strs, "_"+"UNKNOWN"+"_")
    `push(THIS.`_token_strs, "AND")
    `push(THIS.`_token_strs, "ASSIGN"+"_"+"OP")
    `push(THIS.`_token_strs, "ASSIGN"+"_"+"OP"+"_"+"BIT"+"_"+"AND")
    `push(THIS.`_token_strs, "ASSIGN"+"_"+"OP"+"_"+"BIT"+"_"+"OR")
    `push(THIS.`_token_strs, "ASSIGN"+"_"+"OP"+"_"+"BIT"+"_"+"SHL")
    `push(THIS.`_token_strs, "ASSIGN"+"_"+"OP"+"_"+"BIT"+"_"+"SHR")
    `push(THIS.`_token_strs, "ASSIGN"+"_"+"OP"+"_"+"BIT"+"_"+"XOR")
    `push(THIS.`_token_strs, "ASSIGN"+"_"+"OP"+"_"+"DECR")
    `push(THIS.`_token_strs, "ASSIGN"+"_"+"OP"+"_"+"DIV")
    `push(THIS.`_token_strs, "ASSIGN"+"_"+"OP"+"_"+"IDV")
    `push(THIS.`_token_strs, "ASSIGN"+"_"+"OP"+"_"+"INCR")
    `push(THIS.`_token_strs, "ASSIGN"+"_"+"OP"+"_"+"MINUS")
    `push(THIS.`_token_strs, "ASSIGN"+"_"+"OP"+"_"+"MOD")
    `push(THIS.`_token_strs, "ASSIGN"+"_"+"OP"+"_"+"MUL")
    `push(THIS.`_token_strs, "ASSIGN"+"_"+"OP"+"_"+"PLUS")
    `push(THIS.`_token_strs, "ASSIGN"+"_"+"OP"+"_"+"RANDOM")
    `push(THIS.`_token_strs, "ASSIGN"+"_"+"OP"+"_"+"TOGGLE")
    `push(THIS.`_token_strs, "BINARY")
    `push(THIS.`_token_strs, "BIT"+"_"+"AND")
    `push(THIS.`_token_strs, "BIT"+"_"+"NOT")
    `push(THIS.`_token_strs, "BIT"+"_"+"OR")
    `push(THIS.`_token_strs, "BIT"+"_"+"SHL")
    `push(THIS.`_token_strs, "BIT"+"_"+"SHR")
    `push(THIS.`_token_strs, "BIT"+"_"+"XOR")
    `push(THIS.`_token_strs, "COMMA")
    `push(THIS.`_token_strs, "COMMENT")
    `push(THIS.`_token_strs, "CSVAR")
    `push(THIS.`_token_strs, "DEBUGL")
    `push(THIS.`_token_strs, "DECIMAL")
    `push(THIS.`_token_strs, "DIV")
    `push(THIS.`_token_strs, "ELSE")
    `push(THIS.`_token_strs, "ELSIF")
    `push(THIS.`_token_strs, "EMPTY")
    `push(THIS.`_token_strs, "ENDIF")
    `push(THIS.`_token_strs, "ENDREP")
    `push(THIS.`_token_strs, "EQ")
    `push(THIS.`_token_strs, "ERROR")
    `push(THIS.`_token_strs, "EVAR")
    `push(THIS.`_token_strs, "GE")
    `push(THIS.`_token_strs, "GT")
    `push(THIS.`_token_strs, "HEXADECIMAL")
    `push(THIS.`_token_strs, "IDV")
    `push(THIS.`_token_strs, "IF")
    `push(THIS.`_token_strs, "INDENT")
    `push(THIS.`_token_strs, "INDEXOF")
    `push(THIS.`_token_strs, "IS")
    `push(THIS.`_token_strs, "IS"+"_"+"NOT")
    `push(THIS.`_token_strs, "IVAR")
    `push(THIS.`_token_strs, "LE")
    `push(THIS.`_token_strs, "LENGTH")
    `push(THIS.`_token_strs, "LIST")
    `push(THIS.`_token_strs, "LPAR")
    `push(THIS.`_token_strs, "LSIZE")
    `push(THIS.`_token_strs, "LSQR")
    `push(THIS.`_token_strs, "LT")
    `push(THIS.`_token_strs, "MATH"+"_"+"ABS")
    `push(THIS.`_token_strs, "MATH"+"_"+"ACOS")
    `push(THIS.`_token_strs, "MATH"+"_"+"ASIN")
    `push(THIS.`_token_strs, "MATH"+"_"+"ATAN")
    `push(THIS.`_token_strs, "MATH"+"_"+"ATAN2")
    `push(THIS.`_token_strs, "MATH"+"_"+"CEIL")
    `push(THIS.`_token_strs, "MATH"+"_"+"COS")
    `push(THIS.`_token_strs, "MATH"+"_"+"E")
    `push(THIS.`_token_strs, "MATH"+"_"+"EXP")
    `push(THIS.`_token_strs, "MATH"+"_"+"EXP2")
    `push(THIS.`_token_strs, "MATH"+"_"+"FLOOR")
    `push(THIS.`_token_strs, "MATH"+"_"+"LOG")
    `push(THIS.`_token_strs, "MATH"+"_"+"LOG2")
    `push(THIS.`_token_strs, "MATH"+"_"+"MAX")
    `push(THIS.`_token_strs, "MATH"+"_"+"MIN")
    `push(THIS.`_token_strs, "MATH"+"_"+"PI")
    `push(THIS.`_token_strs, "MATH"+"_"+"POW")
    `push(THIS.`_token_strs, "MATH"+"_"+"ROUND")
    `push(THIS.`_token_strs, "MATH"+"_"+"SIGN")
    `push(THIS.`_token_strs, "MATH"+"_"+"SIN")
    `push(THIS.`_token_strs, "MATH"+"_"+"SQRT")
    `push(THIS.`_token_strs, "MATH"+"_"+"TAN")
    `push(THIS.`_token_strs, "MINUS")
    `push(THIS.`_token_strs, "MOD")
    `push(THIS.`_token_strs, "MODULE"+"_"+"NAME")
    `push(THIS.`_token_strs, "MUL")
    `push(THIS.`_token_strs, "NE")
    `push(THIS.`_token_strs, "NEWLINE")
    `push(THIS.`_token_strs, "NOT")
    `push(THIS.`_token_strs, "NSIZE")
    `push(THIS.`_token_strs, "NUMBER")
    `push(THIS.`_token_strs, "OR")
    `push(THIS.`_token_strs, "PLUS")
    `push(THIS.`_token_strs, "POP")
    `push(THIS.`_token_strs, "POSTERROR")
    `push(THIS.`_token_strs, "PROCEDURE")
    `push(THIS.`_token_strs, "PUSH")
    `push(THIS.`_token_strs, "QUEUE")
    `push(THIS.`_token_strs, "RANDOM")
    `push(THIS.`_token_strs, "REPEAT")
    `push(THIS.`_token_strs, "REPNEXT")
    `push(THIS.`_token_strs, "REPSTOP")
    `push(THIS.`_token_strs, "RPAR")
    `push(THIS.`_token_strs, "RSQR")
    `push(THIS.`_token_strs, "SIZE")
    `push(THIS.`_token_strs, "SPACES")
    `push(THIS.`_token_strs, "STRING")
    `push(THIS.`_token_strs, "SUFFIX")
    `push(THIS.`_token_strs, "UNASSIGN")
    `push(THIS.`_token_strs, "UNDEFINED")
    `push(THIS.`_token_strs, "UNQUEUE")

  METHOD `tokenStringToId(`token_str):
    return `indexof(THIS.`_token_strs, `token_str)

  METHOD `tokenIdToString(`token_id):
    IF (`token_id <= 0) OR (`token_id >= `length(THIS.`_token_strs)):
      `warning("Prequel"+" "+"Lexer"+" "+"tokenIdToString"+":"+" "+"unknown"+" "+"id"+":", `token_id)
      `token_id = 0
    ENDIF
    VAR `token_str = THIS.`_token_strs[`token_id]
    return `token_str

  METHOD `isCompoundToken(`token_str):
    return (`indexof(THIS.`_reserved_vlast_words, `token_str) >= 0)

  METHOD `isModuleNameCharStart(`c):
    return (((`c >= "a") AND (`c <= "z")) OR ((`c >= "A") AND (`c <= "Z")) OR (`c == "_"))

  METHOD `isModuleNameChar(`c):
    return (((`c >= "0") AND (`c <= "9")) OR ((`c >= "a") AND (`c <= "z")) OR ((`c >= "A") AND (`c <= "Z")) OR (`c == "_"))

  METHOD `isValidModuleName(`module_name):
    VAR `j
    IF `not(`is_type_str(`get_type(`module_name))):
      return FALSE
    ENDIF
    IF `length(`module_name) == 0:
      return FALSE
    ENDIF
    IF `not(THIS.`isModuleNameCharStart(`module_name[0])):
      return FALSE
    ENDIF
    FORINCR `j(1 `length(`module_name)):
      IF `not(THIS.`isModuleNameChar(`module_name[`j])):
        return FALSE
      ENDIF
    ENDFOR
    return TRUE

  METHOD `isValidSourceCode(`source_code):
    VAR `j
    VAR `chrcode_j
    IF `not(`is_type_str(`get_type(`source_code))):
      return FALSE
    ENDIF
    FORINCR `j(0 `length(`source_code)):
      `chrcode_j = `char_code_at(`source_code, `j)
      IF `chrcode_j != 9 AND `chrcode_j != 10 AND `chrcode_j != 13 AND (`chrcode_j < 32 OR `chrcode_j > 126):
        return FALSE
      ENDIF
    ENDFOR
    return TRUE

  METHOD `normalize(`source_code):
    VAR `splits
    VAR `j
    `splits = `split(`source_code, `chr_tab)
    `source_code = `splits[0]
    FORINCR `j(1 `length(`splits)):
      `source_code += " "+`splits[`j]
    ENDFOR
    `splits = `split(`source_code, `chr_cr)
    `source_code = `splits[0]
    FORINCR `j(1 `length(`splits)):
      `source_code += `splits[`j]
    ENDFOR
    return `source_code

  METHOD `tokenId(`token):
    return `token[0]

  METHOD `tokenColumn(`token):
    return `token[1]

  METHOD `tokenValue(`token):
    return `token[2]

  METHOD `tokenExtra(`token):
    IF `length(`token) <= 3:
      return NULL
    ENDIF
    return `token[3]

  METHOD `memberOf(`s `i `e `l):
    VAR `len_
    VAR `isEq
    VAR `j
    VAR `j2
    `len_ = `e-`i
    FORINCR `j(0 `length(`l)):
      IF `length(`l[`j]) != `len_:
        continue
      ENDIF
      `isEq = TRUE
      FORINCR `j2(0 `len_):
        IF `s[`i+`j2] != `l[`j][`j2]:
          `isEq = FALSE
          break
        ENDIF
      ENDFOR
      IF `isEq:
        return TRUE
      ENDIF
    ENDFOR
    return FALSE

  METHOD `isValidVarname(`varname):
    IF `not(`is_type_str(`get_type(`varname))):
      return FALSE
    ENDIF
    IF `length(`varname) == 0:
      return FALSE
    ENDIF
    `varname = `uppercase(`varname)
    IF ((`varname[0] < "A") OR (`varname[0] > "Z")) AND (`varname[0] != "_"):
      return FALSE
    ENDIF
    VAR `dotCount
    VAR `lastDotIdx
    VAR `startIdx
    VAR `j
    `dotCount = 0
    FORINCR `j(1 `length(`varname)):
      IF `varname[`j] == ".":
        `startIdx = TERNARY{`dotCount == 0}{0}{`lastDotIdx+1}
        IF `j-`startIdx == 0:
          return FALSE
        ENDIF
        IF `varname[`startIdx] >= "0" AND `varname[`startIdx] <= "9":
          return FALSE
        ENDIF
        `dotCount += 1
        `lastDotIdx = `j
        continue
      ENDIF
      IF ((`varname[`j] >= "0") AND (`varname[`j] <= "9")) OR ((`varname[`j] >= "A") AND (`varname[`j] <= "Z")) OR (`varname[`j] == "_"):
        continue
      ENDIF
      return FALSE
    ENDFOR
    IF `dotCount == 0:
      return FALSE
    ENDIF
    `startIdx = `lastDotIdx+1
    IF `length(`varname)-`startIdx == 0:
      return FALSE
    ENDIF
    IF `varname[`startIdx] >= "0" AND `varname[`startIdx] <= "9":
      return FALSE
    ENDIF
    IF THIS.`memberOf(`varname, `startIdx, `length(`varname), THIS.`_reserved_vlast_words):
      return FALSE
    ENDIF
    return TRUE

  METHOD `isValidIvarname(`ivarname):
    IF `not(`is_type_str(`get_type(`ivarname))):
      return FALSE
    ENDIF
    IF `length(`ivarname) == 0:
      return FALSE
    ENDIF
    `ivarname = `uppercase(`ivarname)
    IF ((`ivarname[0] < "A") OR (`ivarname[0] > "Z")) AND (`ivarname[0] != "_"):
      return FALSE
    ENDIF
    VAR `j
    FORINCR `j(1 `length(`ivarname)):
      IF ((`ivarname[`j] >= "0") AND (`ivarname[`j] <= "9")) OR ((`ivarname[`j] >= "A") AND (`ivarname[`j] <= "Z")) OR (`ivarname[`j] == "_"):
        continue
      ENDIF
      return FALSE
    ENDFOR
    IF THIS.`memberOf(`ivarname, 0, `length(`ivarname), THIS.`_reserved_words):
      return FALSE
    ENDIF
    IF THIS.`memberOf(`ivarname, 0, `length(`ivarname), THIS.`_reserved_vlast_words):
      return FALSE
    ENDIF
    return TRUE

  METHOD `isVarChar(`c):
    return (((`c >= "0") AND (`c <= "9")) OR ((`c >= "a") AND (`c <= "z")) OR ((`c >= "A") AND (`c <= "Z")) OR (`c == "_") OR (`c == "."))

  METHOD `isTokenEndSpace(`l `start `token):
    VAR `j
    FORINCR `j(1 `length(`token)):
      IF `uppercase(`l[`start+`j]) != `token[`j]:
        return FALSE
      ENDIF
    ENDFOR
    return (`l[`start+`length(`token)] == " ")

  METHOD `isTokenEndOther(`l `start `token):
    VAR `j
    FORINCR `j(1 `length(`token)):
      IF `uppercase(`l[`start+`j]) != `token[`j]:
        return FALSE
      ENDIF
    ENDFOR
    return `not(THIS.`isVarChar(`l[`start+`length(`token)]))

  METHOD `lexLine(`line):
    `line += " "+`chr_lf
    VAR `ic
    VAR `tname
    VAR `tlen
    VAR `textra
    VAR `col = 0
    VAR `start
    WHILE `line[`col] == " ":
      `col += 1
    ENDWHILE
    IF `line[`col] == `chr_lf:
      return [[`key_token_INDENT, 0, `substring(`line, 0, `col-1)], [`key_token_NEWLINE, `length(`line)-2, `chr_lf]]
    ENDIF
    VAR `tokens = []
    VAR `nonzero
    VAR `j
    VAR `subtextras
    VAR `error_msg
    VAR `literal
    VAR `var_op
    VAR `indexof_csvar
    VAR `token
    `push(`tokens, [`key_token_INDENT, 0, `substring(`line, 0, `col)])
    WHILE TRUE:
      IF `line[`col] == " ":
        `start = `col
        WHILE `line[`col] == " ":
          `col += 1
        ENDWHILE
        IF `line[`col] == `chr_lf:
          IF `col-`start == 1:
            break
          ENDIF
          `push(`tokens, [`key_token_SPACES, `start, `substring(`line, `start, `col-1)])
          break
        ENDIF
        `push(`tokens, [`key_token_SPACES, `start, `substring(`line, `start, `col)])
      ENDIF
      `ic = `uppercase(`line[`col])
      IF `ic == "I":
        `tname = "IF"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_IF, `col, `substring(`line, `col, `col+`tlen)])
          `col += `tlen
          continue
        ENDIF
        `tname = "IS"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `tname = "NOT"
          IF (`uppercase(`line[`col+3]) == "N") AND THIS.`isTokenEndSpace(`line, `col+3, `tname):
            `tname = "IS_NOT"
            `tlen = `length(`tname)
            `push(`tokens, [`key_token_IS_NOT, `col, `substring(`line, `col, `col+`tlen)])
            `col += `tlen
            continue
          ENDIF
          `tname = "IS"
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_IS, `col, `substring(`line, `col, `col+`tlen)])
          `col += `tlen
          continue
        ENDIF
      ENDIF
      IF `ic == "R":
        `tname = "REPEAT"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_REPEAT, `col, `substring(`line, `col, `col+`tlen)])
          `col += `tlen
          continue
        ENDIF
        `tname = "REPNEXT"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_REPNEXT, `col, `substring(`line, `col, `col+`tlen)])
          `col += `tlen
          continue
        ENDIF
        `tname = "REPSTOP"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_REPSTOP, `col, `substring(`line, `col, `col+`tlen)])
          `col += `tlen
          continue
        ENDIF
        `tname = "RANDOM"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_RANDOM, `col, `substring(`line, `col, `col+`tlen)])
          `col += `tlen
          continue
        ENDIF
        `tname = "RETURN"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_EVAR, `col, `substring(`line, `col, `col+`tlen), `tname])
          `col += `tlen
          continue
        ENDIF
      ENDIF
      IF `ic == "L":
        `tname = "LIST"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_LIST, `col, `substring(`line, `col, `col+`tlen)])
          `col += `tlen
          continue
        ENDIF
      ENDIF
      IF `ic == "A":
        `tname = "AND"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_AND, `col, `substring(`line, `col, `col+`tlen)])
          `col += `tlen
          continue
        ENDIF
      ENDIF
      IF `ic == "P":
        `tname = "PROCEDURE"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_PROCEDURE, `col, `substring(`line, `col, `col+`tlen)])
          `col += `tlen
          continue
        ENDIF
      ENDIF
      IF `ic == "E":
        `tname = "ENDIF"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_ENDIF, `col, `substring(`line, `col, `col+`tlen)])
          `col += `tlen
          continue
        ENDIF
        `tname = "ENDREP"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_ENDREP, `col, `substring(`line, `col, `col+`tlen)])
          `col += `tlen
          continue
        ENDIF
        `tname = "ELSE"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_ELSE, `col, `substring(`line, `col, `col+`tlen)])
          `col += `tlen
          continue
        ENDIF
        `tname = "ELSIF"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_ELSIF, `col, `substring(`line, `col, `col+`tlen)])
          `col += `tlen
          continue
        ENDIF
        `tname = "EMPTY"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_EMPTY, `col, `substring(`line, `col, `col+`tlen)])
          `col += `tlen
          continue
        ENDIF
      ENDIF
      IF `ic == "N":
        `tname = "NOT"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_NOT, `col, `substring(`line, `col, `col+`tlen)])
          `col += `tlen
          continue
        ENDIF
        `tname = "NUMBER"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_NUMBER, `col, `substring(`line, `col, `col+`tlen)])
          `col += `tlen
          continue
        ENDIF
      ENDIF
      IF `ic == "O":
        `tname = "OR"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_OR, `col, `substring(`line, `col, `col+`tlen)])
          `col += `tlen
          continue
        ENDIF
      ENDIF
      IF `ic == "U":
        `tname = "UNDEFINED"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_UNDEFINED, `col, `substring(`line, `col, `col+`tlen)])
          `col += `tlen
          continue
        ENDIF
      ENDIF
      IF `line[`col] == ":":
        IF `line[`col+1] == "=":
          `push(`tokens, [`key_token_ASSIGN_OP, `col, ":="])
          `col += 2
          continue
        ENDIF
        IF `line[`col+1] == "~":
          `push(`tokens, [`key_token_ASSIGN_OP_RANDOM, `col, ":~"])
          `col += 2
          continue
        ENDIF
      ENDIF
      IF `line[`col] == "+":
        IF `line[`col+1] == "+":
          `push(`tokens, [`key_token_ASSIGN_OP_INCR, `col, "++"])
          `col += 2
          continue
        ENDIF
        IF `line[`col+1] == "=":
          `push(`tokens, [`key_token_ASSIGN_OP_PLUS, `col, "+="])
          `col += 2
          continue
        ENDIF
        `push(`tokens, [`key_token_PLUS, `col, "+"])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "-":
        IF `line[`col+1] == "-":
          `push(`tokens, [`key_token_ASSIGN_OP_DECR, `col, "--"])
          `col += 2
          continue
        ENDIF
        IF `line[`col+1] == "=":
          `push(`tokens, [`key_token_ASSIGN_OP_MINUS, `col, "-="])
          `col += 2
          continue
        ENDIF
        `push(`tokens, [`key_token_MINUS, `col, "-"])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "*":
        IF `line[`col+1] == "=":
          `push(`tokens, [`key_token_ASSIGN_OP_MUL, `col, "*="])
          `col += 2
          continue
        ENDIF
        `push(`tokens, [`key_token_MUL, `col, "*"])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "/":
        IF `line[`col+1] == "=":
          `push(`tokens, [`key_token_ASSIGN_OP_DIV, `col, "/="])
          `col += 2
          continue
        ELSIF `line[`col+1] == "/":
          IF `line[`col+2] == "=":
            `push(`tokens, [`key_token_ASSIGN_OP_IDV, `col, "//="])
            `col += 3
            continue
          ENDIF
          `push(`tokens, [`key_token_IDV, `col, "//"])
          `col += 2
          continue
        ENDIF
        `push(`tokens, [`key_token_DIV, `col, "/"])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "%":
        IF `line[`col+1] == "=":
          `push(`tokens, [`key_token_ASSIGN_OP_MOD, `col, "%="])
          `col += 2
          continue
        ENDIF
        `push(`tokens, [`key_token_MOD, `col, "%"])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "&":
        IF `line[`col+1] == "=":
          `push(`tokens, [`key_token_ASSIGN_OP_BIT_AND, `col, "&="])
          `col += 2
          continue
        ENDIF
        `push(`tokens, [`key_token_BIT_AND, `col, "&"])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "^":
        IF `line[`col+1] == "=":
          `push(`tokens, [`key_token_ASSIGN_OP_BIT_XOR, `col, "^="])
          `col += 2
          continue
        ENDIF
        `push(`tokens, [`key_token_BIT_XOR, `col, "^"])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "|":
        IF `line[`col+1] == "=":
          `push(`tokens, [`key_token_ASSIGN_OP_BIT_OR, `col, "|="])
          `col += 2
          continue
        ENDIF
        `push(`tokens, [`key_token_BIT_OR, `col, "|"])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "~":
        IF `line[`col+1] == "~":
          `push(`tokens, [`key_token_ASSIGN_OP_TOGGLE, `col, "~~"])
          `col += 2
          continue
        ENDIF
        `push(`tokens, [`key_token_BIT_NOT, `col, "~"])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "(":
        `push(`tokens, [`key_token_LPAR, `col, "("])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == ")":
        `push(`tokens, [`key_token_RPAR, `col, ")"])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "[":
        `push(`tokens, [`key_token_LSQR, `col, "["])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "]":
        `push(`tokens, [`key_token_RSQR, `col, "]"])
        `col += 1
        IF `line[`col] == ".":
          `start = `col
          `col += 1
          WHILE ((`line[`col] >= "A") AND (`line[`col] <= "Z")) OR ((`line[`col] >= "a") AND (`line[`col] <= "z")):
            `col += 1
          ENDWHILE
          `textra = `uppercase(`substring(`line, `start+1, `col))
          IF `indexof(THIS.`_reserved_vlast_words, `textra) < 0:
            `push(`tokens, [`key_token_ERROR, `start, `substring(`line, `start, `col), "UNEXPECTED"+" "+"SUFFIX"])
            `start = `col
            WHILE `line[`col] != `chr_lf:
              `col += 1
            ENDWHILE
            `push(`tokens, [`key_token_POSTERROR, `start, `substring(`line, `start, `col-1)])
            break
          ENDIF
          `push(`tokens, [`key_token_SUFFIX, `start, `substring(`line, `start, `col), `textra])
          continue
        ENDIF
        continue
      ENDIF
      IF `line[`col] == ",":
        `push(`tokens, [`key_token_COMMA, `col, ","])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "=":
        `push(`tokens, [`key_token_EQ, `col, "="])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "<":
        IF `line[`col+1] == ">":
          `push(`tokens, [`key_token_NE, `col, "<>"])
          `col += 2
          continue
        ENDIF
        IF `line[`col+1] == "=":
          `push(`tokens, [`key_token_LE, `col, "<="])
          `col += 2
          continue
        ENDIF
        IF `line[`col+1] == "<":
          IF `line[`col+2] == "=":
            `push(`tokens, [`key_token_ASSIGN_OP_BIT_SHL, `col, "<<="])
            `col += 3
            continue
          ENDIF
          `push(`tokens, [`key_token_BIT_SHL, `col, "<<"])
          `col += 2
          continue
        ENDIF
        `push(`tokens, [`key_token_LT, `col, "<"])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == ">":
        IF `line[`col+1] == "=":
          `push(`tokens, [`key_token_GE, `col, ">="])
          `col += 2
          continue
        ENDIF
        IF `line[`col+1] == ">":
          IF `line[`col+2] == "=":
            `push(`tokens, [`key_token_ASSIGN_OP_BIT_SHR, `col, ">>="])
            `col += 3
            continue
          ENDIF
          `push(`tokens, [`key_token_BIT_SHR, `col, ">>"])
          `col += 2
          continue
        ENDIF
        `push(`tokens, [`key_token_GT, `col, ">"])
        `col += 1
        continue
      ENDIF
      IF `line[`col] == "!":
        `start = `col
        `col += 1
        IF ((`line[`col] < "a") OR (`line[`col] > "z")) AND ((`line[`col] < "A") OR (`line[`col] > "Z")) AND (`line[`col] != "_"):
          `push(`tokens, [`key_token_ERROR, `start, `substring(`line, `start, `col), "EXPECTED"+" "+"VARIABLE"+" "+"NAME"+" "+"AFTER"+" "+"CALLSTACK"+"-"+"VARIABLE"+" "+"OPERATOR"])
          `start = `col
          WHILE `line[`col] != `chr_lf:
            `col += 1
          ENDWHILE
          `push(`tokens, [`key_token_POSTERROR, `start, `substring(`line, `start, `col-1)])
          break
        ENDIF
        `col += 1
        WHILE ((`line[`col] >= "0") AND (`line[`col] <= "9")) OR ((`line[`col] >= "a") AND (`line[`col] <= "z")) OR ((`line[`col] >= "A") AND (`line[`col] <= "Z")) OR (`line[`col] == "_"):
          `col += 1
        ENDWHILE
        `textra = `substring(`line, `start+1, `col)
        `error_msg = NULL
        `textra = `uppercase(`textra)
        IF `indexof(THIS.`_reserved_words, `textra) >= 0:
          `error_msg = "RESERVED"+" "+"WORD"
        ELSIF `indexof(THIS.`_reserved_vlast_words, `textra) >= 0:
          `error_msg = "RESERVED"+" "+"WORD"
        ENDIF
        IF `not(`isnull(`error_msg)):
          `push(`tokens, [`key_token_ERROR, `start, `substring(`line, `start, `col), `error_msg])
          `start = `col
          WHILE `line[`col] != `chr_lf:
            `col += 1
          ENDWHILE
          `push(`tokens, [`key_token_POSTERROR, `start, `substring(`line, `start, `col-1)])
          break
        ENDIF
        IF `line[`col] == "@":
          `indexof_csvar = `col
          `col += 1
          IF `not(THIS.`isModuleNameCharStart(`line[`col])):
            `textra = `lowercase(`textra)
            `push(`tokens, [`key_token_CSVAR, `start, `substring(`line, `start, `col-1), `textra])
            `start = `col-1
            `push(`tokens, [`key_token_ERROR, `start, `substring(`line, `start, `col), "MISSING"+" "+"MODULE"+" "+"NAME"])
            `start = `col
            WHILE `line[`col] != `chr_lf:
              `col += 1
            ENDWHILE
            `push(`tokens, [`key_token_POSTERROR, `start, `substring(`line, `start, `col-1)])
            break
          ENDIF
          `col += 1
          WHILE THIS.`isModuleNameChar(`line[`col]):
            `col += 1
          ENDWHILE
          `textra = `lowercase(`substring(`line, `start+1, `indexof_csvar))+"@"+`uppercase(`substring(`line, `indexof_csvar+1, `col))
        ELSE:
          `textra = `lowercase(`substring(`line, `start+1, `col))
        ENDIF
        `push(`tokens, [`key_token_CSVAR, `start, `substring(`line, `start, `col), `textra])
        IF `line[`col] == ".":
          `start = `col
          `col += 1
          WHILE ((`line[`col] >= "A") AND (`line[`col] <= "Z")) OR ((`line[`col] >= "a") AND (`line[`col] <= "z")):
            `col += 1
          ENDWHILE
          `textra = `uppercase(`substring(`line, `start+1, `col))
          IF `indexof(THIS.`_reserved_vlast_words, `textra) < 0:
            `push(`tokens, [`key_token_ERROR, `start, `substring(`line, `start, `col), "UNEXPECTED"+" "+"SUFFIX"])
            `start = `col
            WHILE `line[`col] != `chr_lf:
              `col += 1
            ENDWHILE
            `push(`tokens, [`key_token_POSTERROR, `start, `substring(`line, `start, `col-1)])
            break
          ENDIF
          COMMENT IF (`textra != "UNASSIGN") AND (`textra != "LENGTH") AND (`textra != "SIZE") AND (`textra != "NSIZE") AND (`textra != "LSIZE") AND (`textra != "INDEXOF") AND (`textra != "POP") AND (`textra != "UNQUEUE") AND (`textra != "PUSH") AND (`textra != "QUEUE"):
          COMMENT   `push(`tokens, [`key_token_SUFFIX, `start, `substring(`line, `start, `col), `textra])
          COMMENT   continue
          COMMENT ENDIF
          `var_op = `textra
          `token = `pop(`tokens)
          `start = `token[1]
          `textra = "!"+`token[3]
          `var_op = `indexof(THIS.`_token_strs, `var_op)
          `push(`tokens, [`var_op, `start, `substring(`line, `start, `col), `textra])
          continue
        ENDIF
        continue
      ENDIF
      IF `line[`col] == "@":
        `start = `col
        `col += 1
        IF THIS.`isModuleNameCharStart(`line[`col]):
          `col += 1
          WHILE THIS.`isModuleNameChar(`line[`col]):
            `col += 1
          ENDWHILE
        ENDIF
        IF `start+1 == `col:
          `push(`tokens, [`key_token_ERROR, `start, `substring(`line, `start, `col), "MISSING"+" "+"MODULE"+" "+"NAME"])
          `start = `col
          WHILE `line[`col] != `chr_lf:
            `col += 1
          ENDWHILE
          `push(`tokens, [`key_token_POSTERROR, `start, `substring(`line, `start, `col-1)])
          break
        ENDIF
        `textra = `uppercase(`substring(`line, `start+1, `col))
        `push(`tokens, [`key_token_MODULE_NAME, `start, `substring(`line, `start, `col), `textra])
        continue
      ENDIF
      IF `line[`col] == `chr_quote:
        `start = `col
        `col += 1
        `textra = ""
        WHILE TRUE:
          IF `line[`col] == `chr_quote:
            `col += 1
            break
          ENDIF
          IF `line[`col] == `chr_lf:
            `textra = NULL
            `push(`tokens, [`key_token_ERROR, `start, `substring(`line, `start, `col-1), "UNEXPECTED"+" "+"END"+" "+"OF"+" "+"STRING"])
            `push(`tokens, [`key_token_POSTERROR, `col-1, ""])
            break
          ENDIF
          IF `line[`col] != "\\":
            `textra += `line[`col]
            `col += 1
            continue
          ENDIF
          `col += 1
          IF `lowercase(`line[`col]) == "n":
            `textra += `chr_lf
            `col += 1
            continue
          ENDIF
          IF `line[`col] == "\\":
            `textra += "\\"
            `col += 1
            continue
          ENDIF
          IF `line[`col] == `chr_quote:
            `textra += `chr_quote
            `col += 1
            continue
          ENDIF
          `textra = NULL
          `push(`tokens, [`key_token_ERROR, `start, `substring(`line, `start, `col), "STRING"+" "+"ESCAPE"+" "+"NOT"+" "+"ALLOWED"])
          `start = `col
          WHILE `line[`col] != `chr_lf:
            `col += 1
          ENDWHILE
          `push(`tokens, [`key_token_POSTERROR, `start, `substring(`line, `start, `col-1)])
          break
        ENDWHILE
        IF `isnull(`textra):
          break
        ENDIF
        `push(`tokens, [`key_token_STRING, `start, `substring(`line, `start, `col), `textra])
        continue
      ENDIF
      IF `line[`col] == "#":
        `start = `col
        `col += 1
        WHILE `line[`col] != `chr_lf:
          `col += 1
        ENDWHILE
        `push(`tokens, [`key_token_COMMENT, `start, `substring(`line, `start, `col-1)])
        break
      ENDIF
      IF (`line[`col] == "0") AND (`lowercase(`line[`col+1]) == "x") AND (((`line[`col+2] >= "0") AND (`line[`col+2] <= "9")) OR ((`line[`col+2] >= "a") AND (`line[`col+2] <= "f")) OR ((`line[`col+2] >= "A") AND (`line[`col+2] <= "F"))):
        `start = `col
        `col += 3
        WHILE ((`line[`col] >= "0") AND (`line[`col] <= "9")) OR ((`line[`col] >= "a") AND (`line[`col] <= "f")) OR ((`line[`col] >= "A") AND (`line[`col] <= "F")):
          `col += 1
        ENDWHILE
        IF `col-`start > 6:
          `push(`tokens, [`key_token_ERROR, `start, `substring(`line, `start, `col), "HEXADECIMAL"+" "+"NUMBER"+" "+"EXCEEDS"+" "+"SIGNED"+" "+"16"+" "+"BITS"])
          `start = `col
          WHILE `line[`col] != `chr_lf:
            `col += 1
          ENDWHILE
          `push(`tokens, [`key_token_POSTERROR, `start, `substring(`line, `start, `col-1)])
          break
        ENDIF
        IF (`line[`col] == ".") AND (((`line[`col+1] >= "0") AND (`line[`col+1] <= "9")) OR ((`line[`col+1] >= "a") AND (`line[`col+1] <= "f")) OR ((`line[`col+1] >= "A") AND (`line[`col+1] <= "F"))):
          `col += 2
          WHILE ((`line[`col] >= "0") AND (`line[`col] <= "9")) OR ((`line[`col] >= "a") AND (`line[`col] <= "f")) OR ((`line[`col] >= "A") AND (`line[`col] <= "F")):
            `col += 1
          ENDWHILE
        ENDIF
        `literal = `split(`substring(`line, `start, `col), ".")
        `literal[0] = `parse_int(`substring(`literal[0], 2, `length(`literal[0])), 16)
        IF `length(`literal) > 1:
          `literal[1] = `substring(`literal[1], 0, 4)
          WHILE `length(`literal[1]) < 4:
            `literal[1] += "0"
          ENDWHILE
          `literal[0] += `parse_int(`literal[1], 16)/65536.0
        ENDIF
        `push(`tokens, [`key_token_HEXADECIMAL, `start, `substring(`line, `start, `col), `fp[0].FromFloat(`literal[0])])
        continue
      ENDIF
      IF (`line[`col] == "0") AND (`lowercase(`line[`col+1]) == "b") AND (`line[`col+2] >= "0") AND (`line[`col+2] <= "1"):
        `start = `col
        `col += 3
        WHILE (`line[`col] >= "0") AND (`line[`col] <= "1"):
          `col += 1
        ENDWHILE
        IF `col-`start > 18:
          `push(`tokens, [`key_token_ERROR, `start, `substring(`line, `start, `col), "BINARY"+" "+"NUMBER"+" "+"EXCEEDS"+" "+"SIGNED"+" "+"16"+" "+"BITS"])
          `start = `col
          WHILE `line[`col] != `chr_lf:
            `col += 1
          ENDWHILE
          `push(`tokens, [`key_token_POSTERROR, `start, `substring(`line, `start, `col-1)])
          break
        ENDIF
        IF (`line[`col] == ".") AND (`line[`col+1] >= "0") AND (`line[`col+1] <= "1"):
          `col += 2
          WHILE (`line[`col] >= "0") AND (`line[`col] <= "1"):
            `col += 1
          ENDWHILE
        ENDIF
        `literal = `split(`substring(`line, `start, `col), ".")
        `literal[0] = `parse_int(`substring(`literal[0], 2, `length(`literal[0])), 2)
        IF `length(`literal) > 1:
          `literal[1] = `substring(`literal[1], 0, 16)
          WHILE `length(`literal[1]) < 16:
            `literal[1] += "0"
          ENDWHILE
          `literal[0] += `parse_int(`literal[1], 2)/65536.0
        ENDIF
        `push(`tokens, [`key_token_BINARY, `start, `substring(`line, `start, `col), `fp[0].FromFloat(`literal[0])])
        continue
      ENDIF
      IF (`line[`col] >= "0") AND (`line[`col] <= "9"):
        `start = `col
        `col += 1
        WHILE (`line[`col] >= "0") AND (`line[`col] <= "9"):
          `col += 1
        ENDWHILE
        `nonzero = `col
        FORINCR `j(`start `col):
          IF `line[`j] == "0":
            continue
          ENDIF
          `nonzero = `j
          break
        ENDFOR
        IF (`col-`nonzero > 5) OR (`parse_int(`substring(`line, `start, `col), 10) > 0xffff):
          `push(`tokens, [`key_token_ERROR, `start, `substring(`line, `start, `col), "NUMBER"+" "+"EXCEEDS"+" "+"SIGNED"+" "+"16"+" "+"BITS"])
          `start = `col
          WHILE `line[`col] != `chr_lf:
            `col += 1
          ENDWHILE
          `push(`tokens, [`key_token_POSTERROR, `start, `substring(`line, `start, `col-1)])
          break
        ENDIF
        IF (`line[`col] == ".") AND (`line[`col+1] >= "0") AND (`line[`col+1] <= "9"):
          `col += 2
          WHILE (`line[`col] >= "0") AND (`line[`col] <= "9"):
            `col += 1
          ENDWHILE
        ENDIF
        `literal = `parse_float(`substring(`line, `start, `col))
        `push(`tokens, [`key_token_DECIMAL, `start, `substring(`line, `start, `col), `fp[0].FromFloat(`literal)])
        continue
      ENDIF
      IF `ic == "C":
        `tname = "CALL"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_EVAR, `col, `substring(`line, `col, `col+`tlen), `tname])
          `col += `tlen
          continue
        ENDIF
      ENDIF
      IF `ic == "M":
        `tname = "MATH"+"."+"ABS"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_MATH_ABS, `col, `substring(`line, `col, `col+`tlen), `tname])
          `col += `tlen
          continue
        ENDIF
        `tname = "MATH"+"."+"ACOS"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_MATH_ACOS, `col, `substring(`line, `col, `col+`tlen), `tname])
          `col += `tlen
          continue
        ENDIF
        `tname = "MATH"+"."+"ASIN"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_MATH_ASIN, `col, `substring(`line, `col, `col+`tlen), `tname])
          `col += `tlen
          continue
        ENDIF
        `tname = "MATH"+"."+"ATAN"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_MATH_ATAN, `col, `substring(`line, `col, `col+`tlen), `tname])
          `col += `tlen
          continue
        ENDIF
        `tname = "MATH"+"."+"ATAN2"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_MATH_ATAN2, `col, `substring(`line, `col, `col+`tlen), `tname])
          `col += `tlen
          continue
        ENDIF
        `tname = "MATH"+"."+"CEIL"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_MATH_CEIL, `col, `substring(`line, `col, `col+`tlen), `tname])
          `col += `tlen
          continue
        ENDIF
        `tname = "MATH"+"."+"COS"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_MATH_COS, `col, `substring(`line, `col, `col+`tlen), `tname])
          `col += `tlen
          continue
        ENDIF
        `tname = "MATH"+"."+"E"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_MATH_E, `col, `substring(`line, `col, `col+`tlen), `tname])
          `col += `tlen
          continue
        ENDIF
        `tname = "MATH"+"."+"EXP"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_MATH_EXP, `col, `substring(`line, `col, `col+`tlen), `tname])
          `col += `tlen
          continue
        ENDIF
        `tname = "MATH"+"."+"EXP2"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_MATH_EXP2, `col, `substring(`line, `col, `col+`tlen), `tname])
          `col += `tlen
          continue
        ENDIF
        `tname = "MATH"+"."+"FLOOR"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_MATH_FLOOR, `col, `substring(`line, `col, `col+`tlen), `tname])
          `col += `tlen
          continue
        ENDIF
        `tname = "MATH"+"."+"LOG"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_MATH_LOG, `col, `substring(`line, `col, `col+`tlen), `tname])
          `col += `tlen
          continue
        ENDIF
        `tname = "MATH"+"."+"LOG2"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_MATH_LOG2, `col, `substring(`line, `col, `col+`tlen), `tname])
          `col += `tlen
          continue
        ENDIF
        `tname = "MATH"+"."+"MAX"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_MATH_MAX, `col, `substring(`line, `col, `col+`tlen), `tname])
          `col += `tlen
          continue
        ENDIF
        `tname = "MATH"+"."+"MIN"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_MATH_MIN, `col, `substring(`line, `col, `col+`tlen), `tname])
          `col += `tlen
          continue
        ENDIF
        `tname = "MATH"+"."+"PI"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_MATH_PI, `col, `substring(`line, `col, `col+`tlen), `tname])
          `col += `tlen
          continue
        ENDIF
        `tname = "MATH"+"."+"POW"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_MATH_POW, `col, `substring(`line, `col, `col+`tlen), `tname])
          `col += `tlen
          continue
        ENDIF
        `tname = "MATH"+"."+"ROUND"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_MATH_ROUND, `col, `substring(`line, `col, `col+`tlen), `tname])
          `col += `tlen
          continue
        ENDIF
        `tname = "MATH"+"."+"SIGN"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_MATH_SIGN, `col, `substring(`line, `col, `col+`tlen), `tname])
          `col += `tlen
          continue
        ENDIF
        `tname = "MATH"+"."+"SIN"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_MATH_SIN, `col, `substring(`line, `col, `col+`tlen), `tname])
          `col += `tlen
          continue
        ENDIF
        `tname = "MATH"+"."+"SQRT"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_MATH_SQRT, `col, `substring(`line, `col, `col+`tlen), `tname])
          `col += `tlen
          continue
        ENDIF
        `tname = "MATH"+"."+"TAN"
        IF THIS.`isTokenEndOther(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_MATH_TAN, `col, `substring(`line, `col, `col+`tlen), `tname])
          `col += `tlen
          continue
        ENDIF
      ENDIF
      IF `ic == "D":
        `tname = "DEBUGL"
        IF THIS.`isTokenEndSpace(`line, `col, `tname):
          `tlen = `length(`tname)
          `push(`tokens, [`key_token_DEBUGL, `col, `substring(`line, `col, `col+`tlen)])
          `col += `tlen
          continue
        ENDIF
      ENDIF
      IF ((`ic >= "A") AND (`ic <= "Z")) OR (`line[`col] == "_"):
        `start = `col
        `col += 1
        WHILE ((`line[`col] >= "0") AND (`line[`col] <= "9")) OR ((`line[`col] >= "a") AND (`line[`col] <= "z")) OR ((`line[`col] >= "A") AND (`line[`col] <= "Z")) OR (`line[`col] == "_") OR (`line[`col] == "."):
          `col += 1
        ENDWHILE
        `textra = `substring(`line, `start, `col)
        `subtextras = `split(`textra, ".")
        `error_msg = NULL
        FORINCR `j(0 `length(`subtextras)):
          IF `length(`subtextras[`j]) == 0:
            `error_msg = "INVALID"+" "+"VARIABLE"
            break
          ENDIF
          IF (`subtextras[`j][0] >= "0") AND (`subtextras[`j][0] <= "9"):
            `error_msg = "INVALID"+" "+"VARIABLE"
            break
          ENDIF
          `subtextras[`j] = `uppercase(`subtextras[`j])
        ENDFOR
        `var_op = NULL
        IF `isnull(`error_msg):
          IF `indexof(THIS.`_reserved_vlast_words, `subtextras[`length(`subtextras)-1]) >= 0:
            IF (`indexof(THIS.`_reserved_qlast_words, `subtextras[`length(`subtextras)-1]) < 0) AND (`length(`subtextras) > 2):
              `error_msg = "INVALID"+" "+"VARIABLE"
            ELSE:
              `var_op = `subtextras[`length(`subtextras)-1]
              `textra = `substring(`textra, 0, `length(`textra)-`length(`var_op)-1)
              `var_op = `indexof(THIS.`_token_strs, `var_op)
              IF `length(`subtextras) == 1:
                `error_msg = "RESERVED"+" "+"WORD"
              ELSIF `length(`subtextras) > 2:
                `textra = `uppercase(`textra)
                IF `indexof(THIS.`_reserved_vlast_words, `subtextras[`length(`subtextras)-2]) >= 0:
                  `error_msg = "RESERVED"+" "+"WORD"
                ENDIF
              ELSE:
                `textra = `lowercase(`textra)
                IF `indexof(THIS.`_reserved_words, `subtextras[0]) >= 0:
                  `error_msg = "RESERVED"+" "+"WORD"
                ELSIF `indexof(THIS.`_reserved_vlast_words, `subtextras[0]) >= 0:
                  `error_msg = "RESERVED"+" "+"WORD"
                ENDIF
              ENDIF
            ENDIF
          ELSE:
            IF `length(`subtextras) > 1:
              `var_op = `key_token_EVAR
              `textra = `uppercase(`textra)
            ELSE:
              `var_op = `key_token_IVAR
              `textra = `lowercase(`textra)
              IF `indexof(THIS.`_reserved_words, `subtextras[0]) >= 0:
                `error_msg = "RESERVED"+" "+"WORD"
              ENDIF
            ENDIF
          ENDIF
        ENDIF
        IF `not(`isnull(`error_msg)):
          `push(`tokens, [`key_token_ERROR, `start, `substring(`line, `start, `col), `error_msg])
          `start = `col
          WHILE `line[`col] != `chr_lf:
            `col += 1
          ENDWHILE
          `push(`tokens, [`key_token_POSTERROR, `start, `substring(`line, `start, `col-1)])
          break
        ENDIF
        `push(`tokens, [`var_op, `start, `substring(`line, `start, `col), `textra])
        continue
      ENDIF
      `push(`tokens, [`key_token_ERROR, `col, `substring(`line, `col, `col+1), "UNEXPECTED"+" "+"CHAR"])
      `col += 1
      `start = `col
      WHILE `line[`col] != `chr_lf:
        `col += 1
      ENDWHILE
      `push(`tokens, [`key_token_POSTERROR, `start, `substring(`line, `start, `col-1)])
      break
    ENDWHILE
    `push(`tokens, [`key_token_NEWLINE, `length(`line)-2, `chr_lf])
    return `tokens

ENDCLASS

VAR `lexer = NEW `Lexer()

VAR `UNARYOP_ = 0
VAR `UNARYOP_PLUS = 1
VAR `UNARYOP_MINUS = 2
VAR `UNARYOP_BIT_NOT = 3

VAR `OPCODE_ERROR = 0
VAR `OPCODE_SUFFIX = 1
VAR `OPCODE_AND = 2
VAR `OPCODE_ASSIGN_OP = 3
VAR `OPCODE_ASSIGN_OP_CSVAR = 4
VAR `OPCODE_ASSIGN_OP_RANDOM = 5
VAR `OPCODE_ASSIGN_POP = 6
VAR `OPCODE_ASSIGN_UNQUEUE = 7
VAR `OPCODE_BIT_AND = 8
VAR `OPCODE_BIT_NOT = 9
VAR `OPCODE_BIT_OR = 10
VAR `OPCODE_BIT_SHL = 11
VAR `OPCODE_BIT_SHR = 12
VAR `OPCODE_BIT_XOR = 13
VAR `OPCODE_BY_REF = 14
VAR `OPCODE_CSVAR = 15
VAR `OPCODE_DEBUGL = 16
VAR `OPCODE_DIV = 17
VAR `OPCODE_ELSE = 18
VAR `OPCODE_ELSIF = 19
VAR `OPCODE_ENDIF = 20
VAR `OPCODE_ENDREP = 21
VAR `OPCODE_EQ = 22
VAR `OPCODE_GE = 23
VAR `OPCODE_GT = 24
VAR `OPCODE_IDV = 25
VAR `OPCODE_IF = 26
VAR `OPCODE_INDEXOF_VAR = 27
VAR `OPCODE_IS_CSVAR = 28
VAR `OPCODE_IS_NOT_CSVAR = 29
VAR `OPCODE_IS_NOT_VAR = 30
VAR `OPCODE_IS_VAR = 31
VAR `OPCODE_LE = 32
VAR `OPCODE_LENGTH_VAR = 33
VAR `OPCODE_LIST = 34
VAR `OPCODE_LIST_AT_CSVAR = 35
VAR `OPCODE_LIST_AT_LIST = 36
VAR `OPCODE_LIST_AT_QUALVAR = 37
VAR `OPCODE_LIST_AT_VAR = 38
VAR `OPCODE_LSIZE_VAR = 39
VAR `OPCODE_LT = 40
VAR `OPCODE_MATH_ABS = 41
VAR `OPCODE_MATH_ACOS = 42
VAR `OPCODE_MATH_ASIN = 43
VAR `OPCODE_MATH_ATAN = 44
VAR `OPCODE_MATH_ATAN2 = 45
VAR `OPCODE_MATH_CEIL = 46
VAR `OPCODE_MATH_COS = 47
VAR `OPCODE_MATH_EXP = 48
VAR `OPCODE_MATH_EXP2 = 49
VAR `OPCODE_MATH_FLOOR = 50
VAR `OPCODE_MATH_LOG = 51
VAR `OPCODE_MATH_LOG2 = 52
VAR `OPCODE_MATH_MAX = 53
VAR `OPCODE_MATH_MIN = 54
VAR `OPCODE_MATH_POW = 55
VAR `OPCODE_MATH_ROUND = 56
VAR `OPCODE_MATH_SIGN = 57
VAR `OPCODE_MATH_SIN = 58
VAR `OPCODE_MATH_SQRT = 59
VAR `OPCODE_MATH_TAN = 60
VAR `OPCODE_MINUS = 61
VAR `OPCODE_MOD = 62
VAR `OPCODE_MODULE_NAME = 63
VAR `OPCODE_MUL = 64
VAR `OPCODE_NE = 65
VAR `OPCODE_NEG = 66
VAR `OPCODE_NOT = 67
VAR `OPCODE_NSIZE_VAR = 68
VAR `OPCODE_NUMBER = 69
VAR `OPCODE_OR = 70
VAR `OPCODE_PLUS = 71
VAR `OPCODE_PROCEDURE = 72
VAR `OPCODE_PUSH = 73
VAR `OPCODE_QUALVAR = 74
VAR `OPCODE_QUEUE = 75
VAR `OPCODE_REPEAT = 76
VAR `OPCODE_REPNEXT = 77
VAR `OPCODE_REPSTOP = 78
VAR `OPCODE_SIZE_VAR = 79
VAR `OPCODE_STRING = 80
VAR `OPCODE_UNASSIGN = 81
VAR `OPCODE_UNASSIGN_CSVAR = 82
VAR `OPCODE_VAR = 83

CLASS `Parser:

  METHOD_INIT():
    THIS.`_ignored_lexemes = []
    `push(THIS.`_ignored_lexemes, `key_token_INDENT)
    `push(THIS.`_ignored_lexemes, `key_token_SPACES)
    `push(THIS.`_ignored_lexemes, `key_token_COMMENT)

  METHOD `parseLine(`tokens):
    IF `lexer.`tokenId(`tokens[`length(`tokens)-2]) == `key_token_POSTERROR:
      return [`OPCODE_ERROR, NULL, `lexer.`tokenExtra(`tokens[`length(`tokens)-3]), `lexer.`tokenColumn(`tokens[`length(`tokens)-3]), []]
    ENDIF
    VAR `lidxs = []
    VAR `j
    FORINCR `j(0 `length(`tokens)):
      IF `indexof(THIS.`_ignored_lexemes, `lexer.`tokenId(`tokens[`j])) < 0:
        `push(`lidxs, `j)
      ENDIF
    ENDFOR
    IF `length(`lidxs) == 1:
      return NULL
    ENDIF
    VAR `lidx_sfxexpr = THIS.`_parseVarSuffix(`tokens, `lidxs, 0)
    IF `length(`lidx_sfxexpr) > 1:
      IF `lidx_sfxexpr[1][1] == `SUFFIX_PUSH:
        return THIS.`_parsePush(`tokens, `lidxs, `lidx_sfxexpr)
      ELSIF `lidx_sfxexpr[1][1] == `SUFFIX_QUEUE:
        return THIS.`_parseQueue(`tokens, `lidxs, `lidx_sfxexpr)
      ELSIF `lidx_sfxexpr[1][1] == `SUFFIX_POP:
        return THIS.`_parsePop(`tokens, `lidxs, `lidx_sfxexpr)
      ELSIF `lidx_sfxexpr[1][1] == `SUFFIX_UNQUEUE:
        return THIS.`_parseUnqueue(`tokens, `lidxs, `lidx_sfxexpr)
      ENDIF
    ENDIF
    VAR `token_id = `lexer.`tokenId(`tokens[`lidxs[0]])
    IF (`token_id == `key_token_IVAR) OR (`token_id == `key_token_CSVAR):
      return THIS.`_parseAssign(`tokens, `lidxs)
    ELSIF `token_id == `key_token_IF:
      return THIS.`_parseIf(`tokens, `lidxs)
    ELSIF `token_id == `key_token_ELSIF:
      return THIS.`_parseElsif(`tokens, `lidxs)
    ELSIF `token_id == `key_token_ELSE:
      return THIS.`_parseElse(`tokens, `lidxs)
    ELSIF `token_id == `key_token_ENDIF:
      return THIS.`_parseEndif(`tokens, `lidxs)
    ELSIF `token_id == `key_token_REPEAT:
      return THIS.`_parseRepeat(`tokens, `lidxs)
    ELSIF `token_id == `key_token_REPNEXT:
      return THIS.`_parseRepnext(`tokens, `lidxs)
    ELSIF `token_id == `key_token_REPSTOP:
      return THIS.`_parseRepstop(`tokens, `lidxs)
    ELSIF `token_id == `key_token_ENDREP:
      return THIS.`_parseEndrep(`tokens, `lidxs)
    ELSIF `token_id == `key_token_EVAR:
      return THIS.`_parseProcedure(`tokens, `lidxs)
    ELSIF `token_id == `key_token_PUSH:
      return THIS.`_parsePush(`tokens, `lidxs, NULL)
    ELSIF `token_id == `key_token_QUEUE:
      return THIS.`_parseQueue(`tokens, `lidxs, NULL)
    ELSIF `token_id == `key_token_POP:
      return THIS.`_parsePop(`tokens, `lidxs, NULL)
    ELSIF `token_id == `key_token_UNQUEUE:
      return THIS.`_parseUnqueue(`tokens, `lidxs, NULL)
    ELSIF `token_id == `key_token_UNASSIGN:
      return THIS.`_parseUnassign(`tokens, `lidxs)
    ELSIF `token_id == `key_token_DEBUGL:
      return THIS.`_parseDebugl(`tokens, `lidxs)
    ENDIF
    return [`OPCODE_ERROR, NULL, "INVALID"+" "+"INSTRUCTION", `lexer.`tokenColumn(`tokens[`lidxs[0]]), []]

  METHOD `_parseAssign(`tokens `lidxs):
    VAR `vvar
    VAR `vmod
    VAR `exprs = []
    VAR `lidx_expr
    VAR `lidx = 1
    VAR `proc_exprs
    VAR `byref_exprs
    VAR `j
    VAR `lidx_ariexpr
    VAR `qualvar
    VAR `expr
    VAR `lidx_sfxexpr
    VAR `vvar_ref
    VAR `vmod_ref
    VAR `indexof_csvar
    VAR `vvar2
    VAR `vmod2
    `vvar = `lexer.`tokenExtra(`tokens[`lidxs[0]])
    IF `lexer.`tokenId(`tokens[`lidxs[0]]) == `key_token_IVAR:
      `vmod = NULL
    ELSE:
      `indexof_csvar = `indexof(`vvar, "@")
      IF `indexof_csvar < 0:
        `vmod = ""
      ELSE:
        `vmod = `substring(`vvar, `indexof_csvar+1, `length(`vvar))
        `vvar = `substring(`vvar, 0, `indexof_csvar)
      ENDIF
    ENDIF
    WHILE `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_LSQR:
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ELSIF `lexer.`tokenId(`tokens[`lidxs[`lidx_expr[0]]]) != `key_token_RSQR:
        return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST"+" "+"INDEX", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      `push(`exprs, `lidx_expr[1])
      `lidx = `lidx_expr[0]+1
    ENDWHILE
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_COMMA:
      `proc_exprs = []
      `byref_exprs = [`vvar, `vmod]
      FORINCR `j(0 `length(`exprs)):
        `push(`byref_exprs, `exprs[`j])
      ENDFOR
      `push(`proc_exprs, [`OPCODE_BY_REF, `byref_exprs])
      WHILE `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_COMMA:
        `lidx += 1
        IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_ASSIGN_OP:
          break
        ENDIF
        IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_CSVAR:
          `vvar_ref = `lexer.`tokenExtra(`tokens[`lidxs[`lidx]])
          `indexof_csvar = `indexof(`vvar_ref, "@")
          IF `indexof_csvar < 0:
            `vmod_ref = ""
          ELSE:
            `vmod_ref = `substring(`vvar_ref, `indexof_csvar+1, `length(`vvar_ref))
            `vvar_ref = `substring(`vvar_ref, 0, `indexof_csvar)
          ENDIF
          `byref_exprs = [`vvar_ref, `vmod_ref]
        ELSIF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_IVAR:
          return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"VARIABLE"+" "+"NAME"+" "+"IN"+" "+"PROCEDURE"+" "+"CALL", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]
        ELSE:
          `byref_exprs = [`lexer.`tokenExtra(`tokens[`lidxs[`lidx]]), NULL]
        ENDIF
        `lidx += 1
        WHILE `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_LSQR:
          `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
          IF `length(`lidx_ariexpr) == 1:
            return `lidx_ariexpr[0]
          ENDIF
          `lidx = `lidx_ariexpr[0]
          IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_RSQR:
            return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST"+" "+"INDEX", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]
          ENDIF
          `push(`byref_exprs, `lidx_ariexpr[1])
          `lidx += 1
        ENDWHILE
        `push(`proc_exprs, [`OPCODE_BY_REF, `byref_exprs])
      ENDWHILE
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_ASSIGN_OP:
        return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"ASSIGNMENT"+" "+"IN"+" "+"PROCEDURE"+" "+"CALL", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]
      ENDIF
      `lidx += 1
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_EVAR:
        return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"PROCEDURE"+" "+"IN"+" "+"ASSIGNMENT", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]
      ENDIF
      `qualvar = `lexer.`tokenExtra(`tokens[`lidxs[`lidx]])
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) != `key_token_LPAR:
        return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"LPAR"+" "+"AFTER"+" "+"PROCEDURE"+" "+"NAME", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+1]]), []]
      ENDIF
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_RPAR:
        IF `lexer.`tokenId(`tokens[`lidxs[`lidx+3]]) != `key_token_NEWLINE:
          return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"PROCEDURE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+3]]), []]
        ENDIF
        return [`OPCODE_PROCEDURE, NULL, `qualvar, `proc_exprs]
      ENDIF
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_BIT_AND:
        IF `lexer.`tokenId(`tokens[`lidxs[`lidx+3]]) == `key_token_CSVAR:
          `vvar_ref = `lexer.`tokenExtra(`tokens[`lidxs[`lidx+3]])
          `indexof_csvar = `indexof(`vvar_ref, "@")
          IF `indexof_csvar < 0:
            `vmod_ref = ""
          ELSE:
            `vmod_ref = `substring(`vvar_ref, `indexof_csvar+1, `length(`vvar_ref))
            `vvar_ref = `substring(`vvar_ref, 0, `indexof_csvar)
          ENDIF
          `byref_exprs = [`vvar_ref, `vmod_ref]
        ELSIF `lexer.`tokenId(`tokens[`lidxs[`lidx+3]]) != `key_token_IVAR:
          return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"VARIABLE"+" "+"NAME"+" "+"IN"+" "+"CALL"+" "+"BY"+" "+"REFERENCE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+3]]), []]
        ELSE:
          `byref_exprs = [`lexer.`tokenExtra(`tokens[`lidxs[`lidx+3]]), NULL]
        ENDIF
        `lidx += 4
        WHILE `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_LSQR:
          `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
          IF `length(`lidx_ariexpr) == 1:
            return `lidx_ariexpr[0]
          ENDIF
          `lidx = `lidx_ariexpr[0]
          IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_RSQR:
            return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST"+" "+"INDEX", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]
          ENDIF
          `push(`byref_exprs, `lidx_ariexpr[1])
          `lidx += 1
        ENDWHILE
        `push(`proc_exprs, [`OPCODE_BY_REF, `byref_exprs])
      ELSIF `lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_MODULE_NAME:
        `push(`proc_exprs, [`OPCODE_MODULE_NAME, `lexer.`tokenExtra(`tokens[`lidxs[`lidx+2]])])
        `lidx += 3
      ELSIF `lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_STRING:
        `push(`proc_exprs, [`OPCODE_STRING, `lexer.`tokenExtra(`tokens[`lidxs[`lidx+2]])])
        `lidx += 3
      ELSE:
        `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx+2)
        IF `length(`lidx_expr) == 1:
          return `lidx_expr[0]
        ENDIF
        `push(`proc_exprs, `lidx_expr[1])
        `lidx = `lidx_expr[0]
      ENDIF
      WHILE `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_COMMA:
        IF `lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_RPAR:
          `lidx += 1
          break
        ENDIF
        IF `lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_BIT_AND:
          IF `lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_CSVAR:
            `vvar_ref = `lexer.`tokenExtra(`tokens[`lidxs[`lidx+2]])
            `indexof_csvar = `indexof(`vvar_ref, "@")
            IF `indexof_csvar < 0:
              `vmod_ref = ""
            ELSE:
              `vmod_ref = `substring(`vvar_ref, `indexof_csvar+1, `length(`vvar_ref))
              `vvar_ref = `substring(`vvar_ref, 0, `indexof_csvar)
            ENDIF
            `byref_exprs = [`vvar_ref, `vmod_ref]
          ELSIF `lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) != `key_token_IVAR:
            return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"VARIABLE"+" "+"NAME"+" "+"IN"+" "+"CALL"+" "+"BY"+" "+"REFERENCE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+2]]), []]
          ELSE:
            `byref_exprs = [`lexer.`tokenExtra(`tokens[`lidxs[`lidx+2]]), NULL]
          ENDIF
          `lidx += 3
          WHILE `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_LSQR:
            `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
            IF `length(`lidx_ariexpr) == 1:
              return `lidx_ariexpr[0]
            ENDIF
            `lidx = `lidx_ariexpr[0]
            IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_RSQR:
              return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST"+" "+"INDEX", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]
            ENDIF
            `push(`byref_exprs, `lidx_ariexpr[1])
            `lidx += 1
          ENDWHILE
          `push(`proc_exprs, [`OPCODE_BY_REF, `byref_exprs])
        ELSIF `lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_MODULE_NAME:
          `push(`proc_exprs, [`OPCODE_MODULE_NAME, `lexer.`tokenExtra(`tokens[`lidxs[`lidx+1]])])
          `lidx = `lidx+2
        ELSIF `lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_STRING:
          `push(`proc_exprs, [`OPCODE_STRING, `lexer.`tokenExtra(`tokens[`lidxs[`lidx+1]])])
          `lidx = `lidx+2
        ELSE:
          `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx+1)
          IF `length(`lidx_expr) == 1:
            return `lidx_expr[0]
          ENDIF
          `push(`proc_exprs, `lidx_expr[1])
          `lidx = `lidx_expr[0]
        ENDIF
      ENDWHILE
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_RPAR:
        return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"RPAR"+" "+"CLOSING"+" "+"PROCEDURE"+" "+"PARAMETERS", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]
      ENDIF
      IF `lidx+1 != `length(`lidxs)-1:
        return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"PROCEDURE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+1]]), []]
      ENDIF
      return [`OPCODE_PROCEDURE, NULL, `qualvar, `proc_exprs]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_ASSIGN_OP_RANDOM:
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_RANDOM:
        IF `lidx+2 != `length(`lidxs)-1:
          return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"RANDOM", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+2]]), []]
        ENDIF
        return [`OPCODE_ASSIGN_OP_RANDOM, NULL, `vvar, `exprs, NULL, `vmod]
      ENDIF
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ARITHMETIC"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      return [`OPCODE_ASSIGN_OP_RANDOM, NULL, `vvar, `exprs, `lidx_expr[1], `vmod]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_ASSIGN_OP_INCR:
      IF `lidx+1 != `length(`lidxs)-1:
        return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"INCREMENT"+" "+"OPERATOR", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+1]]), []]
      ENDIF
      IF `isnull(`vmod):
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_PLUS, [`OPCODE_VAR, `vvar], [`OPCODE_NUMBER, `fp[0].FromFloat(1)]]
        ELSE:
          `expr = [`OPCODE_PLUS, [`OPCODE_LIST_AT_VAR, `vvar, `exprs], [`OPCODE_NUMBER, `fp[0].FromFloat(1)]]
        ENDIF
        return [`OPCODE_ASSIGN_OP, NULL, `vvar, `exprs, `expr]
      ELSE:
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_PLUS, [`OPCODE_CSVAR, `vvar, `vmod], [`OPCODE_NUMBER, `fp[0].FromFloat(1)]]
        ELSE:
          `expr = [`OPCODE_PLUS, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod], [`OPCODE_NUMBER, `fp[0].FromFloat(1)]]
        ENDIF
        return [`OPCODE_ASSIGN_OP_CSVAR, NULL, `vvar, `vmod, `exprs, `expr]
      ENDIF
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_ASSIGN_OP_DECR:
      IF `lidx+1 != `length(`lidxs)-1:
        return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"DECREMENT"+" "+"OPERATOR", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+1]]), []]
      ENDIF
      IF `isnull(`vmod):
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_MINUS, [`OPCODE_VAR, `vvar], [`OPCODE_NUMBER, `fp[0].FromFloat(1)]]
        ELSE:
          `expr = [`OPCODE_MINUS, [`OPCODE_LIST_AT_VAR, `vvar, `exprs], [`OPCODE_NUMBER, `fp[0].FromFloat(1)]]
        ENDIF
        return [`OPCODE_ASSIGN_OP, NULL, `vvar, `exprs, `expr]
      ELSE:
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_MINUS, [`OPCODE_CSVAR, `vvar, `vmod], [`OPCODE_NUMBER, `fp[0].FromFloat(1)]]
        ELSE:
          `expr = [`OPCODE_MINUS, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod], [`OPCODE_NUMBER, `fp[0].FromFloat(1)]]
        ENDIF
        return [`OPCODE_ASSIGN_OP_CSVAR, NULL, `vvar, `vmod, `exprs, `expr]
      ENDIF
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_ASSIGN_OP_PLUS:
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ARITHMETIC"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      IF `isnull(`vmod):
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_PLUS, [`OPCODE_VAR, `vvar], `lidx_expr[1]]
        ELSE:
          `expr = [`OPCODE_PLUS, [`OPCODE_LIST_AT_VAR, `vvar, `exprs], `lidx_expr[1]]
        ENDIF
        return [`OPCODE_ASSIGN_OP, NULL, `vvar, `exprs, `expr]
      ELSE:
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_PLUS, [`OPCODE_CSVAR, `vvar, `vmod], `lidx_expr[1]]
        ELSE:
          `expr = [`OPCODE_PLUS, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod], `lidx_expr[1]]
        ENDIF
        return [`OPCODE_ASSIGN_OP_CSVAR, NULL, `vvar, `vmod, `exprs, `expr]
      ENDIF
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_ASSIGN_OP_MINUS:
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ARITHMETIC"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      IF `isnull(`vmod):
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_MINUS, [`OPCODE_VAR, `vvar], `lidx_expr[1]]
        ELSE:
          `expr = [`OPCODE_MINUS, [`OPCODE_LIST_AT_VAR, `vvar, `exprs], `lidx_expr[1]]
        ENDIF
        return [`OPCODE_ASSIGN_OP, NULL, `vvar, `exprs, `expr]
      ELSE:
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_MINUS, [`OPCODE_CSVAR, `vvar, `vmod], `lidx_expr[1]]
        ELSE:
          `expr = [`OPCODE_MINUS, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod], `lidx_expr[1]]
        ENDIF
        return [`OPCODE_ASSIGN_OP_CSVAR, NULL, `vvar, `vmod, `exprs, `expr]
      ENDIF
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_ASSIGN_OP_MUL:
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ARITHMETIC"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      IF `isnull(`vmod):
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_MUL, [`OPCODE_VAR, `vvar], `lidx_expr[1]]
        ELSE:
          `expr = [`OPCODE_MUL, [`OPCODE_LIST_AT_VAR, `vvar, `exprs], `lidx_expr[1]]
        ENDIF
        return [`OPCODE_ASSIGN_OP, NULL, `vvar, `exprs, `expr]
      ELSE:
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_MUL, [`OPCODE_CSVAR, `vvar, `vmod], `lidx_expr[1]]
        ELSE:
          `expr = [`OPCODE_MUL, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod], `lidx_expr[1]]
        ENDIF
        return [`OPCODE_ASSIGN_OP_CSVAR, NULL, `vvar, `vmod, `exprs, `expr]
      ENDIF
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_ASSIGN_OP_DIV:
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ARITHMETIC"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      IF `isnull(`vmod):
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_DIV, [`OPCODE_VAR, `vvar], `lidx_expr[1]]
        ELSE:
          `expr = [`OPCODE_DIV, [`OPCODE_LIST_AT_VAR, `vvar, `exprs], `lidx_expr[1]]
        ENDIF
        return [`OPCODE_ASSIGN_OP, NULL, `vvar, `exprs, `expr]
      ELSE:
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_DIV, [`OPCODE_CSVAR, `vvar, `vmod], `lidx_expr[1]]
        ELSE:
          `expr = [`OPCODE_DIV, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod], `lidx_expr[1]]
        ENDIF
        return [`OPCODE_ASSIGN_OP_CSVAR, NULL, `vvar, `vmod, `exprs, `expr]
      ENDIF
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_ASSIGN_OP_IDV:
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ARITHMETIC"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      IF `isnull(`vmod):
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_IDV, [`OPCODE_VAR, `vvar], `lidx_expr[1]]
        ELSE:
          `expr = [`OPCODE_IDV, [`OPCODE_LIST_AT_VAR, `vvar, `exprs], `lidx_expr[1]]
        ENDIF
        return [`OPCODE_ASSIGN_OP, NULL, `vvar, `exprs, `expr]
      ELSE:
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_IDV, [`OPCODE_CSVAR, `vvar, `vmod], `lidx_expr[1]]
        ELSE:
          `expr = [`OPCODE_IDV, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod], `lidx_expr[1]]
        ENDIF
        return [`OPCODE_ASSIGN_OP_CSVAR, NULL, `vvar, `vmod, `exprs, `expr]
      ENDIF
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_ASSIGN_OP_MOD:
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ARITHMETIC"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      IF `isnull(`vmod):
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_MOD, [`OPCODE_VAR, `vvar], `lidx_expr[1]]
        ELSE:
          `expr = [`OPCODE_MOD, [`OPCODE_LIST_AT_VAR, `vvar, `exprs], `lidx_expr[1]]
        ENDIF
        return [`OPCODE_ASSIGN_OP, NULL, `vvar, `exprs, `expr]
      ELSE:
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_MOD, [`OPCODE_CSVAR, `vvar, `vmod], `lidx_expr[1]]
        ELSE:
          `expr = [`OPCODE_MOD, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod], `lidx_expr[1]]
        ENDIF
        return [`OPCODE_ASSIGN_OP_CSVAR, NULL, `vvar, `vmod, `exprs, `expr]
      ENDIF
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_ASSIGN_OP_BIT_AND:
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ARITHMETIC"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      IF `isnull(`vmod):
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_BIT_AND, [`OPCODE_VAR, `vvar], `lidx_expr[1]]
        ELSE:
          `expr = [`OPCODE_BIT_AND, [`OPCODE_LIST_AT_VAR, `vvar, `exprs], `lidx_expr[1]]
        ENDIF
        return [`OPCODE_ASSIGN_OP, NULL, `vvar, `exprs, `expr]
      ELSE:
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_BIT_AND, [`OPCODE_CSVAR, `vvar, `vmod], `lidx_expr[1]]
        ELSE:
          `expr = [`OPCODE_BIT_AND, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod], `lidx_expr[1]]
        ENDIF
        return [`OPCODE_ASSIGN_OP_CSVAR, NULL, `vvar, `vmod, `exprs, `expr]
      ENDIF
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_ASSIGN_OP_BIT_OR:
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ARITHMETIC"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      IF `isnull(`vmod):
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_BIT_OR, [`OPCODE_VAR, `vvar], `lidx_expr[1]]
        ELSE:
          `expr = [`OPCODE_BIT_OR, [`OPCODE_LIST_AT_VAR, `vvar, `exprs], `lidx_expr[1]]
        ENDIF
        return [`OPCODE_ASSIGN_OP, NULL, `vvar, `exprs, `expr]
      ELSE:
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_BIT_OR, [`OPCODE_CSVAR, `vvar, `vmod], `lidx_expr[1]]
        ELSE:
          `expr = [`OPCODE_BIT_OR, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod], `lidx_expr[1]]
        ENDIF
        return [`OPCODE_ASSIGN_OP_CSVAR, NULL, `vvar, `vmod, `exprs, `expr]
      ENDIF
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_ASSIGN_OP_BIT_XOR:
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ARITHMETIC"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      IF `isnull(`vmod):
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_BIT_XOR, [`OPCODE_VAR, `vvar], `lidx_expr[1]]
        ELSE:
          `expr = [`OPCODE_BIT_XOR, [`OPCODE_LIST_AT_VAR, `vvar, `exprs], `lidx_expr[1]]
        ENDIF
        return [`OPCODE_ASSIGN_OP, NULL, `vvar, `exprs, `expr]
      ELSE:
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_BIT_XOR, [`OPCODE_CSVAR, `vvar, `vmod], `lidx_expr[1]]
        ELSE:
          `expr = [`OPCODE_BIT_XOR, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod], `lidx_expr[1]]
        ENDIF
        return [`OPCODE_ASSIGN_OP_CSVAR, NULL, `vvar, `vmod, `exprs, `expr]
      ENDIF
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_ASSIGN_OP_BIT_SHL:
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ARITHMETIC"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      IF `isnull(`vmod):
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_BIT_SHL, [`OPCODE_VAR, `vvar], `lidx_expr[1]]
        ELSE:
          `expr = [`OPCODE_BIT_SHL, [`OPCODE_LIST_AT_VAR, `vvar, `exprs], `lidx_expr[1]]
        ENDIF
        return [`OPCODE_ASSIGN_OP, NULL, `vvar, `exprs, `expr]
      ELSE:
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_BIT_SHL, [`OPCODE_CSVAR, `vvar, `vmod], `lidx_expr[1]]
        ELSE:
          `expr = [`OPCODE_BIT_SHL, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod], `lidx_expr[1]]
        ENDIF
        return [`OPCODE_ASSIGN_OP_CSVAR, NULL, `vvar, `vmod, `exprs, `expr]
      ENDIF
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_ASSIGN_OP_BIT_SHR:
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ARITHMETIC"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      IF `isnull(`vmod):
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_BIT_SHR, [`OPCODE_VAR, `vvar], `lidx_expr[1]]
        ELSE:
          `expr = [`OPCODE_BIT_SHR, [`OPCODE_LIST_AT_VAR, `vvar, `exprs], `lidx_expr[1]]
        ENDIF
        return [`OPCODE_ASSIGN_OP, NULL, `vvar, `exprs, `expr]
      ELSE:
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_BIT_SHR, [`OPCODE_CSVAR, `vvar, `vmod], `lidx_expr[1]]
        ELSE:
          `expr = [`OPCODE_BIT_SHR, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod], `lidx_expr[1]]
        ENDIF
        return [`OPCODE_ASSIGN_OP_CSVAR, NULL, `vvar, `vmod, `exprs, `expr]
      ENDIF
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_ASSIGN_OP_TOGGLE:
      IF `lidx+1 != `length(`lidxs)-1:
        return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"TOGGLE"+" "+"OPERATOR", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+1]]), []]
      ENDIF

      IF `isnull(`vmod):
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_BIT_NOT, [`OPCODE_VAR, `vvar]]
        ELSE:
          `expr = [`OPCODE_BIT_NOT, [`OPCODE_LIST_AT_VAR, `vvar, `exprs]]
        ENDIF
        return [`OPCODE_ASSIGN_OP, NULL, `vvar, `exprs, `expr]
      ELSE:
        IF `length(`exprs) == 0:
          `expr = [`OPCODE_BIT_NOT, [`OPCODE_CSVAR, `vvar, `vmod]]
        ELSE:
          `expr = [`OPCODE_BIT_NOT, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod]]
        ENDIF
        return [`OPCODE_ASSIGN_OP_CSVAR, NULL, `vvar, `vmod, `exprs, `expr]
      ENDIF
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_ASSIGN_OP:
      return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"ASSIGNMENT", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]
    ENDIF
    IF (`lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_EVAR) AND (`lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_LPAR):
      `proc_exprs = []
      `byref_exprs = [`vvar, `vmod]
      FORINCR `j(0 `length(`exprs)):
        `push(`byref_exprs, `exprs[`j])
      ENDFOR
      `push(`proc_exprs, [`OPCODE_BY_REF, `byref_exprs])
      `lidx += 1
      `qualvar = `lexer.`tokenExtra(`tokens[`lidxs[`lidx]])
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_RPAR:
        IF `lexer.`tokenId(`tokens[`lidxs[`lidx+3]]) != `key_token_NEWLINE:
          return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"PROCEDURE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+3]]), []]
        ENDIF
        return [`OPCODE_PROCEDURE, NULL, `qualvar, `proc_exprs]
      ENDIF
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_BIT_AND:
        IF `lexer.`tokenId(`tokens[`lidxs[`lidx+3]]) == `key_token_CSVAR:
          `vvar_ref = `lexer.`tokenExtra(`tokens[`lidxs[`lidx+3]])
          `indexof_csvar = `indexof(`vvar_ref, "@")
          IF `indexof_csvar < 0:
            `vmod_ref = ""
          ELSE:
            `vmod_ref = `substring(`vvar_ref, `indexof_csvar+1, `length(`vvar_ref))
            `vvar_ref = `substring(`vvar_ref, 0, `indexof_csvar)
          ENDIF
          `byref_exprs = [`vvar_ref, `vmod_ref]
        ELSIF `lexer.`tokenId(`tokens[`lidxs[`lidx+3]]) != `key_token_IVAR:
          return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"VARIABLE"+" "+"NAME"+" "+"IN"+" "+"CALL"+" "+"BY"+" "+"REFERENCE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+3]]), []]
        ELSE:
          `byref_exprs = [`lexer.`tokenExtra(`tokens[`lidxs[`lidx+3]]), NULL]
        ENDIF
        `lidx += 4
        WHILE `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_LSQR:
          `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
          IF `length(`lidx_ariexpr) == 1:
            return `lidx_ariexpr[0]
          ENDIF
          `lidx = `lidx_ariexpr[0]
          IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_RSQR:
            return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST"+" "+"INDEX", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]
          ENDIF
          `push(`byref_exprs, `lidx_ariexpr[1])
          `lidx += 1
        ENDWHILE
        `push(`proc_exprs, [`OPCODE_BY_REF, `byref_exprs])
      ELSIF `lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_MODULE_NAME:
        `push(`proc_exprs, [`OPCODE_MODULE_NAME, `lexer.`tokenExtra(`tokens[`lidxs[`lidx+2]])])
        `lidx += 3
      ELSIF `lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_STRING:
        `push(`proc_exprs, [`OPCODE_STRING, `lexer.`tokenExtra(`tokens[`lidxs[`lidx+2]])])
        `lidx += 3
      ELSE:
        `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx+2)
        IF `length(`lidx_expr) == 1:
          return `lidx_expr[0]
        ENDIF
        `push(`proc_exprs, `lidx_expr[1])
        `lidx = `lidx_expr[0]
      ENDIF
      WHILE `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_COMMA:
        IF `lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_RPAR:
          `lidx += 1
          break
        ENDIF
        IF `lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_BIT_AND:
          IF `lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_CSVAR:
            `vvar_ref = `lexer.`tokenExtra(`tokens[`lidxs[`lidx+2]])
            `indexof_csvar = `indexof(`vvar_ref, "@")
            IF `indexof_csvar < 0:
              `vmod_ref = ""
            ELSE:
              `vmod_ref = `substring(`vvar_ref, `indexof_csvar+1, `length(`vvar_ref))
              `vvar_ref = `substring(`vvar_ref, 0, `indexof_csvar)
            ENDIF
            `byref_exprs = [`vvar_ref, `vmod_ref]
          ELSIF `lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) != `key_token_IVAR:
            return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"VARIABLE"+" "+"NAME"+" "+"IN"+" "+"CALL"+" "+"BY"+" "+"REFERENCE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+2]]), []]
          ELSE:
            `byref_exprs = [`lexer.`tokenExtra(`tokens[`lidxs[`lidx+2]]), NULL]
          ENDIF
          `lidx += 3
          WHILE `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_LSQR:
            `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
            IF `length(`lidx_ariexpr) == 1:
              return `lidx_ariexpr[0]
            ENDIF
            `lidx = `lidx_ariexpr[0]
            IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_RSQR:
              return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST"+" "+"INDEX", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]
            ENDIF
            `push(`byref_exprs, `lidx_ariexpr[1])
            `lidx += 1
          ENDWHILE
          `push(`proc_exprs, [`OPCODE_BY_REF, `byref_exprs])
        ELSIF `lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_MODULE_NAME:
          `push(`proc_exprs, [`OPCODE_MODULE_NAME, `lexer.`tokenExtra(`tokens[`lidxs[`lidx+1]])])
          `lidx = `lidx+2
        ELSIF `lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_STRING:
          `push(`proc_exprs, [`OPCODE_STRING, `lexer.`tokenExtra(`tokens[`lidxs[`lidx+1]])])
          `lidx = `lidx+2
        ELSE:
          `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx+1)
          IF `length(`lidx_expr) == 1:
            return `lidx_expr[0]
          ENDIF
          `push(`proc_exprs, `lidx_expr[1])
          `lidx = `lidx_expr[0]
        ENDIF
      ENDWHILE
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_RPAR:
        return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"RPAR"+" "+"CLOSING"+" "+"PROCEDURE"+" "+"PARAMETERS", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]
      ENDIF
      IF `lidx+1 != `length(`lidxs)-1:
        return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"PROCEDURE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+1]]), []]
      ENDIF
      return [`OPCODE_PROCEDURE, NULL, `qualvar, `proc_exprs]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_POP:
      `vvar2 = `lexer.`tokenExtra(`tokens[`lidxs[`lidx+1]])
      IF `vvar2[0] != "!":
        `vmod2 = NULL
      ELSE:
        `indexof_csvar = `indexof(`vvar2, "@")
        IF `indexof_csvar < 0:
          `vmod2 = ""
          `vvar2 = `substring(`vvar2, 1, `length(`vvar2))
        ELSE:
          `vmod2 = `substring(`vvar2, `indexof_csvar+1, `length(`vvar2))
          `vvar2 = `substring(`vvar2, 1, `indexof_csvar)
        ENDIF
      ENDIF
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_NEWLINE:
        IF `isnull(`vmod2):
          return [`OPCODE_ASSIGN_POP, NULL, `vvar, `exprs, [`OPCODE_VAR, `vvar2], NULL, `vmod]
        ELSE:
          return [`OPCODE_ASSIGN_POP, NULL, `vvar, `exprs, [`OPCODE_CSVAR, `vvar2, `vmod2], NULL, `vmod]
        ENDIF
      ENDIF
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+2)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"POP", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      IF `isnull(`vmod2):
        return [`OPCODE_ASSIGN_POP, NULL, `vvar, `exprs, [`OPCODE_VAR, `vvar2], `lidx_expr[1], `vmod]
      ELSE:
        return [`OPCODE_ASSIGN_POP, NULL, `vvar, `exprs, [`OPCODE_CSVAR, `vvar2, `vmod2], `lidx_expr[1], `vmod]
      ENDIF
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_UNQUEUE:
      `vvar2 = `lexer.`tokenExtra(`tokens[`lidxs[`lidx+1]])
      IF `vvar2[0] != "!":
        `vmod2 = NULL
      ELSE:
        `indexof_csvar = `indexof(`vvar2, "@")
        IF `indexof_csvar < 0:
          `vmod2 = ""
          `vvar2 = `substring(`vvar2, 1, `length(`vvar2))
        ELSE:
          `vmod2 = `substring(`vvar2, `indexof_csvar+1, `length(`vvar2))
          `vvar2 = `substring(`vvar2, 1, `indexof_csvar)
        ENDIF
      ENDIF
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) != `key_token_NEWLINE:
        return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"UNQUEUE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+2]]), []]
      ENDIF
      IF `isnull(`vmod2):
        return [`OPCODE_ASSIGN_UNQUEUE, NULL, `vvar, `exprs, [`OPCODE_VAR, `vvar2], `vmod]
      ELSE:
        return [`OPCODE_ASSIGN_UNQUEUE, NULL, `vvar, `exprs, [`OPCODE_CSVAR, `vvar2, `vmod2], `vmod]
      ENDIF
    ENDIF
    `lidx_sfxexpr = THIS.`_parseVarSuffix(`tokens, `lidxs, `lidx+1)
    IF `length(`lidx_sfxexpr) > 1:
      IF `lidx_sfxexpr[1][1] == `SUFFIX_POP:
        IF `lexer.`tokenId(`tokens[`lidxs[`lidx_sfxexpr[0]]]) == `key_token_NEWLINE:
          return [`OPCODE_ASSIGN_POP, NULL, `vvar, `exprs, `lidx_sfxexpr[1][2], NULL, `vmod]
        ENDIF
        `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx_sfxexpr[0])
        IF `length(`lidx_expr) == 1:
          return `lidx_expr[0]
        ENDIF
        IF `lidx_expr[0] != `length(`lidxs)-1:
          return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"POP", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
        ENDIF
        return [`OPCODE_ASSIGN_POP, NULL, `vvar, `exprs, `lidx_sfxexpr[1][2], `lidx_expr[1], `vmod]
      ENDIF
      IF `lidx_sfxexpr[1][1] == `SUFFIX_UNQUEUE:
        IF `lexer.`tokenId(`tokens[`lidxs[`lidx_sfxexpr[0]]]) != `key_token_NEWLINE:
          return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"UNQUEUE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_sfxexpr[0]]]), []]
        ENDIF
        return [`OPCODE_ASSIGN_UNQUEUE, NULL, `vvar, `exprs, `lidx_sfxexpr[1][2], `vmod]
      ENDIF
    ENDIF
    `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx+1)
    IF `length(`lidx_expr) == 1:
      return `lidx_expr[0]
    ENDIF
    IF `lidx_expr[0] != `length(`lidxs)-1:
      return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ASSIGNMENT", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
    ENDIF
    IF `isnull(`vmod):
      return [`OPCODE_ASSIGN_OP, NULL, `vvar, `exprs, `lidx_expr[1]]
    ELSE:
      return [`OPCODE_ASSIGN_OP_CSVAR, NULL, `vvar, `vmod, `exprs, `lidx_expr[1]]
    ENDIF

  METHOD `_parseIf(`tokens `lidxs):
    VAR `lidx_expr = THIS.`_parseLogicalExpression(`tokens, `lidxs, 1)
    IF `length(`lidx_expr) == 1:
      return `lidx_expr[0]
    ENDIF
    IF `lidx_expr[0] != `length(`lidxs)-1:
      return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"LOGICAL"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
    ENDIF
    return [`OPCODE_IF, NULL, NULL, `lidx_expr[1]]

  METHOD `_parseElsif(`tokens `lidxs):
    VAR `lidx_expr = THIS.`_parseLogicalExpression(`tokens, `lidxs, 1)
    IF `length(`lidx_expr) == 1:
      return `lidx_expr[0]
    ENDIF
    IF `lidx_expr[0] != `length(`lidxs)-1:
      return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"LOGICAL"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
    ENDIF
    return [`OPCODE_ELSIF, NULL, NULL, `lidx_expr[1]]

  METHOD `_parseElse(`tokens `lidxs):
    IF `length(`lidxs) != 2:
      return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ELSE", `lexer.`tokenColumn(`tokens[`lidxs[1]]), []]
    ENDIF
    return [`OPCODE_ELSE, NULL]

  METHOD `_parseEndif(`tokens `lidxs):
    IF `length(`lidxs) != 2:
      return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ENDIF", `lexer.`tokenColumn(`tokens[`lidxs[1]]), []]
    ENDIF
    return [`OPCODE_ENDIF, NULL]

  METHOD `_parseRepeat(`tokens `lidxs):
    IF `length(`lidxs) == 3 AND `lexer.`tokenId(`tokens[`lidxs[1]]) == `key_token_IVAR:
      return [`OPCODE_REPEAT, NULL, NULL, `lexer.`tokenExtra(`tokens[`lidxs[1]])]
    ENDIF
    IF `length(`lidxs) < 3 OR `lexer.`tokenId(`tokens[`lidxs[1]]) != `key_token_IVAR:
      return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"VARIABLE"+" "+"AFTER"+" "+"REPEAT", `lexer.`tokenColumn(`tokens[`lidxs[1]]), []]
    ENDIF
    return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"REPEAT", `lexer.`tokenColumn(`tokens[`lidxs[2]]), []]

  METHOD `_parseRepnext(`tokens `lidxs):
    IF `length(`lidxs) != 2:
      return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"REPNEXT", `lexer.`tokenColumn(`tokens[`lidxs[1]]), []]
    ENDIF
    return [`OPCODE_REPNEXT, NULL]

  METHOD `_parseRepstop(`tokens `lidxs):
    IF `length(`lidxs) != 2:
      return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"REPSTOP", `lexer.`tokenColumn(`tokens[`lidxs[1]]), []]
    ENDIF
    return [`OPCODE_REPSTOP, NULL]

  METHOD `_parseEndrep(`tokens `lidxs):
    IF `length(`lidxs) != 2:
      return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"ENDREP", `lexer.`tokenColumn(`tokens[`lidxs[1]]), []]
    ENDIF
    return [`OPCODE_ENDREP, NULL, NULL]

  METHOD `_parseProcedure(`tokens `lidxs):
    VAR `qualvar = `lexer.`tokenExtra(`tokens[`lidxs[0]])
    IF `lexer.`tokenId(`tokens[`lidxs[1]]) != `key_token_LPAR:
      return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"LPAR"+" "+"AFTER"+" "+"PROCEDURE"+" "+"NAME", `lexer.`tokenColumn(`tokens[`lidxs[1]]), []]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[2]]) == `key_token_RPAR:
      IF `lexer.`tokenId(`tokens[`lidxs[3]]) != `key_token_NEWLINE:
        return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"PROCEDURE", `lexer.`tokenColumn(`tokens[`lidxs[3]]), []]
      ENDIF
      return [`OPCODE_PROCEDURE, NULL, `qualvar, []]
    ENDIF
    VAR `exprs = []
    VAR `lidx_expr
    VAR `lidx
    VAR `byref_exprs
    VAR `lidx_ariexpr
    VAR `vvar_ref
    VAR `vmod_ref
    VAR `indexof_csvar
    IF `lexer.`tokenId(`tokens[`lidxs[2]]) == `key_token_BIT_AND:
      `lidx = 0
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx+3]]) == `key_token_CSVAR:
        `vvar_ref = `lexer.`tokenExtra(`tokens[`lidxs[`lidx+3]])
        `indexof_csvar = `indexof(`vvar_ref, "@")
        IF `indexof_csvar < 0:
          `vmod_ref = ""
        ELSE:
          `vmod_ref = `substring(`vvar_ref, `indexof_csvar+1, `length(`vvar_ref))
          `vvar_ref = `substring(`vvar_ref, 0, `indexof_csvar)
        ENDIF
        `byref_exprs = [`vvar_ref, `vmod_ref]
      ELSIF `lexer.`tokenId(`tokens[`lidxs[`lidx+3]]) != `key_token_IVAR:
        return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"VARIABLE"+" "+"NAME"+" "+"IN"+" "+"CALL"+" "+"BY"+" "+"REFERENCE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+3]]), []]
      ELSE:
        `byref_exprs = [`lexer.`tokenExtra(`tokens[`lidxs[`lidx+3]]), NULL]
      ENDIF
      `lidx += 4
      WHILE `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_LSQR:
        `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
        IF `length(`lidx_ariexpr) == 1:
          return `lidx_ariexpr[0]
        ENDIF
        `lidx = `lidx_ariexpr[0]
        IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_RSQR:
          return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST"+" "+"INDEX", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]
        ENDIF
        `push(`byref_exprs, `lidx_ariexpr[1])
        `lidx += 1
      ENDWHILE
      `push(`exprs, [`OPCODE_BY_REF, `byref_exprs])
    ELSIF `lexer.`tokenId(`tokens[`lidxs[2]]) == `key_token_MODULE_NAME:
      `push(`exprs, [`OPCODE_MODULE_NAME, `lexer.`tokenExtra(`tokens[`lidxs[2]])])
      `lidx = 3
    ELSIF `lexer.`tokenId(`tokens[`lidxs[2]]) == `key_token_STRING:
      `push(`exprs, [`OPCODE_STRING, `lexer.`tokenExtra(`tokens[`lidxs[2]])])
      `lidx = 3
    ELSE:
      `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, 2)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      `push(`exprs, `lidx_expr[1])
      `lidx = `lidx_expr[0]
    ENDIF
    WHILE `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_COMMA:
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_RPAR:
        `lidx += 1
        break
      ENDIF
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_BIT_AND:
        IF `lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_CSVAR:
          `vvar_ref = `lexer.`tokenExtra(`tokens[`lidxs[`lidx+2]])
          `indexof_csvar = `indexof(`vvar_ref, "@")
          IF `indexof_csvar < 0:
            `vmod_ref = ""
          ELSE:
            `vmod_ref = `substring(`vvar_ref, `indexof_csvar+1, `length(`vvar_ref))
            `vvar_ref = `substring(`vvar_ref, 0, `indexof_csvar)
          ENDIF
          `byref_exprs = [`vvar_ref, `vmod_ref]
        ELSIF `lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) != `key_token_IVAR:
          return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"VARIABLE"+" "+"NAME"+" "+"IN"+" "+"CALL"+" "+"BY"+" "+"REFERENCE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+2]]), []]
        ELSE:
          `byref_exprs = [`lexer.`tokenExtra(`tokens[`lidxs[`lidx+2]]), NULL]
        ENDIF
        `lidx += 3
        WHILE `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_LSQR:
          `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
          IF `length(`lidx_ariexpr) == 1:
            return `lidx_ariexpr[0]
          ENDIF
          `lidx = `lidx_ariexpr[0]
          IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_RSQR:
            return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST"+" "+"INDEX", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]
          ENDIF
          `push(`byref_exprs, `lidx_ariexpr[1])
          `lidx += 1
        ENDWHILE
        `push(`exprs, [`OPCODE_BY_REF, `byref_exprs])
      ELSIF `lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_MODULE_NAME:
        `push(`exprs, [`OPCODE_MODULE_NAME, `lexer.`tokenExtra(`tokens[`lidxs[`lidx+1]])])
        `lidx = `lidx+2
      ELSIF `lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_STRING:
        `push(`exprs, [`OPCODE_STRING, `lexer.`tokenExtra(`tokens[`lidxs[`lidx+1]])])
        `lidx = `lidx+2
      ELSE:
        `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx+1)
        IF `length(`lidx_expr) == 1:
          return `lidx_expr[0]
        ENDIF
        `push(`exprs, `lidx_expr[1])
        `lidx = `lidx_expr[0]
      ENDIF
    ENDWHILE
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_RPAR:
      return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"RPAR"+" "+"CLOSING"+" "+"PROCEDURE"+" "+"PARAMETERS", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]
    ENDIF
    IF `lidx+1 != `length(`lidxs)-1:
      return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"PROCEDURE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+1]]), []]
    ENDIF
    return [`OPCODE_PROCEDURE, NULL, `qualvar, `exprs]

  METHOD `_parsePush(`tokens `lidxs `lidx_sfxexpr):
    VAR `lidx_expr
    VAR `lidx_ariexpr
    IF `not(`isnull(`lidx_sfxexpr)):
      `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx_sfxexpr[0])
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] == `length(`lidxs)-1:
        return [`OPCODE_PUSH, NULL, `lidx_sfxexpr[1][2], `lidx_expr[1], NULL]
      ENDIF
      `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx_expr[0])
      IF `length(`lidx_ariexpr) == 1:
        return `lidx_ariexpr[0]
      ENDIF
      IF `lidx_ariexpr[0] != `length(`lidxs)-1:
        return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"PUSH", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_ariexpr[0]]]), []]
      ENDIF
      return [`OPCODE_PUSH, NULL, `lidx_sfxexpr[1][2], `lidx_expr[1], `lidx_ariexpr[1]]
    ENDIF
    `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, 1)
    IF `length(`lidx_expr) == 1:
      return `lidx_expr[0]
    ENDIF
    VAR `vvar = `lexer.`tokenExtra(`tokens[`lidxs[0]])
    VAR `vmod
    VAR `indexof_csvar
    IF `vvar[0] != "!":
      `vmod = NULL
    ELSE:
      `indexof_csvar = `indexof(`vvar, "@")
      IF `indexof_csvar < 0:
        `vmod = ""
        `vvar = `substring(`vvar, 1, `length(`vvar))
      ELSE:
        `vmod = `substring(`vvar, `indexof_csvar+1, `length(`vvar))
        `vvar = `substring(`vvar, 1, `indexof_csvar)
      ENDIF
    ENDIF
    IF `lidx_expr[0] == `length(`lidxs)-1:
      IF `isnull(`vmod):
        return [`OPCODE_PUSH, NULL, [`OPCODE_VAR, `vvar], `lidx_expr[1], NULL]
      ELSE:
        return [`OPCODE_PUSH, NULL, [`OPCODE_CSVAR, `vvar, `vmod], `lidx_expr[1], NULL]
      ENDIF
    ENDIF
    `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx_expr[0])
    IF `length(`lidx_ariexpr) == 1:
      return `lidx_ariexpr[0]
    ENDIF
    IF `lidx_ariexpr[0] != `length(`lidxs)-1:
      return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"PUSH", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_ariexpr[0]]]), []]
    ENDIF
    IF `isnull(`vmod):
      return [`OPCODE_PUSH, NULL, [`OPCODE_VAR, `vvar], `lidx_expr[1], `lidx_ariexpr[1]]
    ELSE:
      return [`OPCODE_PUSH, NULL, [`OPCODE_CSVAR, `vvar, `vmod], `lidx_expr[1], `lidx_ariexpr[1]]
    ENDIF

  METHOD `_parseQueue(`tokens `lidxs `lidx_sfxexpr):
    VAR `lidx_expr
    IF `not(`isnull(`lidx_sfxexpr)):
      `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx_sfxexpr[0])
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"QUEUE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      return [`OPCODE_QUEUE, NULL, `lidx_sfxexpr[1][2], `lidx_expr[1]]
    ENDIF
    `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, 1)
    IF `length(`lidx_expr) == 1:
      return `lidx_expr[0]
    ENDIF
    IF `lidx_expr[0] != `length(`lidxs)-1:
      return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"QUEUE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
    ENDIF
    VAR `vvar = `lexer.`tokenExtra(`tokens[`lidxs[0]])
    VAR `vmod
    VAR `indexof_csvar
    IF `vvar[0] != "!":
      `vmod = NULL
    ELSE:
      `indexof_csvar = `indexof(`vvar, "@")
      IF `indexof_csvar < 0:
        `vmod = ""
        `vvar = `substring(`vvar, 1, `length(`vvar))
      ELSE:
        `vmod = `substring(`vvar, `indexof_csvar+1, `length(`vvar))
        `vvar = `substring(`vvar, 1, `indexof_csvar)
      ENDIF
    ENDIF
    IF `isnull(`vmod):
      return [`OPCODE_QUEUE, NULL, [`OPCODE_VAR, `vvar], `lidx_expr[1]]
    ELSE:
      return [`OPCODE_QUEUE, NULL, [`OPCODE_CSVAR, `vvar, `vmod], `lidx_expr[1]]
    ENDIF

  METHOD `_parsePop(`tokens `lidxs `lidx_sfxexpr):
    VAR `lidx_expr
    IF `not(`isnull(`lidx_sfxexpr)):
      IF `lidx_sfxexpr[0] == `length(`lidxs)-1:
        return [`OPCODE_ASSIGN_POP, NULL, NULL, NULL, `lidx_sfxexpr[1][2], NULL, NULL]
      ENDIF
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx_sfxexpr[0])
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      IF `lidx_expr[0] != `length(`lidxs)-1:
        return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"POP", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
      ENDIF
      return [`OPCODE_ASSIGN_POP, NULL, NULL, NULL, `lidx_sfxexpr[1][2], `lidx_expr[1], NULL]
    ENDIF
    VAR `vvar = `lexer.`tokenExtra(`tokens[`lidxs[0]])
    VAR `vmod
    VAR `indexof_csvar
    IF `vvar[0] != "!":
      `vmod = NULL
    ELSE:
      `indexof_csvar = `indexof(`vvar, "@")
      IF `indexof_csvar < 0:
        `vmod = ""
        `vvar = `substring(`vvar, 1, `length(`vvar))
      ELSE:
        `vmod = `substring(`vvar, `indexof_csvar+1, `length(`vvar))
        `vvar = `substring(`vvar, 1, `indexof_csvar)
      ENDIF
    ENDIF
    IF `length(`lidxs) == 2:
      IF `isnull(`vmod):
        return [`OPCODE_ASSIGN_POP, NULL, NULL, NULL, [`OPCODE_VAR, `vvar], NULL, NULL]
      ELSE:
        return [`OPCODE_ASSIGN_POP, NULL, NULL, NULL, [`OPCODE_CSVAR, `vvar, `vmod], NULL, NULL]
      ENDIF
    ENDIF
    `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, 1)
    IF `length(`lidx_expr) == 1:
      return `lidx_expr[0]
    ENDIF
    IF `lidx_expr[0] != `length(`lidxs)-1:
      return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"POP", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]
    ENDIF
    IF `isnull(`vmod):
      return [`OPCODE_ASSIGN_POP, NULL, NULL, NULL, [`OPCODE_VAR, `vvar], `lidx_expr[1], NULL]
    ELSE:
      return [`OPCODE_ASSIGN_POP, NULL, NULL, NULL, [`OPCODE_CSVAR, `vvar, `vmod], `lidx_expr[1], NULL]
    ENDIF

  METHOD `_parseUnqueue(`tokens `lidxs `lidx_sfxexpr):
    IF `not(`isnull(`lidx_sfxexpr)):
      IF `lidx_sfxexpr[0] != `length(`lidxs)-1:
        return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"UNQUEUE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_sfxexpr[0]]]), []]
      ENDIF
      return [`OPCODE_ASSIGN_UNQUEUE, NULL, NULL, NULL, `lidx_sfxexpr[1][2], NULL]
    ENDIF
    IF `length(`lidxs) != 2:
      return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"UNQUEUE", `lexer.`tokenColumn(`tokens[`lidxs[1]]), []]
    ENDIF
    VAR `vvar = `lexer.`tokenExtra(`tokens[`lidxs[0]])
    VAR `vmod
    VAR `indexof_csvar
    IF `vvar[0] != "!":
      `vmod = NULL
    ELSE:
      `indexof_csvar = `indexof(`vvar, "@")
      IF `indexof_csvar < 0:
        `vmod = ""
        `vvar = `substring(`vvar, 1, `length(`vvar))
      ELSE:
        `vmod = `substring(`vvar, `indexof_csvar+1, `length(`vvar))
        `vvar = `substring(`vvar, 1, `indexof_csvar)
      ENDIF
    ENDIF
    IF `isnull(`vmod):
      return [`OPCODE_ASSIGN_UNQUEUE, NULL, NULL, NULL, [`OPCODE_VAR, `vvar], NULL]
    ELSE:
      return [`OPCODE_ASSIGN_UNQUEUE, NULL, NULL, NULL, [`OPCODE_CSVAR, `vvar, `vmod], NULL]
    ENDIF

  METHOD `_parseUnassign(`tokens `lidxs):
    IF `lexer.`tokenId(`tokens[`lidxs[1]]) != `key_token_NEWLINE:
      return [`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"TOKEN"+" "+"AFTER"+" "+"UNASSIGN", `lexer.`tokenColumn(`tokens[`lidxs[1]]), []]
    ENDIF
    VAR `vvar = `lexer.`tokenExtra(`tokens[`lidxs[0]])
    IF `vvar[0] != "!":
      return [`OPCODE_UNASSIGN, NULL, `vvar]
    ENDIF
    VAR `vmod
    VAR `indexof_csvar = `indexof(`vvar, "@")
    IF `indexof_csvar < 0:
      `vmod = ""
      `vvar = `substring(`vvar, 1, `length(`vvar))
    ELSE:
      `vmod = `substring(`vvar, `indexof_csvar+1, `length(`vvar))
      `vvar = `substring(`vvar, 1, `indexof_csvar)
    ENDIF
    return [`OPCODE_UNASSIGN_CSVAR, NULL, `vvar, `vmod]

  METHOD `_parseDebugl(`tokens `lidxs):
    IF `length(`lidxs) <= 2:
      return [`OPCODE_ERROR, NULL, "EXPECTED"+" "+"STRING"+" "+"OR"+" "+"EXPRESSION"+" "+"AFTER"+" "+"DEBUGL", `lexer.`tokenColumn(`tokens[`lidxs[1]]), []]
    ENDIF
    VAR `debugl_message = []
    VAR `lidx_expr
    VAR `j = 1
    WHILE `j < `length(`lidxs)-1:
      IF `lexer.`tokenId(`tokens[`lidxs[`j]]) == `key_token_STRING:
        `push(`debugl_message, [`OPCODE_STRING, `lexer.`tokenExtra(`tokens[`lidxs[`j]])])
        `j += 1
        continue
      ENDIF
      `lidx_expr = THIS.`_parseLogicalExpression(`tokens, `lidxs, `j)
      IF `length(`lidx_expr) != 1:
        `push(`debugl_message, `lidx_expr[1])
        `j = `lidx_expr[0]
        continue
      ENDIF
      `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `j)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr[0]
      ENDIF
      `push(`debugl_message, `lidx_expr[1])
      `j = `lidx_expr[0]
    ENDWHILE
    return [`OPCODE_DEBUGL, NULL, `debugl_message]

  METHOD `_parseLogicalExpression(`tokens `lidxs `lidx):
    VAR `terms = []
    VAR `lidx_term = THIS.`_parseLogicalTerm(`tokens, `lidxs, `lidx)
    IF `length(`lidx_term) == 1:
      return `lidx_term
    ENDIF
    `push(`terms, `lidx_term[1])
    `lidx = `lidx_term[0]
    WHILE `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_OR:
      `lidx_term = THIS.`_parseLogicalTerm(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_term) == 1:
        return `lidx_term
      ENDIF
      `push(`terms, `lidx_term[1])
      `lidx = `lidx_term[0]
    ENDWHILE
    VAR `logical_expression = TERNARY{`length(`terms) == 1}{`terms[0]}{[`OPCODE_OR, `terms]}
    return [`lidx, `logical_expression]

  METHOD `_parseLogicalTerm(`tokens `lidxs `lidx):
    VAR `factors = []
    VAR `lidx_factor = THIS.`_parseLogicalFactor(`tokens, `lidxs, `lidx)
    IF `length(`lidx_factor) == 1:
      return `lidx_factor
    ENDIF
    `push(`factors, `lidx_factor[1])
    `lidx = `lidx_factor[0]
    WHILE `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_AND:
      `lidx_factor = THIS.`_parseLogicalFactor(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_factor) == 1:
        return `lidx_factor
      ENDIF
      `push(`factors, `lidx_factor[1])
      `lidx = `lidx_factor[0]
    ENDWHILE
    VAR `logical_term = TERNARY{`length(`factors) == 1}{`factors[0]}{[`OPCODE_AND, `factors]}
    return [`lidx, `logical_term]

  METHOD `_parseLogicalFactor(`tokens `lidxs `lidx):
    VAR `logical_factor
    VAR `lidx_factor
    VAR `lidx_logexpr
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_NOT:
      `lidx_factor = THIS.`_parseLogicalFactor(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_factor) == 1:
        return `lidx_factor
      ENDIF
      IF `lidx_factor[1][0] == `OPCODE_NOT:
        `logical_factor = `lidx_factor[1][1]
      ELSIF `lidx_factor[1][0] == `OPCODE_EQ:
        `logical_factor = [`OPCODE_NE, `lidx_factor[1][1], `lidx_factor[1][2]]
      ELSIF `lidx_factor[1][0] == `OPCODE_NE:
        `logical_factor = [`OPCODE_EQ, `lidx_factor[1][1], `lidx_factor[1][2]]
      ELSIF `lidx_factor[1][0] == `OPCODE_LT:
        `logical_factor = [`OPCODE_GE, `lidx_factor[1][1], `lidx_factor[1][2]]
      ELSIF `lidx_factor[1][0] == `OPCODE_LE:
        `logical_factor = [`OPCODE_GT, `lidx_factor[1][1], `lidx_factor[1][2]]
      ELSIF `lidx_factor[1][0] == `OPCODE_GT:
        `logical_factor = [`OPCODE_LE, `lidx_factor[1][1], `lidx_factor[1][2]]
      ELSIF `lidx_factor[1][0] == `OPCODE_GE:
        `logical_factor = [`OPCODE_LT, `lidx_factor[1][1], `lidx_factor[1][2]]
      ELSIF `lidx_factor[1][0] == `OPCODE_IS_VAR:
        `logical_factor = [`OPCODE_IS_NOT_VAR, `lidx_factor[1][1], `lidx_factor[1][2]]
      ELSIF `lidx_factor[1][0] == `OPCODE_IS_NOT_VAR:
        `logical_factor = [`OPCODE_IS_VAR, `lidx_factor[1][1], `lidx_factor[1][2]]
      ELSIF `lidx_factor[1][0] == `OPCODE_IS_CSVAR:
        `logical_factor = [`OPCODE_IS_NOT_CSVAR, `lidx_factor[1][1], `lidx_factor[1][2]]
      ELSIF `lidx_factor[1][0] == `OPCODE_IS_NOT_CSVAR:
        `logical_factor = [`OPCODE_IS_CSVAR, `lidx_factor[1][1], `lidx_factor[1][2]]
      ELSE:
        `logical_factor = [`OPCODE_NOT, `lidx_factor[1]]
      ENDIF
      return [`lidx_factor[0], `logical_factor]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_LPAR:
      `lidx_logexpr = THIS.`_parseLogicalExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_logexpr) == 1:
        return `lidx_logexpr
      ENDIF
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx_logexpr[0]]]) == `key_token_RPAR:
        return [`lidx_logexpr[0]+1, `lidx_logexpr[1]]
      ENDIF
      return [[`OPCODE_ERROR, NULL, "EXPECTED"+" "+"RPAR"+" "+"IN"+" "+"LOGICAL"+" "+"FACTOR", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_logexpr[0]]]), []]]
    ENDIF
    return THIS.`_parseRelationalExpression(`tokens, `lidxs, `lidx)

  METHOD `_parseRelationalExpression(`tokens `lidxs `lidx):
    VAR `rel_op_opcode
    IF (`lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_IVAR) AND ((`lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_IS) OR (`lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_IS_NOT)):
      IF (`lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_NUMBER) OR (`lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_LIST) OR (`lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_EMPTY) OR (`lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_UNDEFINED):
        return [`lidx+3, [TERNARY{`lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_IS}{`OPCODE_IS_VAR}{`OPCODE_IS_NOT_VAR}, [`OPCODE_VAR, `lexer.`tokenExtra(`tokens[`lidxs[`lidx]])], `lexer.`tokenId(`tokens[`lidxs[`lidx+2]])]]
      ENDIF
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_PROCEDURE:
        `rel_op_opcode = TERNARY{`lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_IS}{`OPCODE_NE}{`OPCODE_EQ}
        return [`lidx+3, [`rel_op_opcode, [`OPCODE_NUMBER, 0], [`OPCODE_NUMBER, 0]]]
      ENDIF
      return [[`OPCODE_ERROR, NULL, "EXPECTED"+" "+"TYPE"+" "+"IN"+" "+"RELATIONAL"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+2]]), []]]
    ENDIF
    IF (`lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_EVAR) AND ((`lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_IS) OR (`lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_IS_NOT)):
      IF (`lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_NUMBER) OR (`lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_LIST) OR (`lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_EMPTY) OR (`lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_PROCEDURE) OR (`lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_UNDEFINED):
        return [`lidx+3, [TERNARY{`lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_IS}{`OPCODE_IS_VAR}{`OPCODE_IS_NOT_VAR}, [`OPCODE_QUALVAR, `lexer.`tokenExtra(`tokens[`lidxs[`lidx]])], `lexer.`tokenId(`tokens[`lidxs[`lidx+2]])]]
      ENDIF
      return [[`OPCODE_ERROR, NULL, "EXPECTED"+" "+"TYPE"+" "+"IN"+" "+"RELATIONAL"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+2]]), []]]
    ENDIF
    VAR `vvar
    VAR `vmod
    VAR `indexof_csvar
    IF (`lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_CSVAR) AND ((`lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_IS) OR (`lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_IS_NOT)):
      `vvar = `lexer.`tokenExtra(`tokens[`lidxs[`lidx]])
      `indexof_csvar = `indexof(`vvar, "@")
      IF `indexof_csvar < 0:
        `vmod = ""
      ELSE:
        `vmod = `substring(`vvar, `indexof_csvar+1, `length(`vvar))
        `vvar = `substring(`vvar, 0, `indexof_csvar)
      ENDIF
      IF (`lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_NUMBER) OR (`lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_LIST) OR (`lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_EMPTY) OR (`lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_UNDEFINED):
        return [`lidx+3, [TERNARY{`lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_IS}{`OPCODE_IS_CSVAR}{`OPCODE_IS_NOT_CSVAR}, [`OPCODE_CSVAR, `vvar, `vmod], `lexer.`tokenId(`tokens[`lidxs[`lidx+2]])]]
      ENDIF
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) == `key_token_PROCEDURE:
        `rel_op_opcode = TERNARY{`lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_IS}{`OPCODE_NE}{`OPCODE_EQ}
        return [`lidx+3, [`rel_op_opcode, [`OPCODE_NUMBER, 0], [`OPCODE_NUMBER, 0]]]
      ENDIF
      return [[`OPCODE_ERROR, NULL, "EXPECTED"+" "+"TYPE"+" "+"IN"+" "+"RELATIONAL"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx+2]]), []]]
    ENDIF
    VAR `lidx_sfxexpr = THIS.`_parseVarSuffix(`tokens, `lidxs, `lidx)
    IF (`length(`lidx_sfxexpr) > 1) AND (`lidx_sfxexpr[1][1] == `SUFFIX_) AND ((`lidx_sfxexpr[1][2][0] == `OPCODE_LIST_AT_VAR) OR (`lidx_sfxexpr[1][2][0] == `OPCODE_LIST_AT_QUALVAR)) AND ((`lexer.`tokenId(`tokens[`lidxs[`lidx_sfxexpr[0]]]) == `key_token_IS) OR (`lexer.`tokenId(`tokens[`lidxs[`lidx_sfxexpr[0]]]) == `key_token_IS_NOT)):
      IF (`lexer.`tokenId(`tokens[`lidxs[`lidx_sfxexpr[0]+1]]) == `key_token_NUMBER) OR (`lexer.`tokenId(`tokens[`lidxs[`lidx_sfxexpr[0]+1]]) == `key_token_LIST) OR (`lexer.`tokenId(`tokens[`lidxs[`lidx_sfxexpr[0]+1]]) == `key_token_EMPTY):
        return [`lidx_sfxexpr[0]+2, [TERNARY{`lexer.`tokenId(`tokens[`lidxs[`lidx_sfxexpr[0]]]) == `key_token_IS}{`OPCODE_IS_VAR}{`OPCODE_IS_NOT_VAR}, `lidx_sfxexpr[1][2], `lexer.`tokenId(`tokens[`lidxs[`lidx_sfxexpr[0]+1]])]]
      ENDIF
      return [[`OPCODE_ERROR, NULL, "EXPECTED"+" "+"DATATYPE"+" "+"IN"+" "+"RELATIONAL"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_sfxexpr[0]+1]]), []]]
    ENDIF
    IF (`length(`lidx_sfxexpr) > 1) AND (`lidx_sfxexpr[1][1] == `SUFFIX_) AND (`lidx_sfxexpr[1][2][0] == `OPCODE_LIST_AT_CSVAR) AND ((`lexer.`tokenId(`tokens[`lidxs[`lidx_sfxexpr[0]]]) == `key_token_IS) OR (`lexer.`tokenId(`tokens[`lidxs[`lidx_sfxexpr[0]]]) == `key_token_IS_NOT)):
      IF (`lexer.`tokenId(`tokens[`lidxs[`lidx_sfxexpr[0]+1]]) == `key_token_NUMBER) OR (`lexer.`tokenId(`tokens[`lidxs[`lidx_sfxexpr[0]+1]]) == `key_token_LIST) OR (`lexer.`tokenId(`tokens[`lidxs[`lidx_sfxexpr[0]+1]]) == `key_token_EMPTY):
        return [`lidx_sfxexpr[0]+2, [TERNARY{`lexer.`tokenId(`tokens[`lidxs[`lidx_sfxexpr[0]]]) == `key_token_IS}{`OPCODE_IS_CSVAR}{`OPCODE_IS_NOT_CSVAR}, `lidx_sfxexpr[1][2], `lexer.`tokenId(`tokens[`lidxs[`lidx_sfxexpr[0]+1]])]]
      ENDIF
      return [[`OPCODE_ERROR, NULL, "EXPECTED"+" "+"DATATYPE"+" "+"IN"+" "+"RELATIONAL"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_sfxexpr[0]+1]]), []]]
    ENDIF
    VAR `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx)
    IF `length(`lidx_expr) == 1:
      return `lidx_expr
    ENDIF
    VAR `rel_op_tokenid = `lexer.`tokenId(`tokens[`lidxs[`lidx_expr[0]]])
    IF `rel_op_tokenid == `key_token_EQ:
      `rel_op_opcode = `OPCODE_EQ
    ELSIF `rel_op_tokenid == `key_token_NE:
      `rel_op_opcode = `OPCODE_NE
    ELSIF `rel_op_tokenid == `key_token_LT:
      `rel_op_opcode = `OPCODE_LT
    ELSIF `rel_op_tokenid == `key_token_LE:
      `rel_op_opcode = `OPCODE_LE
    ELSIF `rel_op_tokenid == `key_token_GT:
      `rel_op_opcode = `OPCODE_GT
    ELSIF `rel_op_tokenid == `key_token_GE:
      `rel_op_opcode = `OPCODE_GE
    ELSE:
      return [[`OPCODE_ERROR, NULL, "EXPECTED"+" "+"OPERATOR"+" "+"IN"+" "+"RELATIONAL"+" "+"EXPRESSION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_expr[0]]]), []]]
    ENDIF
    VAR `lidx_expr2 = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx_expr[0]+1)
    IF `length(`lidx_expr2) == 1:
      return `lidx_expr2
    ENDIF
    return [`lidx_expr2[0], [`rel_op_opcode, `lidx_expr[1], `lidx_expr2[1]]]

  METHOD `_parseArithmeticOrListExpression(`tokens `lidxs `lidx):
    VAR `exprs
    VAR `lidx_expr
    VAR `idxexprs
    VAR `lidx_idxexpr
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_LSQR:
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_RSQR:
        IF `lexer.`tokenId(`tokens[`lidxs[`lidx+2]]) != `key_token_LSQR:
          return [`lidx+2, [`OPCODE_LIST, []]]
        ENDIF
        `lidx += 2
        `idxexprs = []
        WHILE `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_LSQR:
          `lidx_idxexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
          IF `length(`lidx_idxexpr) == 1:
            return `lidx_idxexpr
          ENDIF
          `lidx = `lidx_idxexpr[0]
          IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_RSQR:
            return [[`OPCODE_ERROR, NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST"+" "+"INDEX", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
          ENDIF
          `push(`idxexprs, `lidx_idxexpr[1])
          `lidx += 1
        ENDWHILE
        return [`lidx, [`OPCODE_LIST_AT_LIST, [], `idxexprs]]
      ENDIF
      `exprs = []
      `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr
      ENDIF
      `push(`exprs, `lidx_expr[1])
      `lidx = `lidx_expr[0]
      WHILE `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_COMMA:
        IF `lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_RSQR:
          `lidx += 1
          break
        ENDIF
        `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx+1)
        IF `length(`lidx_expr) == 1:
          return `lidx_expr
        ENDIF
        `push(`exprs, `lidx_expr[1])
        `lidx = `lidx_expr[0]
      ENDWHILE
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_RSQR:
        return [[`OPCODE_ERROR, NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
      ENDIF
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) != `key_token_LSQR:
        return [`lidx+1, [`OPCODE_LIST, `exprs]]
      ENDIF
      `lidx += 1
      `idxexprs = []
      WHILE `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_LSQR:
        `lidx_idxexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
        IF `length(`lidx_idxexpr) == 1:
          return `lidx_idxexpr
        ENDIF
        `lidx = `lidx_idxexpr[0]
        IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_RSQR:
          return [[`OPCODE_ERROR, NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST"+" "+"INDEX", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
        ENDIF
        `push(`idxexprs, `lidx_idxexpr[1])
        `lidx += 1
      ENDWHILE
      return [`lidx, [`OPCODE_LIST_AT_LIST, `exprs, `idxexprs]]
    ENDIF
    return THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx)

  METHOD `_parseArithmeticExpression(`tokens `lidxs `lidx):
    VAR `unary_op
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_MINUS:
      `unary_op = `UNARYOP_MINUS
      `lidx += 1
    ELSIF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_BIT_NOT:
      `unary_op = `UNARYOP_BIT_NOT
      `lidx += 1
    ELSIF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_PLUS:
      `unary_op = `UNARYOP_PLUS
      `lidx += 1
    ELSE:
      `unary_op = `UNARYOP_
    ENDIF
    VAR `lidx_term = THIS.`_parseArithmeticTerm(`tokens, `lidxs, `lidx)
    IF `length(`lidx_term) == 1:
      return `lidx_term
    ENDIF
    VAR `expr = `lidx_term[1]
    IF `unary_op == `UNARYOP_MINUS:
      `expr = [`OPCODE_NEG, `expr]
    ELSIF `unary_op == `UNARYOP_BIT_NOT:
      `expr = [`OPCODE_BIT_NOT, `expr]
    ENDIF
    `lidx = `lidx_term[0]
    VAR `add_op_tokenid
    VAR `add_op_opcode
    WHILE TRUE:
      `add_op_tokenid = `lexer.`tokenId(`tokens[`lidxs[`lidx]])
      IF `add_op_tokenid == `key_token_PLUS:
        `add_op_opcode = `OPCODE_PLUS
      ELSIF `add_op_tokenid == `key_token_MINUS:
        `add_op_opcode = `OPCODE_MINUS
      ELSIF `add_op_tokenid == `key_token_BIT_OR:
        `add_op_opcode = `OPCODE_BIT_OR
      ELSIF `add_op_tokenid == `key_token_BIT_XOR:
        `add_op_opcode = `OPCODE_BIT_XOR
      ELSE:
        break
      ENDIF
      `lidx_term = THIS.`_parseArithmeticTerm(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_term) == 1:
        return `lidx_term
      ENDIF
      `expr = [`add_op_opcode, `expr, `lidx_term[1]]
      `lidx = `lidx_term[0]
    ENDWHILE
    return [`lidx, `expr]

  METHOD `_parseArithmeticTerm(`tokens `lidxs `lidx):
    VAR `lidx_factor = THIS.`_parseArithmeticFactor(`tokens, `lidxs, `lidx)
    IF `length(`lidx_factor) == 1:
      return `lidx_factor
    ENDIF
    VAR `term = `lidx_factor[1]
    `lidx = `lidx_factor[0]
    VAR `mul_op_tokenid
    VAR `mul_op_opcode
    WHILE TRUE:
      `mul_op_tokenid = `lexer.`tokenId(`tokens[`lidxs[`lidx]])
      IF `mul_op_tokenid == `key_token_MUL:
        `mul_op_opcode = `OPCODE_MUL
      ELSIF `mul_op_tokenid == `key_token_DIV:
        `mul_op_opcode = `OPCODE_DIV
      ELSIF `mul_op_tokenid == `key_token_IDV:
        `mul_op_opcode = `OPCODE_IDV
      ELSIF `mul_op_tokenid == `key_token_MOD:
        `mul_op_opcode = `OPCODE_MOD
      ELSIF `mul_op_tokenid == `key_token_BIT_AND:
        `mul_op_opcode = `OPCODE_BIT_AND
      ELSIF `mul_op_tokenid == `key_token_BIT_SHL:
        `mul_op_opcode = `OPCODE_BIT_SHL
      ELSIF `mul_op_tokenid == `key_token_BIT_SHR:
        `mul_op_opcode = `OPCODE_BIT_SHR
      ELSE:
        break
      ENDIF
      `lidx_factor = THIS.`_parseArithmeticFactor(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_factor) == 1:
        return `lidx_factor
      ENDIF
      `term = [`mul_op_opcode, `term, `lidx_factor[1]]
      `lidx = `lidx_factor[0]
    ENDWHILE
    return [`lidx, `term]

  METHOD `_parseArithmeticFactor(`tokens `lidxs `lidx):
    VAR `lidx_ariexpr
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_LPAR:
      `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_ariexpr) == 1:
        return `lidx_ariexpr
      ENDIF
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx_ariexpr[0]]]) == `key_token_RPAR:
        return [`lidx_ariexpr[0]+1, `lidx_ariexpr[1]]
      ENDIF
      return [[`OPCODE_ERROR, NULL, "EXPECTED"+" "+"RPAR"+" "+"IN"+" "+"ARITHMETIC"+" "+"FACTOR", `lexer.`tokenColumn(`tokens[`lidxs[`lidx_ariexpr[0]]]), []]]
    ENDIF
    return THIS.`_parseBaseFactor(`tokens, `lidxs, `lidx)

  METHOD `_parseBaseFactor(`tokens `lidxs `lidx):
    VAR `lidx_ariexpr
    VAR `length_var
    VAR `size_var
    VAR `nsize_var
    VAR `lsize_var
    VAR `lidx_expr
    VAR `indexof_var
    VAR `mathsymb
    VAR `lidx_mathexprs
    VAR `vmod
    VAR `indexof_csvar
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_DECIMAL:
      return [`lidx+1, [`OPCODE_NUMBER, `lexer.`tokenExtra(`tokens[`lidxs[`lidx]])]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_BINARY:
      return [`lidx+1, [`OPCODE_NUMBER, `lexer.`tokenExtra(`tokens[`lidxs[`lidx]])]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_HEXADECIMAL:
      return [`lidx+1, [`OPCODE_NUMBER, `lexer.`tokenExtra(`tokens[`lidxs[`lidx]])]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_LENGTH:
      `length_var = `lexer.`tokenExtra(`tokens[`lidxs[`lidx]])
      IF `length_var[0] == "!":
        `indexof_csvar = `indexof(`length_var, "@")
        IF `indexof_csvar < 0:
          `vmod = ""
          `length_var = `substring(`length_var, 1, `length(`length_var))
        ELSE:
          `vmod = `substring(`length_var, `indexof_csvar+1, `length(`length_var))
          `length_var = `substring(`length_var, 1, `indexof_csvar)
        ENDIF
        return [`lidx+1, [`OPCODE_LENGTH_VAR, [`OPCODE_CSVAR, `length_var, `vmod]]]
      ELSIF `indexof(`length_var, ".") < 0:
        return [`lidx+1, [`OPCODE_LENGTH_VAR, [`OPCODE_VAR, `length_var]]]
      ELSE:
        return [`lidx+1, [`OPCODE_LENGTH_VAR, [`OPCODE_QUALVAR, `length_var]]]
      ENDIF
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_SIZE:
      `size_var = `lexer.`tokenExtra(`tokens[`lidxs[`lidx]])
      IF `size_var[0] == "!":
        `indexof_csvar = `indexof(`size_var, "@")
        IF `indexof_csvar < 0:
          `vmod = ""
          `size_var = `substring(`size_var, 1, `length(`size_var))
        ELSE:
          `vmod = `substring(`size_var, `indexof_csvar+1, `length(`size_var))
          `size_var = `substring(`size_var, 1, `indexof_csvar)
        ENDIF
        return [`lidx+1, [`OPCODE_SIZE_VAR, [`OPCODE_CSVAR, `size_var, `vmod]]]
      ELSIF `indexof(`size_var, ".") < 0:
        return [`lidx+1, [`OPCODE_SIZE_VAR, [`OPCODE_VAR, `size_var]]]
      ELSE:
        return [`lidx+1, [`OPCODE_SIZE_VAR, [`OPCODE_QUALVAR, `size_var]]]
      ENDIF
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_NSIZE:
      `nsize_var = `lexer.`tokenExtra(`tokens[`lidxs[`lidx]])
      IF `nsize_var[0] == "!":
        `indexof_csvar = `indexof(`nsize_var, "@")
        IF `indexof_csvar < 0:
          `vmod = ""
          `nsize_var = `substring(`nsize_var, 1, `length(`nsize_var))
        ELSE:
          `vmod = `substring(`nsize_var, `indexof_csvar+1, `length(`nsize_var))
          `nsize_var = `substring(`nsize_var, 1, `indexof_csvar)
        ENDIF
        return [`lidx+1, [`OPCODE_NSIZE_VAR, [`OPCODE_CSVAR, `nsize_var, `vmod]]]
      ELSIF `indexof(`nsize_var, ".") < 0:
        return [`lidx+1, [`OPCODE_NSIZE_VAR, [`OPCODE_VAR, `nsize_var]]]
      ELSE:
        return [`lidx+1, [`OPCODE_NSIZE_VAR, [`OPCODE_QUALVAR, `nsize_var]]]
      ENDIF
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_LSIZE:
      `lsize_var = `lexer.`tokenExtra(`tokens[`lidxs[`lidx]])
      IF `lsize_var[0] == "!":
        `indexof_csvar = `indexof(`lsize_var, "@")
        IF `indexof_csvar < 0:
          `vmod = ""
          `lsize_var = `substring(`lsize_var, 1, `length(`lsize_var))
        ELSE:
          `vmod = `substring(`lsize_var, `indexof_csvar+1, `length(`lsize_var))
          `lsize_var = `substring(`lsize_var, 1, `indexof_csvar)
        ENDIF
        return [`lidx+1, [`OPCODE_LSIZE_VAR, [`OPCODE_CSVAR, `lsize_var, `vmod]]]
      ELSIF `indexof(`lsize_var, ".") < 0:
        return [`lidx+1, [`OPCODE_LSIZE_VAR, [`OPCODE_VAR, `lsize_var]]]
      ELSE:
        return [`lidx+1, [`OPCODE_LSIZE_VAR, [`OPCODE_QUALVAR, `lsize_var]]]
      ENDIF
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_INDEXOF:
      `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr
      ENDIF
      `indexof_var = `lexer.`tokenExtra(`tokens[`lidxs[`lidx]])
      `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx_expr[0])
      IF `indexof_var[0] == "!":
        `indexof_csvar = `indexof(`indexof_var, "@")
        IF `indexof_csvar < 0:
          `vmod = ""
          `indexof_var = `substring(`indexof_var, 1, `length(`indexof_var))
        ELSE:
          `vmod = `substring(`indexof_var, `indexof_csvar+1, `length(`indexof_var))
          `indexof_var = `substring(`indexof_var, 1, `indexof_csvar)
        ENDIF
        IF `length(`lidx_ariexpr) == 1:
          return [`lidx_expr[0], [`OPCODE_INDEXOF_VAR, [`OPCODE_CSVAR, `indexof_var, `vmod], `lidx_expr[1], [`OPCODE_NUMBER, 0]]]
        ENDIF
        return [`lidx_ariexpr[0], [`OPCODE_INDEXOF_VAR, [`OPCODE_CSVAR, `indexof_var, `vmod], `lidx_expr[1], `lidx_ariexpr[1]]]
      ELSIF `indexof(`indexof_var, ".") < 0:
        IF `length(`lidx_ariexpr) == 1:
          return [`lidx_expr[0], [`OPCODE_INDEXOF_VAR, [`OPCODE_VAR, `indexof_var], `lidx_expr[1], [`OPCODE_NUMBER, 0]]]
        ENDIF
        return [`lidx_ariexpr[0], [`OPCODE_INDEXOF_VAR, [`OPCODE_VAR, `indexof_var], `lidx_expr[1], `lidx_ariexpr[1]]]
      ELSE:
        IF `length(`lidx_ariexpr) == 1:
          return [`lidx_expr[0], [`OPCODE_INDEXOF_VAR, [`OPCODE_QUALVAR, `indexof_var], `lidx_expr[1], [`OPCODE_NUMBER, 0]]]
        ENDIF
        return [`lidx_ariexpr[0], [`OPCODE_INDEXOF_VAR, [`OPCODE_QUALVAR, `indexof_var], `lidx_expr[1], `lidx_ariexpr[1]]]
      ENDIF
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_MATH_ABS:
      `lidx_mathexprs = THIS.`_parseMathArith(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_mathexprs) == 1:
        return `lidx_mathexprs
      ENDIF
      IF `length(`lidx_mathexprs[1]) != 1:
        return [[`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"MATH"+" "+"FUNCTION"+" "+"ARITY", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
      ENDIF
      return [`lidx_mathexprs[0], [`OPCODE_MATH_ABS, `lidx_mathexprs[1]]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_MATH_ACOS:
      `lidx_mathexprs = THIS.`_parseMathArith(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_mathexprs) == 1:
        return `lidx_mathexprs
      ENDIF
      IF `length(`lidx_mathexprs[1]) != 1:
        return [[`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"MATH"+" "+"FUNCTION"+" "+"ARITY", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
      ENDIF
      return [`lidx_mathexprs[0], [`OPCODE_MATH_ACOS, `lidx_mathexprs[1]]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_MATH_ASIN:
      `lidx_mathexprs = THIS.`_parseMathArith(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_mathexprs) == 1:
        return `lidx_mathexprs
      ENDIF
      IF `length(`lidx_mathexprs[1]) != 1:
        return [[`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"MATH"+" "+"FUNCTION"+" "+"ARITY", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
      ENDIF
      return [`lidx_mathexprs[0], [`OPCODE_MATH_ASIN, `lidx_mathexprs[1]]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_MATH_ATAN:
      `lidx_mathexprs = THIS.`_parseMathArith(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_mathexprs) == 1:
        return `lidx_mathexprs
      ENDIF
      IF `length(`lidx_mathexprs[1]) != 1:
        return [[`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"MATH"+" "+"FUNCTION"+" "+"ARITY", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
      ENDIF
      return [`lidx_mathexprs[0], [`OPCODE_MATH_ATAN, `lidx_mathexprs[1]]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_MATH_ATAN2:
      `lidx_mathexprs = THIS.`_parseMathArith(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_mathexprs) == 1:
        return `lidx_mathexprs
      ENDIF
      IF `length(`lidx_mathexprs[1]) != 2:
        return [[`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"MATH"+" "+"FUNCTION"+" "+"ARITY", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
      ENDIF
      return [`lidx_mathexprs[0], [`OPCODE_MATH_ATAN2, `lidx_mathexprs[1]]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_MATH_CEIL:
      `lidx_mathexprs = THIS.`_parseMathArith(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_mathexprs) == 1:
        return `lidx_mathexprs
      ENDIF
      IF `length(`lidx_mathexprs[1]) != 1:
        return [[`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"MATH"+" "+"FUNCTION"+" "+"ARITY", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
      ENDIF
      return [`lidx_mathexprs[0], [`OPCODE_MATH_CEIL, `lidx_mathexprs[1]]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_MATH_COS:
      `lidx_mathexprs = THIS.`_parseMathArith(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_mathexprs) == 1:
        return `lidx_mathexprs
      ENDIF
      IF `length(`lidx_mathexprs[1]) != 1:
        return [[`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"MATH"+" "+"FUNCTION"+" "+"ARITY", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
      ENDIF
      return [`lidx_mathexprs[0], [`OPCODE_MATH_COS, `lidx_mathexprs[1]]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_MATH_E:
      return [`lidx+1, [`OPCODE_NUMBER, `fp[0].E()]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_MATH_EXP:
      `lidx_mathexprs = THIS.`_parseMathArith(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_mathexprs) == 1:
        return `lidx_mathexprs
      ENDIF
      IF `length(`lidx_mathexprs[1]) != 1:
        return [[`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"MATH"+" "+"FUNCTION"+" "+"ARITY", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
      ENDIF
      return [`lidx_mathexprs[0], [`OPCODE_MATH_EXP, `lidx_mathexprs[1]]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_MATH_EXP2:
      `lidx_mathexprs = THIS.`_parseMathArith(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_mathexprs) == 1:
        return `lidx_mathexprs
      ENDIF
      IF `length(`lidx_mathexprs[1]) != 1:
        return [[`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"MATH"+" "+"FUNCTION"+" "+"ARITY", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
      ENDIF
      return [`lidx_mathexprs[0], [`OPCODE_MATH_EXP2, `lidx_mathexprs[1]]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_MATH_FLOOR:
      `lidx_mathexprs = THIS.`_parseMathArith(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_mathexprs) == 1:
        return `lidx_mathexprs
      ENDIF
      IF `length(`lidx_mathexprs[1]) != 1:
        return [[`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"MATH"+" "+"FUNCTION"+" "+"ARITY", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
      ENDIF
      return [`lidx_mathexprs[0], [`OPCODE_MATH_FLOOR, `lidx_mathexprs[1]]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_MATH_LOG:
      `lidx_mathexprs = THIS.`_parseMathArith(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_mathexprs) == 1:
        return `lidx_mathexprs
      ENDIF
      IF `length(`lidx_mathexprs[1]) != 1:
        return [[`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"MATH"+" "+"FUNCTION"+" "+"ARITY", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
      ENDIF
      return [`lidx_mathexprs[0], [`OPCODE_MATH_LOG, `lidx_mathexprs[1]]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_MATH_LOG2:
      `lidx_mathexprs = THIS.`_parseMathArith(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_mathexprs) == 1:
        return `lidx_mathexprs
      ENDIF
      IF `length(`lidx_mathexprs[1]) != 1:
        return [[`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"MATH"+" "+"FUNCTION"+" "+"ARITY", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
      ENDIF
      return [`lidx_mathexprs[0], [`OPCODE_MATH_LOG2, `lidx_mathexprs[1]]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_MATH_MAX:
      `lidx_mathexprs = THIS.`_parseMathArith(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_mathexprs) == 1:
        return `lidx_mathexprs
      ENDIF
      IF `length(`lidx_mathexprs[1]) != 2:
        return [[`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"MATH"+" "+"FUNCTION"+" "+"ARITY", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
      ENDIF
      return [`lidx_mathexprs[0], [`OPCODE_MATH_MAX, `lidx_mathexprs[1]]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_MATH_MIN:
      `lidx_mathexprs = THIS.`_parseMathArith(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_mathexprs) == 1:
        return `lidx_mathexprs
      ENDIF
      IF `length(`lidx_mathexprs[1]) != 2:
        return [[`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"MATH"+" "+"FUNCTION"+" "+"ARITY", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
      ENDIF
      return [`lidx_mathexprs[0], [`OPCODE_MATH_MIN, `lidx_mathexprs[1]]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_MATH_PI:
      return [`lidx+1, [`OPCODE_NUMBER, `fp[0].PI()]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_MATH_POW:
      `lidx_mathexprs = THIS.`_parseMathArith(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_mathexprs) == 1:
        return `lidx_mathexprs
      ENDIF
      IF `length(`lidx_mathexprs[1]) != 2:
        return [[`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"MATH"+" "+"FUNCTION"+" "+"ARITY", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
      ENDIF
      return [`lidx_mathexprs[0], [`OPCODE_MATH_POW, `lidx_mathexprs[1]]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_MATH_ROUND:
      `lidx_mathexprs = THIS.`_parseMathArith(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_mathexprs) == 1:
        return `lidx_mathexprs
      ENDIF
      IF `length(`lidx_mathexprs[1]) != 1:
        return [[`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"MATH"+" "+"FUNCTION"+" "+"ARITY", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
      ENDIF
      return [`lidx_mathexprs[0], [`OPCODE_MATH_ROUND, `lidx_mathexprs[1]]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_MATH_SIGN:
      `lidx_mathexprs = THIS.`_parseMathArith(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_mathexprs) == 1:
        return `lidx_mathexprs
      ENDIF
      IF `length(`lidx_mathexprs[1]) != 1:
        return [[`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"MATH"+" "+"FUNCTION"+" "+"ARITY", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
      ENDIF
      return [`lidx_mathexprs[0], [`OPCODE_MATH_SIGN, `lidx_mathexprs[1]]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_MATH_SIN:
      `lidx_mathexprs = THIS.`_parseMathArith(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_mathexprs) == 1:
        return `lidx_mathexprs
      ENDIF
      IF `length(`lidx_mathexprs[1]) != 1:
        return [[`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"MATH"+" "+"FUNCTION"+" "+"ARITY", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
      ENDIF
      return [`lidx_mathexprs[0], [`OPCODE_MATH_SIN, `lidx_mathexprs[1]]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_MATH_SQRT:
      `lidx_mathexprs = THIS.`_parseMathArith(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_mathexprs) == 1:
        return `lidx_mathexprs
      ENDIF
      IF `length(`lidx_mathexprs[1]) != 1:
        return [[`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"MATH"+" "+"FUNCTION"+" "+"ARITY", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
      ENDIF
      return [`lidx_mathexprs[0], [`OPCODE_MATH_SQRT, `lidx_mathexprs[1]]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_MATH_TAN:
      `lidx_mathexprs = THIS.`_parseMathArith(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_mathexprs) == 1:
        return `lidx_mathexprs
      ENDIF
      IF `length(`lidx_mathexprs[1]) != 1:
        return [[`OPCODE_ERROR, NULL, "UNEXPECTED"+" "+"MATH"+" "+"FUNCTION"+" "+"ARITY", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
      ENDIF
      return [`lidx_mathexprs[0], [`OPCODE_MATH_TAN, `lidx_mathexprs[1]]]
    ENDIF
    VAR `lidx_sfxexpr = THIS.`_parseVarSuffix(`tokens, `lidxs, `lidx)
    IF (`length(`lidx_sfxexpr) > 1) AND ((`lidx_sfxexpr[1][1] == `SUFFIX_) OR (`lidx_sfxexpr[1][1] == `SUFFIX_LENGTH) OR (`lidx_sfxexpr[1][1] == `SUFFIX_SIZE) OR (`lidx_sfxexpr[1][1] == `SUFFIX_NSIZE) OR (`lidx_sfxexpr[1][1] == `SUFFIX_LSIZE) OR (`lidx_sfxexpr[1][1] == `SUFFIX_INDEXOF)):
      return [`lidx_sfxexpr[0], `lidx_sfxexpr[1][2]]
    ENDIF
    return [[`OPCODE_ERROR, NULL, "EXPECTED"+" "+"BASE"+" "+"FACTOR", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]

  METHOD `_parseMathArith(`tokens `lidxs `lidx):
    VAR `exprs
    VAR `lidx_expr
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_LPAR:
      return [[`OPCODE_ERROR, NULL, "EXPECTED"+" "+"LPAR"+" "+"AFTER"+" "+"MATH"+" "+"FUNCTION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_RPAR:
      return [`lidx+2, []]
    ENDIF
    `exprs = []
    `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
    IF `length(`lidx_expr) == 1:
      return `lidx_expr
    ENDIF
    `push(`exprs, `lidx_expr[1])
    `lidx = `lidx_expr[0]
    WHILE `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_COMMA:
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) == `key_token_RPAR:
        `lidx += 1
        break
      ENDIF
      `lidx_expr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
      IF `length(`lidx_expr) == 1:
        return `lidx_expr
      ENDIF
      `push(`exprs, `lidx_expr[1])
      `lidx = `lidx_expr[0]
    ENDWHILE
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_RPAR:
      return [[`OPCODE_ERROR, NULL, "EXPECTED"+" "+"RPAR"+" "+"AFTER"+" "+"MATH"+" "+"FUNCTION", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
    ENDIF
    return [`lidx+1, `exprs]

  METHOD `_parseVarSuffix(`tokens `lidxs `lidx):
    VAR `vvar
    VAR `exprs
    VAR `lidx_ariexpr
    VAR `suffix
    VAR `lidx_expr
    VAR `qualvar
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_IVAR:
      `vvar = `lexer.`tokenExtra(`tokens[`lidxs[`lidx]])
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) != `key_token_LSQR:
        return [`lidx+1, [`OPCODE_SUFFIX, `SUFFIX_, [`OPCODE_VAR, `vvar]]]
      ENDIF
      `lidx += 1
      `exprs = []
      WHILE `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_LSQR:
        `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
        IF `length(`lidx_ariexpr) == 1:
          return `lidx_ariexpr
        ENDIF
        `lidx = `lidx_ariexpr[0]
        IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_RSQR:
          return [[`OPCODE_ERROR, NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST"+" "+"INDEX", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
        ENDIF
        `push(`exprs, `lidx_ariexpr[1])
        `lidx += 1
      ENDWHILE
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_SUFFIX:
        return [`lidx, [`OPCODE_SUFFIX, `SUFFIX_, [`OPCODE_LIST_AT_VAR, `vvar, `exprs]]]
      ENDIF
      `suffix = `lexer.`tokenStringToId(`lexer.`tokenExtra(`tokens[`lidxs[`lidx]]))
      IF `suffix == `key_token_LENGTH:
        return [`lidx+1, [`OPCODE_SUFFIX, `SUFFIX_LENGTH, [`OPCODE_LENGTH_VAR, [`OPCODE_LIST_AT_VAR, `vvar, `exprs]]]]
      ELSIF `suffix == `key_token_SIZE:
        return [`lidx+1, [`OPCODE_SUFFIX, `SUFFIX_SIZE, [`OPCODE_SIZE_VAR, [`OPCODE_LIST_AT_VAR, `vvar, `exprs]]]]
      ELSIF `suffix == `key_token_NSIZE:
        return [`lidx+1, [`OPCODE_SUFFIX, `SUFFIX_NSIZE, [`OPCODE_NSIZE_VAR, [`OPCODE_LIST_AT_VAR, `vvar, `exprs]]]]
      ELSIF `suffix == `key_token_LSIZE:
        return [`lidx+1, [`OPCODE_SUFFIX, `SUFFIX_LSIZE, [`OPCODE_LSIZE_VAR, [`OPCODE_LIST_AT_VAR, `vvar, `exprs]]]]
      ELSIF `suffix == `key_token_INDEXOF:
        `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx+1)
        IF `length(`lidx_expr) == 1:
          return `lidx_expr
        ENDIF
        `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx_expr[0])
        IF `length(`lidx_ariexpr) == 1:
          return [`lidx_expr[0], [`OPCODE_SUFFIX, `SUFFIX_INDEXOF, [`OPCODE_INDEXOF_VAR, [`OPCODE_LIST_AT_VAR, `vvar, `exprs], `lidx_expr[1], [`OPCODE_NUMBER, 0]]]]
        ENDIF
        return [`lidx_ariexpr[0], [`OPCODE_SUFFIX, `SUFFIX_INDEXOF, [`OPCODE_INDEXOF_VAR, [`OPCODE_LIST_AT_VAR, `vvar, `exprs], `lidx_expr[1], `lidx_ariexpr[1]]]]
      ENDIF
      IF `suffix == `key_token_PUSH:
        return [`lidx+1, [`OPCODE_SUFFIX, `SUFFIX_PUSH, [`OPCODE_LIST_AT_VAR, `vvar, `exprs]]]
      ELSIF `suffix == `key_token_QUEUE:
        return [`lidx+1, [`OPCODE_SUFFIX, `SUFFIX_QUEUE, [`OPCODE_LIST_AT_VAR, `vvar, `exprs]]]
      ELSIF `suffix == `key_token_POP:
        return [`lidx+1, [`OPCODE_SUFFIX, `SUFFIX_POP, [`OPCODE_LIST_AT_VAR, `vvar, `exprs]]]
      ELSIF `suffix == `key_token_UNQUEUE:
        return [`lidx+1, [`OPCODE_SUFFIX, `SUFFIX_UNQUEUE, [`OPCODE_LIST_AT_VAR, `vvar, `exprs]]]
      ENDIF
      return [`lidx, [`OPCODE_SUFFIX, `SUFFIX_, [`OPCODE_LIST_AT_VAR, `vvar, `exprs]]]
    ENDIF
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_EVAR:
      `qualvar = `lexer.`tokenExtra(`tokens[`lidxs[`lidx]])
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) != `key_token_LSQR:
        return [`lidx+1, [`OPCODE_SUFFIX, `SUFFIX_, [`OPCODE_QUALVAR, `qualvar]]]
      ENDIF
      `lidx += 1
      `exprs = []
      WHILE `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_LSQR:
        `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
        IF `length(`lidx_ariexpr) == 1:
          return `lidx_ariexpr
        ENDIF
        `lidx = `lidx_ariexpr[0]
        IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_RSQR:
          return [[`OPCODE_ERROR, NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST"+" "+"INDEX", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
        ENDIF
        `push(`exprs, `lidx_ariexpr[1])
        `lidx += 1
      ENDWHILE
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_SUFFIX:
        return [`lidx, [`OPCODE_SUFFIX, `SUFFIX_, [`OPCODE_LIST_AT_QUALVAR, `qualvar, `exprs]]]
      ENDIF
      `suffix = `lexer.`tokenStringToId(`lexer.`tokenExtra(`tokens[`lidxs[`lidx]]))
      IF `suffix == `key_token_LENGTH:
        return [`lidx+1, [`OPCODE_SUFFIX, `SUFFIX_LENGTH, [`OPCODE_LENGTH_VAR, [`OPCODE_LIST_AT_QUALVAR, `qualvar, `exprs]]]]
      ELSIF `suffix == `key_token_SIZE:
        return [`lidx+1, [`OPCODE_SUFFIX, `SUFFIX_SIZE, [`OPCODE_SIZE_VAR, [`OPCODE_LIST_AT_QUALVAR, `qualvar, `exprs]]]]
      ELSIF `suffix == `key_token_NSIZE:
        return [`lidx+1, [`OPCODE_SUFFIX, `SUFFIX_NSIZE, [`OPCODE_NSIZE_VAR, [`OPCODE_LIST_AT_QUALVAR, `qualvar, `exprs]]]]
      ELSIF `suffix == `key_token_LSIZE:
        return [`lidx+1, [`OPCODE_SUFFIX, `SUFFIX_LSIZE, [`OPCODE_LSIZE_VAR, [`OPCODE_LIST_AT_QUALVAR, `qualvar, `exprs]]]]
      ELSIF `suffix == `key_token_INDEXOF:
        `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx+1)
        IF `length(`lidx_expr) == 1:
          return `lidx_expr
        ENDIF
        `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx_expr[0])
        IF `length(`lidx_ariexpr) == 1:
          return [`lidx_expr[0], [`OPCODE_SUFFIX, `SUFFIX_INDEXOF, [`OPCODE_INDEXOF_VAR, [`OPCODE_LIST_AT_QUALVAR, `qualvar, `exprs], `lidx_expr[1], [`OPCODE_NUMBER, 0]]]]
        ENDIF
        return [`lidx_ariexpr[0], [`OPCODE_SUFFIX, `SUFFIX_INDEXOF, [`OPCODE_INDEXOF_VAR, [`OPCODE_LIST_AT_QUALVAR, `qualvar, `exprs], `lidx_expr[1], `lidx_ariexpr[1]]]]
      ENDIF
      return [`lidx, [`OPCODE_SUFFIX, `SUFFIX_, [`OPCODE_LIST_AT_QUALVAR, `qualvar, `exprs]]]
    ENDIF
    VAR `vmod
    VAR `indexof_csvar
    IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_CSVAR:
      `vvar = `lexer.`tokenExtra(`tokens[`lidxs[`lidx]])
      `indexof_csvar = `indexof(`vvar, "@")
      IF `indexof_csvar < 0:
        `vmod = ""
      ELSE:
        `vmod = `substring(`vvar, `indexof_csvar+1, `length(`vvar))
        `vvar = `substring(`vvar, 0, `indexof_csvar)
      ENDIF
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx+1]]) != `key_token_LSQR:
        return [`lidx+1, [`OPCODE_SUFFIX, `SUFFIX_, [`OPCODE_CSVAR, `vvar, `vmod]]]
      ENDIF
      `lidx += 1
      `exprs = []
      WHILE `lexer.`tokenId(`tokens[`lidxs[`lidx]]) == `key_token_LSQR:
        `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx+1)
        IF `length(`lidx_ariexpr) == 1:
          return `lidx_ariexpr
        ENDIF
        `lidx = `lidx_ariexpr[0]
        IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_RSQR:
          return [[`OPCODE_ERROR, NULL, "EXPECTED"+" "+"RSQR"+" "+"IN"+" "+"LIST"+" "+"INDEX", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]
        ENDIF
        `push(`exprs, `lidx_ariexpr[1])
        `lidx += 1
      ENDWHILE
      IF `lexer.`tokenId(`tokens[`lidxs[`lidx]]) != `key_token_SUFFIX:
        return [`lidx, [`OPCODE_SUFFIX, `SUFFIX_, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod]]]
      ENDIF
      `suffix = `lexer.`tokenStringToId(`lexer.`tokenExtra(`tokens[`lidxs[`lidx]]))
      IF `suffix == `key_token_LENGTH:
        return [`lidx+1, [`OPCODE_SUFFIX, `SUFFIX_LENGTH, [`OPCODE_LENGTH_VAR, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod]]]]
      ELSIF `suffix == `key_token_SIZE:
        return [`lidx+1, [`OPCODE_SUFFIX, `SUFFIX_SIZE, [`OPCODE_SIZE_VAR, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod]]]]
      ELSIF `suffix == `key_token_NSIZE:
        return [`lidx+1, [`OPCODE_SUFFIX, `SUFFIX_NSIZE, [`OPCODE_NSIZE_VAR, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod]]]]
      ELSIF `suffix == `key_token_LSIZE:
        return [`lidx+1, [`OPCODE_SUFFIX, `SUFFIX_LSIZE, [`OPCODE_LSIZE_VAR, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod]]]]
      ELSIF `suffix == `key_token_INDEXOF:
        `lidx_expr = THIS.`_parseArithmeticOrListExpression(`tokens, `lidxs, `lidx+1)
        IF `length(`lidx_expr) == 1:
          return `lidx_expr
        ENDIF
        `lidx_ariexpr = THIS.`_parseArithmeticExpression(`tokens, `lidxs, `lidx_expr[0])
        IF `length(`lidx_ariexpr) == 1:
          return [`lidx_expr[0], [`OPCODE_SUFFIX, `SUFFIX_INDEXOF, [`OPCODE_INDEXOF_VAR, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod], `lidx_expr[1], [`OPCODE_NUMBER, 0]]]]
        ENDIF
        return [`lidx_ariexpr[0], [`OPCODE_SUFFIX, `SUFFIX_INDEXOF, [`OPCODE_INDEXOF_VAR, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod], `lidx_expr[1], `lidx_ariexpr[1]]]]
      ENDIF
      IF `suffix == `key_token_PUSH:
        return [`lidx+1, [`OPCODE_SUFFIX, `SUFFIX_PUSH, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod]]]
      ELSIF `suffix == `key_token_QUEUE:
        return [`lidx+1, [`OPCODE_SUFFIX, `SUFFIX_QUEUE, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod]]]
      ELSIF `suffix == `key_token_POP:
        return [`lidx+1, [`OPCODE_SUFFIX, `SUFFIX_POP, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod]]]
      ELSIF `suffix == `key_token_UNQUEUE:
        return [`lidx+1, [`OPCODE_SUFFIX, `SUFFIX_UNQUEUE, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod]]]
      ENDIF
      return [`lidx, [`OPCODE_SUFFIX, `SUFFIX_, [`OPCODE_LIST_AT_CSVAR, `vvar, `exprs, `vmod]]]
    ENDIF
    return [[`OPCODE_ERROR, NULL, "EXPECTED"+" "+"VARIABLE", `lexer.`tokenColumn(`tokens[`lidxs[`lidx]]), []]]

ENDCLASS

VAR `parser = NEW `Parser()

VAR `UtilsEditorM_control_tokens = [`key_token_IF, `key_token_ELSIF, `key_token_ELSE, `key_token_ENDIF, `key_token_REPEAT, `key_token_ENDREP, `key_token_REPNEXT, `key_token_REPSTOP]
VAR `UtilsEditorM_indent_ignored = [`key_token_COMMENT, `key_token_NEWLINE, `key_token_ERROR]

CLASS `UtilsEditorM:

  METHOD_INIT():
    THIS.`_control_tokens_if = [`key_token_IF, `key_token_ELSIF, `key_token_ELSE, `key_token_ENDIF]
    THIS.`_control_tokens_repeat = [`key_token_REPEAT, `key_token_ENDREP]
    THIS.`_control_tokens_repstop = [`key_token_REPNEXT, `key_token_REPSTOP]
    VAR `indent_spaces = 1
    THIS.`_indent_stmts = {}
    THIS.`_indent_stmts[`key_token_IF] = [0, `indent_spaces]
    THIS.`_indent_stmts[`key_token_ELSIF] = [-`indent_spaces, `indent_spaces]
    THIS.`_indent_stmts[`key_token_ELSE] = [-`indent_spaces, `indent_spaces]
    THIS.`_indent_stmts[`key_token_ENDIF] = [-`indent_spaces, 0]
    THIS.`_indent_stmts[`key_token_REPEAT] = [0, `indent_spaces]
    THIS.`_indent_stmts[`key_token_ENDREP] = [-`indent_spaces, 0]

  METHOD `lineastLine(`line_ast):
    return `line_ast[0]

  METHOD `lineastTokens(`line_ast):
    return `line_ast[1]

  METHOD `lineastAst(`line_ast):
    return `line_ast[2]

  METHOD `lineastControl(`line_ast):
    IF `length(`line_ast) <= 3:
      return NULL
    ENDIF
    return `line_ast[3]

  METHOD `indentStmts(`token):
    IF `not(`token in THIS.`_indent_stmts):
      return [0, 0]
    ENDIF
    VAR `indent_stmt = THIS.`_indent_stmts[`token]
    return [`indent_stmt[0], `indent_stmt[1]]

  METHOD `mkControlSets(`lines_control `sets_control `error_control `lines_id `lines_ast):
    VAR `processed_indexes = []
    VAR `j1
    VAR `set_control_indexes
    VAR `sets_control_index
    VAR `set_control
    VAR `j2
    VAR `lnid_j
    VAR `token_indent_j
    VAR `line_ast_j
    VAR `control_node_j
    VAR `error_data
    VAR `error_lnid
    VAR `error_message
    VAR `error_line_ast
    VAR `error_control_node
    FORINCR `j1(0 `length(`lines_control)):
      IF `indexof(`processed_indexes, `j1) >= 0:
        continue
      ENDIF
      `set_control_indexes = THIS.`_extractControlSetIndexes(`j1, `lines_control)
      `sets_control_index = `length(`sets_control)
      `set_control = []
      FORINCR `j2(0 `length(`set_control_indexes)):
        `lnid_j = `lines_control[`set_control_indexes[`j2]][0]
        `token_indent_j = `lines_control[`set_control_indexes[`j2]][1]
        `push(`set_control, [`lnid_j, `token_indent_j])
        `line_ast_j = `lines_ast[`lnid_j]
        `control_node_j = [`set_control_indexes[`j2], `sets_control_index]
        `push(`line_ast_j, `control_node_j)
      ENDFOR
      `push(`sets_control, `set_control)
      `error_data = THIS.`_mkControlError(`set_control)
      `error_lnid = `error_data[0]
      `error_message = `error_data[1]
      IF `not(`isnull(`error_lnid)):
        THIS.`setInsertLineId(`error_lnid, `error_control, `lines_id)
        `error_line_ast = `lines_ast[`error_lnid]
        `error_control_node = THIS.`lineastControl(`error_line_ast)
        `push(`error_control_node, `error_message)
      ENDIF
      `processed_indexes = `concat(`processed_indexes, `set_control_indexes)
      IF `length(`processed_indexes) >= `length(`lines_control):
        IF `length(`processed_indexes) > `length(`lines_control):
          `warning("Prequel"+" "+"UtilsEditorM"+" "+"mkControlSets"+":"+" "+"unhandled"+" "+"value"+":", [`processed_indexes, `lines_control])
        ENDIF
        break
      ENDIF
    ENDFOR

  METHOD `_extractControlSetIndexes(`index `lines_control):
    VAR `line_control = `lines_control[`index]
    VAR `lnid = `line_control[0]
    VAR `token_indent = `line_control[1]
    VAR `indent = `line_control[2]
    VAR `set_control = [`index]
    VAR `last_token_indent
    VAR `j
    VAR `lnid_j
    VAR `token_indent_j
    VAR `indent_j
    VAR `min_indent_repstop
    `index += 1
    IF `index >= `length(`lines_control):
      return `set_control
    ENDIF
    IF `token_indent == `key_token_IF:
      `last_token_indent = `key_token_IF
      `j = `index
      WHILE `j < `length(`lines_control):
        `lnid_j = `lines_control[`j][0]
        `token_indent_j = `lines_control[`j][1]
        `indent_j = `lines_control[`j][2]
        IF `indent_j < `indent:
          break
        ENDIF
        IF `indent_j > `indent:
          `j += 1
          continue
        ENDIF
        IF `indexof(THIS.`_control_tokens_if, `token_indent_j) < 0:
          break
        ENDIF
        IF `token_indent_j == `key_token_IF:
          break
        ENDIF
        IF `token_indent_j == `key_token_ENDIF:
          `push(`set_control, `j)
          break
        ENDIF
        IF `last_token_indent == `key_token_ELSE:
          break
        ENDIF
        `push(`set_control, `j)
        `last_token_indent = `token_indent_j
        `j += 1
      ENDWHILE
    ELSIF `token_indent == `key_token_REPEAT:
      `min_indent_repstop = -1
      `j = `index
      WHILE `j < `length(`lines_control):
        `lnid_j = `lines_control[`j][0]
        `token_indent_j = `lines_control[`j][1]
        `indent_j = `lines_control[`j][2]
        IF `indent_j < `indent:
          break
        ENDIF
        IF `indent_j == `indent:
          IF `token_indent_j == `key_token_ENDREP:
            `push(`set_control, `j)
          ENDIF
          break
        ENDIF
        IF `token_indent_j == `key_token_REPEAT:
          IF (`min_indent_repstop < 0) OR (`min_indent_repstop > `indent_j):
            `min_indent_repstop = `indent_j
          ENDIF
          `j += 1
          continue
        ENDIF
        IF `indexof(THIS.`_control_tokens_repstop, `token_indent_j) < 0:
          IF `indent_j <= `min_indent_repstop:
            `min_indent_repstop = -1
          ENDIF
          `j += 1
          continue
        ENDIF
        IF (`min_indent_repstop >= 0) AND (`min_indent_repstop < `indent_j):
          `j += 1
          continue
        ENDIF
        `push(`set_control, `j)
        `j += 1
      ENDWHILE
    ENDIF
    return `set_control

  METHOD `_mkControlError(`set_control):
    VAR `error_lnid
    VAR `error_message
    IF `set_control[0][1] == `key_token_IF:
      IF `set_control[`length(`set_control)-1][1] == `key_token_ENDIF:
        return [NULL, NULL]
      ENDIF
      `error_lnid = `set_control[`length(`set_control)-1][0]
      IF `set_control[`length(`set_control)-1][1] == `key_token_IF:
        `error_message = "IF"+" "+"MISMATCHES"+" "+"ENDIF"
      ELSIF `set_control[`length(`set_control)-1][1] == `key_token_ELSIF:
        `error_message = "ELSIF"+" "+"MISMATCHES"+" "+"ENDIF"
      ELSE:
        `error_message = "ELSE"+" "+"MISMATCHES"+" "+"ENDIF"
      ENDIF
      return [`error_lnid, `error_message]
    ENDIF
    IF `set_control[0][1] == `key_token_REPEAT:
      IF `set_control[`length(`set_control)-1][1] == `key_token_ENDREP:
        return [NULL, NULL]
      ENDIF
      return [`set_control[0][0], "REPEAT"+" "+"MISMATCHES"+" "+"ENDREP"]
    ENDIF
    `error_lnid = `set_control[0][0]
    IF `set_control[0][1] == `key_token_ELSIF:
      `error_message = "ELSIF"+" "+"WITHOUT"+" "+"IF"
    ELSIF `set_control[0][1] == `key_token_ELSE:
      `error_message = "ELSE"+" "+"WITHOUT"+" "+"IF"
    ELSIF `set_control[0][1] == `key_token_ENDIF:
      `error_message = "ENDIF"+" "+"WITHOUT"+" "+"IF"
    ELSIF `set_control[0][1] == `key_token_REPNEXT:
      `error_message = "REPNEXT"+" "+"WITHOUT"+" "+"REPEAT"
    ELSIF `set_control[0][1] == `key_token_REPSTOP:
      `error_message = "REPSTOP"+" "+"WITHOUT"+" "+"REPEAT"
    ELSE:
      `error_message = "ENDREP"+" "+"WITHOUT"+" "+"REPEAT"
    ENDIF
    return [`error_lnid, `error_message]

  METHOD `setInsertLineId(`lnid `set_ `lines_id):
    VAR `index = `indexof(`set_, `lnid)
    IF `index >= 0:
      return
    ENDIF
    VAR `lnno = `indexof(`lines_id, `lnid)
    `index = 0
    VAR `j
    FORDECR `j(`length(`set_)-1 0):
      IF `lnno <= `indexof(`lines_id, `set_[`j]):
        continue
      ENDIF
      `index = `j+1
      break
    ENDFOR
    `poke(`set_, `index, `lnid)

  METHOD `setDeleteLineId(`lnid `set_):
    VAR `index = `indexof(`set_, `lnid)
    WHILE `index >= 0:
      `pick(`set_, `index)
      `index = `indexof(`set_, `lnid)
    ENDWHILE

ENDCLASS

VAR `utils_editor_m = NEW `UtilsEditorM()

CLASS `EditorM:

  METHOD_INIT(`source_code):
    THIS.`_lnids = NEW `ResourceIds()
    THIS.`_lines_id = []
    THIS.`setSourceCode(`source_code)

  METHOD `setSourceCode(`source_code):
    VAR `ast_node
    VAR `bptn_lnid
    VAR `indent
    VAR `indent_stmt
    VAR `is_breakpoint
    VAR `j
    VAR `j1
    VAR `line_indent
    VAR `lines
    VAR `lnid
    VAR `lnno
    VAR `token_indent
    VAR `tokens
    FORINCR `j(0 `length(THIS.`_lines_id)):
      `lnid = THIS.`_lines_id[`j]
      THIS.`_lnids.`free(`lnid)
    ENDFOR
    IF (`length(`source_code) > 0) AND (`source_code[`length(`source_code)-1] != `chr_lf):
      `source_code += `chr_lf
    ENDIF
    `source_code = `lexer.`normalize(`source_code)
    `lines = `split(`source_code, `chr_lf)
    `push(`lines, "")
    THIS.`_lines_id = []
    THIS.`_lines_ast = {}
    THIS.`_error_lines = []
    THIS.`_lines_indent = [[0, 0]]
    THIS.`_error_indents = []
    THIS.`_lines_control = []
    THIS.`_sets_control = []
    THIS.`_error_control = []
    THIS.`_cut_lines = []
    THIS.`_cut_lnno = -1
    THIS.`_breakpoints = []
    `is_breakpoint = FALSE
    FORINCR `j1(0 `length(`lines)-1):
      IF `lines[`j1] == "#pragma"+" "+"breakpoint":
        `is_breakpoint = TRUE
        continue
      ENDIF
      `lnid = THIS.`_lnids.`alloc()
      `lnno = `length(THIS.`_lines_id)
      `tokens = `lexer.`lexLine(`lines[`j1])
      `ast_node = `parser.`parseLine(`tokens)
      IF `not(`isnull(`ast_node)) AND (`ast_node[0] == `OPCODE_ERROR):
        `push(THIS.`_error_lines, `lnid)
      ENDIF
      `line_indent = THIS.`_lines_indent[`lnno]
      `indent = `length(`lexer.`tokenValue(`tokens[0]))
      `token_indent = `lexer.`tokenId(`tokens[1])
      IF `indexof(`UtilsEditorM_indent_ignored, `token_indent) >= 0:
        `push(THIS.`_lines_indent, [`line_indent[0], `line_indent[1]])
      ELSE:
        `indent_stmt = `utils_editor_m.`indentStmts(`token_indent)
        `push(THIS.`_lines_indent, [`indent, `indent_stmt[1]])
        IF `indent != `line_indent[0]+`line_indent[1]+`indent_stmt[0]:
          `push(THIS.`_error_indents, `lnid)
        ENDIF
      ENDIF
      `push(THIS.`_lines_id, `lnid)
      THIS.`_lines_ast[`lnid] = [`lines[`j1], `tokens, `ast_node]
      IF `indexof(`UtilsEditorM_control_tokens, `token_indent) >= 0:
        `push(THIS.`_lines_control, [`lnid, `token_indent, `indent])
      ENDIF
      IF `is_breakpoint:
        `push(THIS.`_breakpoints, `lnid)
        `is_breakpoint = FALSE
      ENDIF
    ENDFOR
    `unqueue(THIS.`_lines_indent)
    `utils_editor_m.`mkControlSets(THIS.`_lines_control, THIS.`_sets_control, THIS.`_error_control, THIS.`_lines_id, THIS.`_lines_ast)
    THIS.`_inactive_breakpoints = []
    FORINCR `j(0 `length(THIS.`_breakpoints)):
      `bptn_lnid = THIS.`_breakpoints[`j]
      IF `not(`isnull(`utils_editor_m.`lineastAst(THIS.`_lines_ast[`bptn_lnid]))) AND (`indexof(THIS.`_error_lines, `bptn_lnid) < 0) AND (`indexof(THIS.`_error_indents, `bptn_lnid) < 0) AND (`indexof(THIS.`_error_control, `bptn_lnid) < 0):
        continue
      ENDIF
      `push(THIS.`_inactive_breakpoints, `bptn_lnid)
    ENDFOR
    THIS.`_parser_error = THIS.`_mkTopError()
    THIS.`_entry_lnid = NULL
    THIS.`_is_compiled = FALSE

  METHOD `getSourceCode():
    VAR `source_code = ""
    VAR `j
    VAR `lnid
    VAR `line
    FORINCR `j(0 `length(THIS.`_lines_id)-1):
      `lnid = THIS.`_lines_id[`j]
      `line = `utils_editor_m.`lineastLine(THIS.`_lines_ast[`lnid])
      `source_code += `line+`chr_lf
    ENDFOR
    return `source_code

  METHOD `getLnnoCount():
    return (`length(THIS.`_lines_id)-1)

  METHOD `getTokens(`lnno):
    VAR `lnid = THIS.`_lines_id[`lnno]
    return `utils_editor_m.`lineastTokens(THIS.`_lines_ast[`lnid])

  METHOD `getParserError():
    return THIS.`_parser_error

  METHOD `getEntryLnno():
    IF `isnull(THIS.`_entry_lnid):
      return -1
    ENDIF
    return `indexof(THIS.`_lines_id, THIS.`_entry_lnid)

  METHOD `_mkTopError():
    VAR `error_lnid
    VAR `error_lnno
    VAR `terr_lnid
    VAR `terr_lnno
    VAR `terr_startcol
    VAR `terr_endcol
    VAR `terr_message
    VAR `tokens
    IF `length(THIS.`_error_lines) > 0:
      `terr_lnid = THIS.`_error_lines[0]
      `terr_lnno = `indexof(THIS.`_lines_id, `terr_lnid)
      `terr_startcol = `utils_editor_m.`lineastAst(THIS.`_lines_ast[`terr_lnid])[3]
      `terr_endcol = `terr_startcol
      `terr_message = `utils_editor_m.`lineastAst(THIS.`_lines_ast[`terr_lnid])[2]
      `tokens = `utils_editor_m.`lineastTokens(THIS.`_lines_ast[`terr_lnid])
      IF (`length(`tokens) >= 4) AND (`lexer.`tokenId(`tokens[`length(`tokens)-3]) == `key_token_ERROR):
        `terr_endcol = `terr_startcol+`length(`lexer.`tokenValue(`tokens[`length(`tokens)-3]))
      ENDIF
    ELSE:
      `terr_lnno = `length(THIS.`_lines_id)
    ENDIF
    IF `length(THIS.`_error_control) > 0:
      `error_lnid = THIS.`_error_control[0]
      `error_lnno = `indexof(THIS.`_lines_id, `error_lnid)
      IF `terr_lnno > `error_lnno:
        `terr_lnid = `error_lnid
        `terr_lnno = `error_lnno
        `tokens = `utils_editor_m.`lineastTokens(THIS.`_lines_ast[`terr_lnid])
        `terr_startcol = `length(`lexer.`tokenValue(`tokens[0]))
        `terr_endcol = `terr_startcol
        `terr_message = `utils_editor_m.`lineastControl(THIS.`_lines_ast[`terr_lnid])[2]
      ENDIF
    ENDIF
    IF `length(THIS.`_error_indents) > 0:
      `error_lnid = THIS.`_error_indents[0]
      `error_lnno = `indexof(THIS.`_lines_id, `error_lnid)
      IF `terr_lnno > `error_lnno:
        `terr_lnid = `error_lnid
        `terr_lnno = `error_lnno
        `tokens = `utils_editor_m.`lineastTokens(THIS.`_lines_ast[`terr_lnid])
        `terr_startcol = `length(`lexer.`tokenValue(`tokens[0]))
        `terr_endcol = `terr_startcol
        `terr_message = "INVALID"+" "+"INDENTATION"
      ENDIF
    ENDIF
    IF `terr_lnno >= `length(THIS.`_lines_id):
      return NULL
    ENDIF
    return [`terr_lnid, `terr_lnno, `terr_startcol, `terr_endcol, `terr_message]

  METHOD `getBreakpointsInfo():
    return [THIS.`_breakpoints, THIS.`_inactive_breakpoints]

  METHOD `hasBreakpoint(`lnno):
    VAR `lnid = THIS.`_lines_id[`lnno]
    return ((`indexof(THIS.`_breakpoints, `lnid) >= 0) AND (`indexof(THIS.`_inactive_breakpoints, `lnid) < 0))

  METHOD `setBreakpoint(`lnno):
    VAR `lnid = THIS.`_lines_id[`lnno]
    IF `indexof(THIS.`_breakpoints, `lnid) >= 0:
      return
    ENDIF
    `utils_editor_m.`setInsertLineId(`lnid, THIS.`_breakpoints, THIS.`_lines_id)
    IF `not(`isnull(`utils_editor_m.`lineastAst(THIS.`_lines_ast[`lnid]))) AND (`indexof(THIS.`_error_lines, `lnid) < 0) AND (`indexof(THIS.`_error_indents, `lnid) < 0) AND (`indexof(THIS.`_error_control, `lnid) < 0):
      return
    ENDIF
    `utils_editor_m.`setInsertLineId(`lnid, THIS.`_inactive_breakpoints, THIS.`_lines_id)

  METHOD `clearBreakpoint(`lnno):
    VAR `lnid = THIS.`_lines_id[`lnno]
    VAR `index = `indexof(THIS.`_breakpoints, `lnid)
    IF `index < 0:
      return
    ENDIF
    `pick(THIS.`_breakpoints, `index)
    `index = `indexof(THIS.`_inactive_breakpoints, `lnid)
    IF `index < 0:
      return
    ENDIF
    `pick(THIS.`_inactive_breakpoints, `index)

  METHOD `getLinesId():
    return THIS.`_lines_id

  METHOD `getLinesAst():
    return THIS.`_lines_ast

  METHOD `getEntryLnid():
    return THIS.`_entry_lnid

  METHOD `isCompiled():
    return THIS.`_is_compiled

  METHOD `compile():
    IF THIS.`_is_compiled:
      return
    ENDIF
    VAR `ast_node_endrep
    VAR `ast_node_if
    VAR `ast_node_j
    VAR `ast_node_prev_elsif_else
    VAR `ast_node_prev_if
    VAR `ast_node_repeat
    VAR `ast_node_repstop
    VAR `control_type_j_0
    VAR `j
    VAR `j1
    VAR `j2
    VAR `lnid_elsif_else
    VAR `lnid_endif
    VAR `lnid_endrep
    VAR `lnid_if
    VAR `lnid_j
    VAR `lnid_prev_elsif_else
    VAR `lnid_prev_if
    VAR `lnid_repeat
    VAR `lnid_repstop
    VAR `lnno_elsif_else
    VAR `lnno_prev_elsif_else
    VAR `prev_ast_node
    VAR `prev_lnid
    VAR `set_control_j
    VAR `type_if
    THIS.`_is_compiled = TRUE
    THIS.`_entry_lnid = NULL
    FORINCR `j(0 `length(THIS.`_lines_id)):
      `lnid_j = THIS.`_lines_id[`j]
      IF `isnull(`utils_editor_m.`lineastAst(THIS.`_lines_ast[`lnid_j])):
        continue
      ENDIF
      THIS.`_entry_lnid = `lnid_j
      break
    ENDFOR
    IF `isnull(THIS.`_entry_lnid):
      return
    ENDIF
    `prev_lnid = THIS.`_entry_lnid
    `prev_ast_node = `utils_editor_m.`lineastAst(THIS.`_lines_ast[`prev_lnid])
    VAR `start_j = `indexof(THIS.`_lines_id, THIS.`_entry_lnid)+1
    FORINCR `j(`start_j `length(THIS.`_lines_id)):
      `lnid_j = THIS.`_lines_id[`j]
      `ast_node_j = `utils_editor_m.`lineastAst(THIS.`_lines_ast[`lnid_j])
      IF `isnull(`ast_node_j):
        continue
      ENDIF
      `prev_ast_node[1] = `lnid_j
      `prev_lnid = `lnid_j
      `prev_ast_node = `ast_node_j
    ENDFOR
    `prev_ast_node[1] = NULL
    FORINCR `j1(0 `length(THIS.`_sets_control)):
      `set_control_j = THIS.`_sets_control[`j1]
      `control_type_j_0 = `set_control_j[0][1]
      IF `control_type_j_0 == `key_token_IF:
        `lnid_prev_if = `set_control_j[0][0]
        `ast_node_prev_if = `utils_editor_m.`lineastAst(THIS.`_lines_ast[`lnid_prev_if])
        FORINCR `j2(1 `length(`set_control_j)):
          `lnid_if  = `set_control_j[`j2][0]
          `ast_node_if = `utils_editor_m.`lineastAst(THIS.`_lines_ast[`lnid_if])
          `ast_node_prev_if[2] = `lnid_if
          `type_if = `set_control_j[`j2][1]
          IF (`type_if != `key_token_IF) AND (`type_if != `key_token_ELSIF):
            break
          ENDIF
          `lnid_prev_if = `lnid_if
          `ast_node_prev_if = `ast_node_if
        ENDFOR
        `lnid_endif = `set_control_j[`length(`set_control_j)-1][0]
        FORINCR `j2(1 `length(`set_control_j)-1):
          `lnid_elsif_else = `set_control_j[`j2][0]
          `lnno_elsif_else = `indexof(THIS.`_lines_id, `lnid_elsif_else)
          `lnno_prev_elsif_else = `lnno_elsif_else-1
          WHILE TRUE:
            `lnid_prev_elsif_else = THIS.`_lines_id[`lnno_prev_elsif_else]
            `ast_node_prev_elsif_else = `utils_editor_m.`lineastAst(THIS.`_lines_ast[`lnid_prev_elsif_else])
            IF `isnull(`ast_node_prev_elsif_else):
              `lnno_prev_elsif_else -= 1
              continue
            ENDIF
            IF `ast_node_prev_elsif_else[0] == `OPCODE_REPNEXT:
              break
            ELSIF `ast_node_prev_elsif_else[0] == `OPCODE_REPSTOP:
              break
            ENDIF
            `ast_node_prev_elsif_else[1] = `lnid_endif
            break
          ENDWHILE
        ENDFOR
      ELSE:
        `lnid_repeat = `set_control_j[0][0]
        `ast_node_repeat = `utils_editor_m.`lineastAst(THIS.`_lines_ast[`lnid_repeat])
        `lnid_endrep = `set_control_j[`length(`set_control_j)-1][0]
        `ast_node_endrep = `utils_editor_m.`lineastAst(THIS.`_lines_ast[`lnid_endrep])
        `ast_node_repeat[2] = `lnid_endrep
        `ast_node_endrep[2] = `lnid_repeat
        FORINCR `j2(1 `length(`set_control_j)-1):
          `lnid_repstop = `set_control_j[`j2][0]
          `ast_node_repstop = `utils_editor_m.`lineastAst(THIS.`_lines_ast[`lnid_repstop])
          `ast_node_repstop[1] = `lnid_endrep
        ENDFOR
      ENDIF
    ENDFOR

  METHOD `destroy():
    VAR `x = NULL

ENDCLASS

CLASS `Environment:

  METHOD_INIT():
    THIS.`reset()

  METHOD `reset():
    THIS.`_env = []

  METHOD `vars():
    VAR `vs = []
    VAR `j
    FORINCR `j(0 `length(THIS.`_env)):
      `push(`vs, THIS.`_env[`j][0])
    ENDFOR
    return `vs

  METHOD `set(`evar `evalue):
    VAR `j
    FORINCR `j(0 `length(THIS.`_env)):
      IF THIS.`_env[`j][0] == `evar:
        THIS.`_env[`j][1] = `evalue
        return
      ENDIF
    ENDFOR
    `push(THIS.`_env, [`evar, `evalue, 0])

  METHOD `overwrite(`evar `varvalue):
    VAR `j
    FORINCR `j(0 `length(THIS.`_env)):
      IF THIS.`_env[`j][0] == `evar:
        IF `not(`utils.`encodeOverwriteData(THIS.`_env[`j][1], `varvalue)):
          `pick(THIS.`_env, `j)
          return FALSE
        ENDIF
        return TRUE
      ENDIF
    ENDFOR
    return FALSE

  METHOD `get(`evar):
    VAR `count = 0
    VAR `evalue = NULL
    VAR `e
    VAR `j
    VAR `j2
    FORINCR `j(0 `length(THIS.`_env)):
      `count += 1
      IF THIS.`_env[`j][0] == `evar:
        THIS.`_env[`j][2] += `count
        `evalue = THIS.`_env[`j][1]
        `j2 = `j
        WHILE (`j2-1 >= 0) AND (THIS.`_env[`j2-1][2] < THIS.`_env[`j][2]):
          `j2 -= 1
        ENDWHILE
        IF `j2 == `j:
          break
        ENDIF
        `e = `pick(THIS.`_env, `j)
        `poke(THIS.`_env, `j2, `e)
        break
      ENDIF
    ENDFOR
    IF `not(`isnull(`evalue)) AND (THIS.`_env[0][2] >= 120000):
      FORINCR `j(0 `length(THIS.`_env)):
        IF THIS.`_env[`j][2] > 80000:
          THIS.`_env[`j][2] -= 80000
        ELSE:
          THIS.`_env[`j][2] = 0
        ENDIF
      ENDFOR
    ENDIF
    return `evalue

  METHOD `del(`evar):
    VAR `j
    FORINCR `j(0 `length(THIS.`_env)):
      IF THIS.`_env[`j][0] == `evar:
        `pick(THIS.`_env, `j)
        break
      ENDIF
    ENDFOR

  METHOD `destroy():
    WHILE `length(THIS.`_env) > 0:
      `pop(THIS.`_env)
    ENDWHILE
    THIS.`_env = NULL

ENDCLASS

VAR `INTERP_STATE_READY = 0
VAR `INTERP_STATE_LIMIT = 1
VAR `INTERP_STATE_PAUSE = 2
VAR `INTERP_STATE_YIELD = 3
VAR `INTERP_STATE_ERROR = 4
VAR `INTERP_STATE_ENDED = 5

FUNC `func_iexpr_rel_op_eq(`v1 `v2):
  return (`v1 == `v2)
ENDFUNC

FUNC `func_iexpr_rel_op_ne(`v1 `v2):
  return (`v1 != `v2)
ENDFUNC

FUNC `func_iexpr_rel_op_lt(`v1 `v2):
  return (`v1 < `v2)
ENDFUNC

FUNC `func_iexpr_rel_op_le(`v1 `v2):
  return (`v1 <= `v2)
ENDFUNC

FUNC `func_iexpr_rel_op_gt(`v1 `v2):
  return (`v1 > `v2)
ENDFUNC

FUNC `func_iexpr_rel_op_ge(`v1 `v2):
  return (`v1 >= `v2)
ENDFUNC

FUNC `func_iexpr_unary_op_neg(`v):
  return `fp[0].Neg(`v)
ENDFUNC

FUNC `func_iexpr_unary_op_bit_not(`v):
  return (~`v)
ENDFUNC

FUNC `func_iexpr_add_op_plus(`v1 `v2):
  return `fp[0].Add(`v1, `v2)
ENDFUNC

FUNC `func_iexpr_add_op_minus(`v1 `v2):
  return `fp[0].Sub(`v1, `v2)
ENDFUNC

FUNC `func_iexpr_add_op_bit_or(`v1 `v2):
  return (`v1 | `v2)
ENDFUNC

FUNC `func_iexpr_add_op_bit_xor(`v1 `v2):
  return (`v1 ^ `v2)
ENDFUNC

FUNC `func_iexpr_mul_op_mul(`v1 `v2):
  return `fp[0].Mul(`v1, `v2)
ENDFUNC

FUNC `func_iexpr_mul_op_div(`v1 `v2):
  return `fp[0].Div(`v1, `v2)
ENDFUNC

FUNC `func_iexpr_mul_op_idv(`v1 `v2):
  return `fp[0].Floor(`fp[0].Div(`v1, `v2))
ENDFUNC

FUNC `func_iexpr_mul_op_mod(`v1 `v2):
  return `fp[0].Mod(`v1, `v2)
ENDFUNC

FUNC `func_iexpr_mul_op_bit_and(`v1 `v2):
  return (`v1 & `v2)
ENDFUNC

FUNC `func_iexpr_mul_op_bit_shl(`v1 `v2):
  `v2 = `fp[0].FloorToInt(`v2)
  IF `v2 >= 32:
    return 0
  ELSIF `v2 >= 0:
    return `int32(`v1 << `v2)
  ELSIF `v2 <= -31:
    return TERNARY{(`v1 & 0x80000000) == 0}{0}{-1}
  ENDIF
  return `int32(`v1 >> (-`v2))
ENDFUNC

FUNC `func_iexpr_mul_op_bit_shr(`v1 `v2):
  `v2 = `fp[0].FloorToInt(`v2)
  IF `v2 >= 31:
    return TERNARY{(`v1 & 0x80000000) == 0}{0}{-1}
  ELSIF `v2 >= 0:
    return `int32(`v1 >> `v2)
  ELSIF `v2 <= -32:
    return 0
  ENDIF
  return `int32(`v1 << (-`v2))
ENDFUNC

FUNC `func_iexpr_size_var_size(`lsize `nsize):
  return (`lsize+`nsize)
ENDFUNC

FUNC `func_iexpr_size_var_nsize(`lsize `nsize):
  return `nsize
ENDFUNC

FUNC `func_iexpr_size_var_lsize(`lsize `nsize):
  return `lsize
ENDFUNC

FUNC `func_iexpr_math_op_abs(`v):
  return `fp[0].Abs(`v)
ENDFUNC

FUNC `func_iexpr_math_op_acos(`v):
  return `fp[0].Acos(`v)
ENDFUNC

FUNC `func_iexpr_math_op_asin(`v):
  return `fp[0].Asin(`v)
ENDFUNC

FUNC `func_iexpr_math_op_atan(`v):
  return `fp[0].Atan(`v)
ENDFUNC

FUNC `func_iexpr_math_op_atan2(`v1 `v2):
  return `fp[0].Atan2(`v1, `v2)
ENDFUNC

FUNC `func_iexpr_math_op_ceil(`v):
  return `fp[0].Ceil(`v)
ENDFUNC

FUNC `func_iexpr_math_op_cos(`v):
  return `fp[0].Cos(`v)
ENDFUNC

FUNC `func_iexpr_math_op_exp(`v):
  return `fp[0].Exp(`v)
ENDFUNC

FUNC `func_iexpr_math_op_exp2(`v):
  return `fp[0].Exp2(`v)
ENDFUNC

FUNC `func_iexpr_math_op_floor(`v):
  return `fp[0].Floor(`v)
ENDFUNC

FUNC `func_iexpr_math_op_log(`v):
  return `fp[0].Log(`v)
ENDFUNC

FUNC `func_iexpr_math_op_log2(`v):
  return `fp[0].Log2(`v)
ENDFUNC

FUNC `func_iexpr_math_op_max(`v1 `v2):
  return `fp[0].Max(`v1, `v2)
ENDFUNC

FUNC `func_iexpr_math_op_min(`v1 `v2):
  return `fp[0].Min(`v1, `v2)
ENDFUNC

FUNC `func_iexpr_math_op_pow(`v1 `v2):
  return `fp[0].Pow(`v1, `v2)
ENDFUNC

FUNC `func_iexpr_math_op_round(`v):
  return `fp[0].Round(`v)
ENDFUNC

FUNC `func_iexpr_math_op_sign(`v):
  return `fp[0].Sign(`v)
ENDFUNC

FUNC `func_iexpr_math_op_sin(`v):
  return `fp[0].Sin(`v)
ENDFUNC

FUNC `func_iexpr_math_op_sqrt(`v):
  return `fp[0].Sqrt(`v)
ENDFUNC

FUNC `func_iexpr_math_op_tan(`v):
  return `fp[0].Tan(`v)
ENDFUNC

CLASS `InterpM:

  METHOD_INIT(`editor_m `getQualvar `onProcedure `onYieldResume `rnd32b `instance `existsInstanceCsvar `getInstanceCsvar `__addInstanceCsvar `__removeInstanceCsvar `__updateInstanceCsvarDeltaCost `inInstanceRepeatCsvars `isCsinstanceStatusCodeNull `getCsinstance):
    THIS.`_lines_id = `editor_m.`getLinesId()
    THIS.`_lines_ast = `editor_m.`getLinesAst()
    VAR `breakpoints_info = `editor_m.`getBreakpointsInfo()
    THIS.`_breakpoints = `breakpoints_info[0]
    THIS.`_entry_pcounter = `editor_m.`getEntryLnid()
    THIS.`_getQualvar = `getQualvar
    THIS.`_onProcedure = `onProcedure
    THIS.`_onYieldResume = `onYieldResume
    THIS.`_rnd32b = `rnd32b
    THIS.`_instance = `instance
    THIS.`_existsInstanceCsvar = `existsInstanceCsvar
    THIS.`_getInstanceCsvar = `getInstanceCsvar
    THIS.`_addInstanceCsvar = `__addInstanceCsvar
    THIS.`_removeInstanceCsvar = `__removeInstanceCsvar
    THIS.`_updateInstanceCsvarDeltaCost = `__updateInstanceCsvarDeltaCost
    THIS.`_inInstanceRepeatCsvars = `inInstanceRepeatCsvars
    THIS.`_isCsinstanceStatusCodeNull = `isCsinstanceStatusCodeNull
    THIS.`_getCsinstance = `getCsinstance
    THIS.`_max_debugl_lines = NULL
    THIS.`_max_debugl_chars_per_line = NULL
    THIS.`_environment = NEW `Environment()
    THIS.`_varnames = []
    THIS.`_prev_pcounter = NULL
    THIS.`_pcounter = THIS.`_entry_pcounter
    THIS.`_repeat_vars = []
    THIS.`_has_repstop = FALSE
    THIS.`_debugl_lines = []
    THIS.`_changed_vars = []
    THIS.`_error = NULL
    THIS.`_status_code = NULL
    THIS.`_memory_delta_n = 0
    THIS.`_memory_delta_l = 0
    THIS.`_yield = FALSE
    THIS.`_procedure = NULL
    THIS.`_limits = `utils.`getNormalizedLimits(NULL)
    THIS.`_count = {}
    THIS.`_count[`key_limits_instructions] = NULL
    THIS.`_count[`key_limits_max_memory] = NULL
    THIS.`_count[`key_limits_memory] = NULL
    THIS.`_count[`key_limits_memory_n] = NULL
    THIS.`_count[`key_limits_memory_l] = NULL
    THIS.`_tmpNumber = [`key_interp_number, 0, 0, 1]
    THIS.`_tmpBoolean = [`key_interp_boolean, TRUE]
    THIS.`_tmpByRef = [`key_interp_by_ref, NULL]
    THIS.`_tmpModuleName = [`key_interp_module_name, NULL]
    THIS.`_tmpString = [`key_interp_string, NULL]
    VAR `that = THIS
    CLOSURE `closure_istmt_assign_op(`instruction):
      `that.`_istmtAssignOp(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_assign_op_csvar(`instruction):
      `that.`_istmtAssignOpCsvar(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_assign_op_random(`instruction):
      `that.`_istmtAssignOpRandom(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_assign_pop(`instruction):
      `that.`_istmtAssignPop(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_assign_unqueue(`instruction):
      `that.`_istmtAssignUnqueue(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_if(`instruction):
      `that.`_istmtIf(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_elsif(`instruction):
      `that.`_istmtElsif(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_else(`instruction):
      `that.`_istmtElse(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_endif(`instruction):
      `that.`_istmtEndif(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_repeat(`instruction):
      `that.`_istmtRepeat(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_repnext(`instruction):
      `that.`_istmtRepnext(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_repstop(`instruction):
      `that.`_istmtRepstop(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_endrep(`instruction):
      `that.`_istmtEndrep(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_procedure(`instruction):
      `that.`_istmtProcedure(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_push(`instruction):
      `that.`_istmtPush(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_queue(`instruction):
      `that.`_istmtQueue(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_unassign(`instruction):
      `that.`_istmtUnassign(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_unassign_csvar(`instruction):
      `that.`_istmtUnassignCsvar(`instruction)
    ENDCLOSURE
    CLOSURE `closure_istmt_debugl(`instruction):
      `that.`_istmtDebugl(`instruction)
    ENDCLOSURE
    THIS.`_dispatch_stmt = {}
    THIS.`_dispatch_stmt[`OPCODE_ASSIGN_OP] = `closure_istmt_assign_op
    THIS.`_dispatch_stmt[`OPCODE_ASSIGN_OP_CSVAR] = `closure_istmt_assign_op_csvar
    THIS.`_dispatch_stmt[`OPCODE_ASSIGN_OP_RANDOM] = `closure_istmt_assign_op_random
    THIS.`_dispatch_stmt[`OPCODE_ASSIGN_POP] = `closure_istmt_assign_pop
    THIS.`_dispatch_stmt[`OPCODE_ASSIGN_UNQUEUE] = `closure_istmt_assign_unqueue
    THIS.`_dispatch_stmt[`OPCODE_IF] = `closure_istmt_if
    THIS.`_dispatch_stmt[`OPCODE_ELSIF] = `closure_istmt_elsif
    THIS.`_dispatch_stmt[`OPCODE_ELSE] = `closure_istmt_else
    THIS.`_dispatch_stmt[`OPCODE_ENDIF] = `closure_istmt_endif
    THIS.`_dispatch_stmt[`OPCODE_REPEAT] = `closure_istmt_repeat
    THIS.`_dispatch_stmt[`OPCODE_REPNEXT] = `closure_istmt_repnext
    THIS.`_dispatch_stmt[`OPCODE_REPSTOP] = `closure_istmt_repstop
    THIS.`_dispatch_stmt[`OPCODE_ENDREP] = `closure_istmt_endrep
    THIS.`_dispatch_stmt[`OPCODE_PROCEDURE] = `closure_istmt_procedure
    THIS.`_dispatch_stmt[`OPCODE_PUSH] = `closure_istmt_push
    THIS.`_dispatch_stmt[`OPCODE_QUEUE] = `closure_istmt_queue
    THIS.`_dispatch_stmt[`OPCODE_UNASSIGN] = `closure_istmt_unassign
    THIS.`_dispatch_stmt[`OPCODE_UNASSIGN_CSVAR] = `closure_istmt_unassign_csvar
    THIS.`_dispatch_stmt[`OPCODE_DEBUGL] = `closure_istmt_debugl
    CLOSURE `closure_iexpr_number(`expression):
      return `that.`_iexprNumber(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_list(`expression):
      return `that.`_iexprList(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_by_ref(`expression):
      return `that.`_iexprByRef(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_module_name(`expression):
      return `that.`_iexprModuleName(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_string(`expression):
      return `that.`_iexprString(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_or(`expression):
      return `that.`_iexprOr(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_and(`expression):
      return `that.`_iexprAnd(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_not(`expression):
      return `that.`_iexprNot(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_rel_op_eq(`expression):
      return `that.`_iexprRelOp(`expression, `func_iexpr_rel_op_eq)
    ENDCLOSURE
    CLOSURE `closure_iexpr_rel_op_ne(`expression):
      return `that.`_iexprRelOp(`expression, `func_iexpr_rel_op_ne)
    ENDCLOSURE
    CLOSURE `closure_iexpr_rel_op_lt(`expression):
      return `that.`_iexprRelOp(`expression, `func_iexpr_rel_op_lt)
    ENDCLOSURE
    CLOSURE `closure_iexpr_rel_op_le(`expression):
      return `that.`_iexprRelOp(`expression, `func_iexpr_rel_op_le)
    ENDCLOSURE
    CLOSURE `closure_iexpr_rel_op_gt(`expression):
      return `that.`_iexprRelOp(`expression, `func_iexpr_rel_op_gt)
    ENDCLOSURE
    CLOSURE `closure_iexpr_rel_op_ge(`expression):
      return `that.`_iexprRelOp(`expression, `func_iexpr_rel_op_ge)
    ENDCLOSURE
    CLOSURE `closure_iexpr_unary_op_neg(`expression):
      return `that.`_iexprUnaryOp(`expression, `func_iexpr_unary_op_neg)
    ENDCLOSURE
    CLOSURE `closure_iexpr_unary_op_bit_not(`expression):
      return `that.`_iexprUnaryOp(`expression, `func_iexpr_unary_op_bit_not)
    ENDCLOSURE
    CLOSURE `closure_iexpr_add_op_plus(`expression):
      return `that.`_iexprAddOp(`expression, `func_iexpr_add_op_plus)
    ENDCLOSURE
    CLOSURE `closure_iexpr_add_op_minus(`expression):
      return `that.`_iexprAddOp(`expression, `func_iexpr_add_op_minus)
    ENDCLOSURE
    CLOSURE `closure_iexpr_add_op_bit_or(`expression):
      return `that.`_iexprAddOp(`expression, `func_iexpr_add_op_bit_or)
    ENDCLOSURE
    CLOSURE `closure_iexpr_add_op_bit_xor(`expression):
      return `that.`_iexprAddOp(`expression, `func_iexpr_add_op_bit_xor)
    ENDCLOSURE
    CLOSURE `closure_iexpr_mul_op_mul(`expression):
      return `that.`_iexprMulOp(`expression, `func_iexpr_mul_op_mul)
    ENDCLOSURE
    CLOSURE `closure_iexpr_mul_op_div(`expression):
      return `that.`_iexprMulOp(`expression, `func_iexpr_mul_op_div)
    ENDCLOSURE
    CLOSURE `closure_iexpr_mul_op_idv(`expression):
      return `that.`_iexprMulOp(`expression, `func_iexpr_mul_op_idv)
    ENDCLOSURE
    CLOSURE `closure_iexpr_mul_op_mod(`expression):
      return `that.`_iexprMulOp(`expression, `func_iexpr_mul_op_mod)
    ENDCLOSURE
    CLOSURE `closure_iexpr_mul_op_bit_and(`expression):
      return `that.`_iexprMulOp(`expression, `func_iexpr_mul_op_bit_and)
    ENDCLOSURE
    CLOSURE `closure_iexpr_mul_op_bit_shl(`expression):
      return `that.`_iexprMulOp(`expression, `func_iexpr_mul_op_bit_shl)
    ENDCLOSURE
    CLOSURE `closure_iexpr_mul_op_bit_shr(`expression):
      return `that.`_iexprMulOp(`expression, `func_iexpr_mul_op_bit_shr)
    ENDCLOSURE
    CLOSURE `closure_iexpr_var(`expression):
      return `that.`_iexprVar(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_qualvar(`expression):
      return `that.`_iexprQualvar(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_csvar(`expression):
      return `that.`_iexprCsvar(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_is_var(`expression):
      return `that.`_iexprIsVar(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_is_not_var(`expression):
      return `that.`_iexprIsNotVar(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_is_csvar(`expression):
      return `that.`_iexprIsCsvar(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_is_not_csvar(`expression):
      return `that.`_iexprIsNotCsvar(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_length_var(`expression):
      return `that.`_iexprLengthVar(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_size_var_size(`expression):
      return `that.`_iexprSizeVar(`expression, `func_iexpr_size_var_size)
    ENDCLOSURE
    CLOSURE `closure_iexpr_size_var_nsize(`expression):
      return `that.`_iexprSizeVar(`expression, `func_iexpr_size_var_nsize)
    ENDCLOSURE
    CLOSURE `closure_iexpr_size_var_lsize(`expression):
      return `that.`_iexprSizeVar(`expression, `func_iexpr_size_var_lsize)
    ENDCLOSURE
    CLOSURE `closure_iexpr_indexof_var(`expression):
      return `that.`_iexprIndexofVar(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_list_at_list(`expression):
      return `that.`_iexprListAtList(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_list_at_var(`expression):
      return `that.`_iexprListAtVar(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_list_at_qualvar(`expression):
      return `that.`_iexprListAtQualvar(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_list_at_csvar(`expression):
      return `that.`_iexprListAtCsvar(`expression)
    ENDCLOSURE
    CLOSURE `closure_iexpr_math_op_abs(`expression):
      return `that.`_iexprMathOp(`expression, `func_iexpr_math_op_abs)
    ENDCLOSURE
    CLOSURE `closure_iexpr_math_op_acos(`expression):
      return `that.`_iexprMathOp(`expression, `func_iexpr_math_op_acos)
    ENDCLOSURE
    CLOSURE `closure_iexpr_math_op_asin(`expression):
      return `that.`_iexprMathOp(`expression, `func_iexpr_math_op_asin)
    ENDCLOSURE
    CLOSURE `closure_iexpr_math_op_atan(`expression):
      return `that.`_iexprMathOp(`expression, `func_iexpr_math_op_atan)
    ENDCLOSURE
    CLOSURE `closure_iexpr_math_op_atan2(`expression):
      return `that.`_iexprMathOp(`expression, `func_iexpr_math_op_atan2)
    ENDCLOSURE
    CLOSURE `closure_iexpr_math_op_ceil(`expression):
      return `that.`_iexprMathOp(`expression, `func_iexpr_math_op_ceil)
    ENDCLOSURE
    CLOSURE `closure_iexpr_math_op_cos(`expression):
      return `that.`_iexprMathOp(`expression, `func_iexpr_math_op_cos)
    ENDCLOSURE
    CLOSURE `closure_iexpr_math_op_exp(`expression):
      return `that.`_iexprMathOp(`expression, `func_iexpr_math_op_exp)
    ENDCLOSURE
    CLOSURE `closure_iexpr_math_op_exp2(`expression):
      return `that.`_iexprMathOp(`expression, `func_iexpr_math_op_exp2)
    ENDCLOSURE
    CLOSURE `closure_iexpr_math_op_floor(`expression):
      return `that.`_iexprMathOp(`expression, `func_iexpr_math_op_floor)
    ENDCLOSURE
    CLOSURE `closure_iexpr_math_op_log(`expression):
      return `that.`_iexprMathOp(`expression, `func_iexpr_math_op_log)
    ENDCLOSURE
    CLOSURE `closure_iexpr_math_op_log2(`expression):
      return `that.`_iexprMathOp(`expression, `func_iexpr_math_op_log2)
    ENDCLOSURE
    CLOSURE `closure_iexpr_math_op_max(`expression):
      return `that.`_iexprMathOp(`expression, `func_iexpr_math_op_max)
    ENDCLOSURE
    CLOSURE `closure_iexpr_math_op_min(`expression):
      return `that.`_iexprMathOp(`expression, `func_iexpr_math_op_min)
    ENDCLOSURE
    CLOSURE `closure_iexpr_math_op_pow(`expression):
      return `that.`_iexprMathOp(`expression, `func_iexpr_math_op_pow)
    ENDCLOSURE
    CLOSURE `closure_iexpr_math_op_round(`expression):
      return `that.`_iexprMathOp(`expression, `func_iexpr_math_op_round)
    ENDCLOSURE
    CLOSURE `closure_iexpr_math_op_sign(`expression):
      return `that.`_iexprMathOp(`expression, `func_iexpr_math_op_sign)
    ENDCLOSURE
    CLOSURE `closure_iexpr_math_op_sin(`expression):
      return `that.`_iexprMathOp(`expression, `func_iexpr_math_op_sin)
    ENDCLOSURE
    CLOSURE `closure_iexpr_math_op_sqrt(`expression):
      return `that.`_iexprMathOp(`expression, `func_iexpr_math_op_sqrt)
    ENDCLOSURE
    CLOSURE `closure_iexpr_math_op_tan(`expression):
      return `that.`_iexprMathOp(`expression, `func_iexpr_math_op_tan)
    ENDCLOSURE
    THIS.`_dispatch_expr = {}
    THIS.`_dispatch_expr[`OPCODE_NUMBER] = `closure_iexpr_number
    THIS.`_dispatch_expr[`OPCODE_LIST] = `closure_iexpr_list
    THIS.`_dispatch_expr[`OPCODE_BY_REF] = `closure_iexpr_by_ref
    THIS.`_dispatch_expr[`OPCODE_MODULE_NAME] = `closure_iexpr_module_name
    THIS.`_dispatch_expr[`OPCODE_STRING] = `closure_iexpr_string
    THIS.`_dispatch_expr[`OPCODE_OR] = `closure_iexpr_or
    THIS.`_dispatch_expr[`OPCODE_AND] = `closure_iexpr_and
    THIS.`_dispatch_expr[`OPCODE_NOT] = `closure_iexpr_not
    THIS.`_dispatch_expr[`OPCODE_EQ] = `closure_iexpr_rel_op_eq
    THIS.`_dispatch_expr[`OPCODE_NE] = `closure_iexpr_rel_op_ne
    THIS.`_dispatch_expr[`OPCODE_LT] = `closure_iexpr_rel_op_lt
    THIS.`_dispatch_expr[`OPCODE_LE] = `closure_iexpr_rel_op_le
    THIS.`_dispatch_expr[`OPCODE_GT] = `closure_iexpr_rel_op_gt
    THIS.`_dispatch_expr[`OPCODE_GE] = `closure_iexpr_rel_op_ge
    THIS.`_dispatch_expr[`OPCODE_NEG] = `closure_iexpr_unary_op_neg
    THIS.`_dispatch_expr[`OPCODE_BIT_NOT] = `closure_iexpr_unary_op_bit_not
    THIS.`_dispatch_expr[`OPCODE_PLUS] = `closure_iexpr_add_op_plus
    THIS.`_dispatch_expr[`OPCODE_MINUS] = `closure_iexpr_add_op_minus
    THIS.`_dispatch_expr[`OPCODE_BIT_OR] = `closure_iexpr_add_op_bit_or
    THIS.`_dispatch_expr[`OPCODE_BIT_XOR] = `closure_iexpr_add_op_bit_xor
    THIS.`_dispatch_expr[`OPCODE_MUL] = `closure_iexpr_mul_op_mul
    THIS.`_dispatch_expr[`OPCODE_DIV] = `closure_iexpr_mul_op_div
    THIS.`_dispatch_expr[`OPCODE_IDV] = `closure_iexpr_mul_op_idv
    THIS.`_dispatch_expr[`OPCODE_MOD] = `closure_iexpr_mul_op_mod
    THIS.`_dispatch_expr[`OPCODE_BIT_AND] = `closure_iexpr_mul_op_bit_and
    THIS.`_dispatch_expr[`OPCODE_BIT_SHL] = `closure_iexpr_mul_op_bit_shl
    THIS.`_dispatch_expr[`OPCODE_BIT_SHR] = `closure_iexpr_mul_op_bit_shr
    THIS.`_dispatch_expr[`OPCODE_VAR] = `closure_iexpr_var
    THIS.`_dispatch_expr[`OPCODE_QUALVAR] = `closure_iexpr_qualvar
    THIS.`_dispatch_expr[`OPCODE_CSVAR] = `closure_iexpr_csvar
    THIS.`_dispatch_expr[`OPCODE_IS_VAR] = `closure_iexpr_is_var
    THIS.`_dispatch_expr[`OPCODE_IS_NOT_VAR] = `closure_iexpr_is_not_var
    THIS.`_dispatch_expr[`OPCODE_IS_CSVAR] = `closure_iexpr_is_csvar
    THIS.`_dispatch_expr[`OPCODE_IS_NOT_CSVAR] = `closure_iexpr_is_not_csvar
    THIS.`_dispatch_expr[`OPCODE_LENGTH_VAR] = `closure_iexpr_length_var
    THIS.`_dispatch_expr[`OPCODE_SIZE_VAR] = `closure_iexpr_size_var_size
    THIS.`_dispatch_expr[`OPCODE_NSIZE_VAR] = `closure_iexpr_size_var_nsize
    THIS.`_dispatch_expr[`OPCODE_LSIZE_VAR] = `closure_iexpr_size_var_lsize
    THIS.`_dispatch_expr[`OPCODE_INDEXOF_VAR] = `closure_iexpr_indexof_var
    THIS.`_dispatch_expr[`OPCODE_LIST_AT_LIST] = `closure_iexpr_list_at_list
    THIS.`_dispatch_expr[`OPCODE_LIST_AT_VAR] = `closure_iexpr_list_at_var
    THIS.`_dispatch_expr[`OPCODE_LIST_AT_QUALVAR] = `closure_iexpr_list_at_qualvar
    THIS.`_dispatch_expr[`OPCODE_LIST_AT_CSVAR] = `closure_iexpr_list_at_csvar
    THIS.`_dispatch_expr[`OPCODE_MATH_ABS] = `closure_iexpr_math_op_abs
    THIS.`_dispatch_expr[`OPCODE_MATH_ACOS] = `closure_iexpr_math_op_acos
    THIS.`_dispatch_expr[`OPCODE_MATH_ASIN] = `closure_iexpr_math_op_asin
    THIS.`_dispatch_expr[`OPCODE_MATH_ATAN] = `closure_iexpr_math_op_atan
    THIS.`_dispatch_expr[`OPCODE_MATH_ATAN2] = `closure_iexpr_math_op_atan2
    THIS.`_dispatch_expr[`OPCODE_MATH_CEIL] = `closure_iexpr_math_op_ceil
    THIS.`_dispatch_expr[`OPCODE_MATH_COS] = `closure_iexpr_math_op_cos
    THIS.`_dispatch_expr[`OPCODE_MATH_EXP] = `closure_iexpr_math_op_exp
    THIS.`_dispatch_expr[`OPCODE_MATH_EXP2] = `closure_iexpr_math_op_exp2
    THIS.`_dispatch_expr[`OPCODE_MATH_FLOOR] = `closure_iexpr_math_op_floor
    THIS.`_dispatch_expr[`OPCODE_MATH_LOG] = `closure_iexpr_math_op_log
    THIS.`_dispatch_expr[`OPCODE_MATH_LOG2] = `closure_iexpr_math_op_log2
    THIS.`_dispatch_expr[`OPCODE_MATH_MAX] = `closure_iexpr_math_op_max
    THIS.`_dispatch_expr[`OPCODE_MATH_MIN] = `closure_iexpr_math_op_min
    THIS.`_dispatch_expr[`OPCODE_MATH_POW] = `closure_iexpr_math_op_pow
    THIS.`_dispatch_expr[`OPCODE_MATH_ROUND] = `closure_iexpr_math_op_round
    THIS.`_dispatch_expr[`OPCODE_MATH_SIGN] = `closure_iexpr_math_op_sign
    THIS.`_dispatch_expr[`OPCODE_MATH_SIN] = `closure_iexpr_math_op_sin
    THIS.`_dispatch_expr[`OPCODE_MATH_SQRT] = `closure_iexpr_math_op_sqrt
    THIS.`_dispatch_expr[`OPCODE_MATH_TAN] = `closure_iexpr_math_op_tan
    THIS.`_data_v = NULL

  METHOD `readDebugl():
    VAR `debugl_lines = THIS.`_debugl_lines
    THIS.`_debugl_lines = []
    return `debugl_lines

  METHOD `readChangedVars():
    VAR `changed_vars = THIS.`_changed_vars
    THIS.`_changed_vars = []
    return `changed_vars

  METHOD `_addChangedVar(`varname):
    IF `indexof(THIS.`_changed_vars, `varname) >= 0:
      return
    ENDIF
    `push(THIS.`_changed_vars, `varname)

  METHOD `_getLnno(`lnid):
    IF `isnull(`lnid):
      return -1
    ENDIF
    return `indexof(THIS.`_lines_id, `lnid)

  METHOD `_setRuntimeError(`error_message):
    THIS.`_error = `error_message

  METHOD `getVarNames():
    return THIS.`_varnames

  METHOD `addVar(`varname `evalue):
    VAR `delta_cost_n = `utils.`nsizeEvalue(`evalue)
    VAR `delta_cost_l = `utils.`lsizeEvalue(`evalue)
    THIS.`_memory_delta_n += `delta_cost_n
    THIS.`_memory_delta_l += `delta_cost_l
    THIS.`_addChangedVar(`varname)
    THIS.`_addVar(`varname, `evalue)

  METHOD `getVar(`varname):
    return THIS.`_environment.`get(`varname)

  METHOD `removeVar(`varname):
    VAR `evalue = THIS.`getVar(`varname)
    VAR `delta_cost_n = -`utils.`nsizeEvalue(`evalue)
    VAR `delta_cost_l = -`utils.`lsizeEvalue(`evalue)
    THIS.`_memory_delta_n += `delta_cost_n
    THIS.`_memory_delta_l += `delta_cost_l
    THIS.`_addChangedVar(`varname)
    THIS.`_removeVar(`varname)

  METHOD `addCsvar(`varname `evalue):
    THIS.`_addVar(`varname, `evalue)

  METHOD `addCsvarCost(`varname `evalue):
    VAR `delta_cost_n = `utils.`nsizeEvalue(`evalue)
    VAR `delta_cost_l = `utils.`lsizeEvalue(`evalue)
    THIS.`updateCsvarDeltaCost(`varname, `delta_cost_n, `delta_cost_l)

  METHOD `removeCsvar(`varname):
    VAR `evalue = THIS.`getVar(`varname)
    THIS.`_removeVar(`varname)
    return `evalue

  METHOD `removeCsvarCost(`varname `evalue):
    VAR `delta_cost_n = -`utils.`nsizeEvalue(`evalue)
    VAR `delta_cost_l = -`utils.`lsizeEvalue(`evalue)
    THIS.`updateCsvarDeltaCost(`varname, `delta_cost_n, `delta_cost_l)

  METHOD `updateCsvarDeltaCost(`varname `delta_cost_n `delta_cost_l):
    THIS.`_memory_delta_n += `delta_cost_n
    THIS.`_memory_delta_l += `delta_cost_l
    THIS.`_addChangedVar(`varname)

  METHOD `_addVar(`varname `evalue):
    IF `indexof(THIS.`_varnames, `varname) < 0:
      `push(THIS.`_varnames, `varname)
    ENDIF
    THIS.`_environment.`set(`varname, `evalue)

  METHOD `_removeVar(`varname):
    VAR `idx = `indexof(THIS.`_varnames, `varname)
    IF `idx >= 0:
      `pick(THIS.`_varnames, `idx)
    ENDIF
    THIS.`_environment.`del(`varname)

  METHOD `inRepeatVars(`varname):
    return (`indexof(THIS.`_repeat_vars, `varname) >= 0)

  METHOD `run(`instance `stepping `limits):
    return THIS.`_run(`instance, FALSE, `stepping, `limits)

  METHOD `resume(`instance `resume_yield `stepping `limits_):
    VAR `limits
    IF `not(`isnull(`limits_)):
      `limits = `limits_
    ELSE:
      `limits = THIS.`_limits
      IF `not(`isnull(`limits[`key_limits_instructions])):
        `limits[`key_limits_instructions] -= THIS.`_count[`key_limits_instructions]
      ENDIF
      IF `not(`isnull(`limits[`key_limits_memory])):
        `limits[`key_limits_memory] -= THIS.`_count[`key_limits_memory]
      ENDIF
      IF `not(`isnull(`limits[`key_limits_memory_n])):
        `limits[`key_limits_memory_n] -= THIS.`_count[`key_limits_memory_n]
      ENDIF
      IF `not(`isnull(`limits[`key_limits_memory_l])):
        `limits[`key_limits_memory_l] -= THIS.`_count[`key_limits_memory_l]
      ENDIF
    ENDIF
    return THIS.`_run(`instance, `resume_yield, `stepping, `limits)

  METHOD `reap():
    THIS.`_prev_pcounter = NULL
    THIS.`_pcounter = THIS.`_entry_pcounter
    THIS.`_repeat_vars = []
    THIS.`_has_repstop = FALSE
    THIS.`_debugl_lines = []
    THIS.`_changed_vars = []
    THIS.`_error = NULL
    THIS.`_status_code = NULL
    THIS.`_memory_delta_n = 0
    THIS.`_memory_delta_l = 0
    THIS.`_yield = FALSE
    THIS.`_procedure = NULL

  METHOD `reset():
    THIS.`_environment.`reset()
    THIS.`_varnames = []

  METHOD `getStatusCode():
    return THIS.`_status_code

  METHOD `returnWithStatus(`status_code):
    THIS.`_status_code = `status_code

  METHOD `prequelYield():
    THIS.`_yield = TRUE

  METHOD `runtimeError(`error_message):
    THIS.`_setRuntimeError(`error_message)

  METHOD `_run(`instance `resume_yield `stepping `limits):
    THIS.`_limits = `limits
    THIS.`_count[`key_limits_instructions] = 0
    THIS.`_count[`key_limits_max_memory] = 0
    THIS.`_count[`key_limits_memory] = 0
    THIS.`_count[`key_limits_memory_n] = 0
    THIS.`_count[`key_limits_memory_l] = 0
    THIS.`_yield = FALSE
    VAR `force
    VAR `instruction
    VAR `next_pcounter
    VAR `status_code
    VAR `was_procedure
    IF `resume_yield:
      THIS.`_error = NULL
      THIS.`_status_code = NULL
      THIS.`_memory_delta_n = 0
      THIS.`_memory_delta_l = 0
      THIS.`_onYieldResume(`instance)
      IF `not(`isnull(THIS.`_error)):
        return [`INTERP_STATE_ERROR, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter), THIS.`_error]
      ENDIF
      THIS.`_count[`key_limits_memory] += (THIS.`_memory_delta_l+THIS.`_memory_delta_n)
      THIS.`_count[`key_limits_memory_n] += THIS.`_memory_delta_n
      THIS.`_count[`key_limits_memory_l] += THIS.`_memory_delta_l
      IF THIS.`_count[`key_limits_max_memory] < THIS.`_count[`key_limits_memory]:
        THIS.`_count[`key_limits_max_memory] = THIS.`_count[`key_limits_memory]
      ENDIF
      IF THIS.`_yield:
        return [`INTERP_STATE_YIELD, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter)]
      ENDIF
      `instruction = `utils_editor_m.`lineastAst(THIS.`_lines_ast[THIS.`_pcounter])
      `next_pcounter = `instruction[1]
      THIS.`_pcounter = `next_pcounter
      THIS.`_count[`key_limits_instructions] += 1
      IF `not(`isnull(THIS.`_status_code)):
        THIS.`_pcounter = NULL
        return [`INTERP_STATE_ENDED, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter), THIS.`_status_code]
      ENDIF
      IF `isnull(THIS.`_pcounter):
        `status_code = 0
        return [`INTERP_STATE_ENDED, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter), `status_code]
      ENDIF
      IF (`not(`isnull(THIS.`_limits[`key_limits_instructions])) AND (THIS.`_limits[`key_limits_instructions] <= THIS.`_count[`key_limits_instructions])) OR (`not(`isnull(THIS.`_limits[`key_limits_memory])) AND (THIS.`_limits[`key_limits_memory] <= THIS.`_count[`key_limits_memory])) OR (`not(`isnull(THIS.`_limits[`key_limits_memory_n])) AND (THIS.`_limits[`key_limits_memory_n] <= THIS.`_count[`key_limits_memory_n])) OR (`not(`isnull(THIS.`_limits[`key_limits_memory_l])) AND (THIS.`_limits[`key_limits_memory_l] <= THIS.`_count[`key_limits_memory_l])):
        return [`INTERP_STATE_LIMIT, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter)]
      ENDIF
    ENDIF
    IF `isnull(THIS.`_pcounter):
      `status_code = 0
      return [`INTERP_STATE_ENDED, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter), `status_code]
    ENDIF
    `force = (THIS.`_pcounter == THIS.`_prev_pcounter)
    `was_procedure = FALSE
    WHILE TRUE:
      `instruction = `utils_editor_m.`lineastAst(THIS.`_lines_ast[THIS.`_pcounter])
      IF (`stepping OR (`indexof(THIS.`_breakpoints, THIS.`_pcounter) >= 0)) AND `not(`force):
        THIS.`_prev_pcounter = THIS.`_pcounter
        return [`INTERP_STATE_PAUSE, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter)]
      ENDIF
      THIS.`_interpStmt(`instruction)
      THIS.`_prev_pcounter = NULL
      `force = FALSE
      IF `not(`isnull(THIS.`_error)):
        return [`INTERP_STATE_ERROR, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter), THIS.`_error]
      ENDIF
      IF `not(`isnull(THIS.`_procedure)):
        THIS.`_onProcedure(`instance, THIS.`_procedure[0], THIS.`_procedure[1])
        THIS.`_procedure = NULL
        IF `not(`isnull(THIS.`_error)):
          return [`INTERP_STATE_ERROR, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter), THIS.`_error]
        ENDIF
        `was_procedure = TRUE
      ENDIF
      THIS.`_count[`key_limits_memory] += (THIS.`_memory_delta_l+THIS.`_memory_delta_n)
      THIS.`_count[`key_limits_memory_n] += THIS.`_memory_delta_n
      THIS.`_count[`key_limits_memory_l] += THIS.`_memory_delta_l
      IF THIS.`_count[`key_limits_max_memory] < THIS.`_count[`key_limits_memory]:
        THIS.`_count[`key_limits_max_memory] = THIS.`_count[`key_limits_memory]
      ENDIF
      IF THIS.`_yield:
        return [`INTERP_STATE_YIELD, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter)]
      ENDIF
      THIS.`_count[`key_limits_instructions] += 1
      IF `was_procedure:
        `was_procedure = FALSE
        `next_pcounter = `instruction[1]
        THIS.`_pcounter = `next_pcounter
      ENDIF
      IF `not(`isnull(THIS.`_status_code)):
        THIS.`_pcounter = NULL
        return [`INTERP_STATE_ENDED, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter), THIS.`_status_code]
      ENDIF
      IF `isnull(THIS.`_pcounter):
        `status_code = 0
        return [`INTERP_STATE_ENDED, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter), `status_code]
      ENDIF
      IF (`not(`isnull(THIS.`_limits[`key_limits_instructions])) AND (THIS.`_limits[`key_limits_instructions] <= THIS.`_count[`key_limits_instructions])) OR (`not(`isnull(THIS.`_limits[`key_limits_memory])) AND (THIS.`_limits[`key_limits_memory] <= THIS.`_count[`key_limits_memory])) OR (`not(`isnull(THIS.`_limits[`key_limits_memory_n])) AND (THIS.`_limits[`key_limits_memory_n] <= THIS.`_count[`key_limits_memory_n])) OR (`not(`isnull(THIS.`_limits[`key_limits_memory_l])) AND (THIS.`_limits[`key_limits_memory_l] <= THIS.`_count[`key_limits_memory_l])):
        return [`INTERP_STATE_LIMIT, THIS.`_count, THIS.`_getLnno(THIS.`_pcounter)]
      ENDIF
    ENDWHILE

  METHOD `_interpStmt(`instruction):
    THIS.`_error = NULL
    THIS.`_status_code = NULL
    THIS.`_memory_delta_n = 0
    THIS.`_memory_delta_l = 0
    THIS.`_procedure = NULL
    VAR `opcode = `instruction[0]
    THIS.`_dispatch_stmt[`opcode](`instruction)

  METHOD `_istmtAssignOp(`instruction):
    VAR `that = THIS
    VAR `next_pcounter = `instruction[1]
    VAR `vvar = `instruction[2]
    VAR `exprs = `instruction[3]
    VAR `expr = `instruction[4]
    CLOSURE `getExpr():
      return `utils.`deepCopy(`that.`_interpExpr(`expr))
    ENDCLOSURE
    IF `length(`exprs) == 0:
      THIS.`_istmtAssignToVar(`vvar, `getExpr, `next_pcounter)
    ELSE:
      THIS.`_istmtAssignToListAt(`vvar, `exprs, `getExpr, `next_pcounter)
    ENDIF

  METHOD `_istmtAssignOpCsvar(`instruction):
    VAR `that = THIS
    VAR `next_pcounter = `instruction[1]
    VAR `vvar = `instruction[2]
    VAR `vmod = `instruction[3]
    VAR `exprs = `instruction[4]
    VAR `expr = `instruction[5]
    CLOSURE `getExpr():
      return `utils.`deepCopy(`that.`_interpExpr(`expr))
    ENDCLOSURE
    IF `length(`exprs) == 0:
      THIS.`_istmtAssignToCsvar(`vvar, `vmod, `getExpr, `next_pcounter)
    ELSE:
      THIS.`_istmtAssignToListAtCsvar(`vvar, `vmod, `exprs, `getExpr, `next_pcounter)
    ENDIF

  METHOD `_istmtAssignOpRandom(`instruction):
    VAR `that = THIS
    VAR `next_pcounter = `instruction[1]
    VAR `vvar = `instruction[2]
    VAR `exprs = `instruction[3]
    VAR `expr = `instruction[4]
    VAR `vmod = `instruction[5]
    CLOSURE `getExpr():
      VAR `evalue
      VAR `evaluen
      VAR `r
      IF `isnull(`expr):
        `r = `int32(`that.`_rnd32b[0]())
        return `utils.`encodeData(`r)
      ENDIF
      `evalue = `that.`_interpExpr(`expr)
      IF `isnull(`evalue):
        return NULL
      ENDIF
      IF `evalue[0] != `key_interp_number:
        `that.`_setRuntimeError("EXPECTED"+" "+"NUMBER"+" "+"IN"+" "+"RHS")
        return NULL
      ENDIF
      IF `fp[0].Fract(`evalue[1]) == 0:
        `evaluen = `trunc(`fp[0].ToFloat(`evalue[1]))
        IF `evaluen < 2:
          `r = 0
          return `utils.`encodeData(`r)
        ENDIF
        `r = `that.`_rnd32b[0]() | 0
        `r = (`r & 0x7fff0000) % `evalue[1]
      ELSE:
        IF `evalue[1] < 2:
          `r = 0
          return `utils.`encodeData(`r)
        ENDIF
        `r = `that.`_rnd32b[0]() | 0
        `r = (`r & 0x7fffffff) % `evalue[1]
      ENDIF
      return `utils.`encodeData(`r)
    ENDCLOSURE
    IF `isnull(`vmod):
      IF `length(`exprs) == 0:
        THIS.`_istmtAssignToVar(`vvar, `getExpr, `next_pcounter)
      ELSE:
        THIS.`_istmtAssignToListAt(`vvar, `exprs, `getExpr, `next_pcounter)
      ENDIF
    ELSE:
      IF `length(`exprs) == 0:
        THIS.`_istmtAssignToCsvar(`vvar, `vmod, `getExpr, `next_pcounter)
      ELSE:
        THIS.`_istmtAssignToListAtCsvar(`vvar, `vmod, `exprs, `getExpr, `next_pcounter)
      ENDIF
    ENDIF

  METHOD `_istmtAssignPop(`instruction):
    VAR `that = THIS
    VAR `next_pcounter = `instruction[1]
    VAR `vvar = `instruction[2]
    VAR `exprs = `instruction[3]
    VAR `popvarexprs = `instruction[4]
    VAR `index = `instruction[5]
    VAR `vmod = `instruction[6]
    CLOSURE `getExpr():
      VAR `evalue = `that.`_interpExpr(`popvarexprs)
      IF `isnull(`evalue):
        return NULL
      ENDIF
      IF `evalue[0] != `key_interp_list:
        `that.`_setRuntimeError("EXPECTED"+" "+"LIST")
        return NULL
      ENDIF
      IF `length(`evalue[1]) == 0:
        `that.`_setRuntimeError("POP"+" "+"EMPTY"+" "+"LIST")
        return NULL
      ENDIF
      VAR `popvar = `popvarexprs[1]
      VAR `popvalue
      VAR `lindex
      VAR `lindexn
      IF `isnull(`index):
        `popvalue = `pop(`evalue[1])
      ELSE:
        `lindex = `that.`_interpExpr(`index)
        IF `isnull(`lindex):
          return NULL
        ENDIF
        IF `lindex[0] != `key_interp_number:
          `that.`_setRuntimeError("INVALID"+" "+"INDEX")
          return NULL
        ENDIF
        `lindexn = `fp[0].FloorToInt(`lindex[1])
        IF (`lindexn < 0) OR (`lindexn >= `length(`evalue[1])):
          `that.`_setRuntimeError("INDEX"+" "+"OUT-OF-RANGE")
          return NULL
        ENDIF
        `popvalue = `pick(`evalue[1], `lindexn)
      ENDIF
      VAR `delta_cost_n = -`utils.`nsizeEvalue(`popvalue)
      VAR `delta_cost_l = -`utils.`lsizeEvalue(`popvalue)
      VAR `popexprs
      VAR `popevalue
      VAR `poplindex
      VAR `poplindexn
      VAR `j
      VAR `csinstance
      VAR `popmod
      IF `popvarexprs[0] == `OPCODE_VAR:
        `evalue[2] += `delta_cost_l
        `evalue[3] += `delta_cost_n
        `csinstance = `that.`_instance
      ELSIF `popvarexprs[0] == `OPCODE_LIST_AT_VAR:
        `popexprs = `popvarexprs[2]
        `popevalue = `that.`getVar(`popvar)
        `popevalue[2] += `delta_cost_l
        `popevalue[3] += `delta_cost_n
        FORINCR `j(0 `length(`popexprs)):
          `poplindex = `that.`_interpExpr(`popexprs[`j])
          `poplindexn = `fp[0].FloorToInt(`poplindex[1])
          `popevalue = `popevalue[1][`poplindexn]
          `popevalue[2] += `delta_cost_l
          `popevalue[3] += `delta_cost_n
        ENDFOR
        `csinstance = `that.`_instance
      ELSIF `popvarexprs[0] == `OPCODE_CSVAR:
        `evalue[2] += `delta_cost_l
        `evalue[3] += `delta_cost_n
        `popmod = `popvarexprs[2]
        `csinstance = `that.`_getCsinstance(`popvar, `popmod, `that.`_instance)
      ELSIF `popvarexprs[0] == `OPCODE_LIST_AT_CSVAR:
        `popexprs = `popvarexprs[2]
        `popmod = `popvarexprs[3]
        `csinstance = `that.`_getCsinstance(`popvar, `popmod, `that.`_instance)
        `popevalue = `that.`_getInstanceCsvar(`csinstance, `popvar)
        `popevalue[2] += `delta_cost_l
        `popevalue[3] += `delta_cost_n
        FORINCR `j(0 `length(`popexprs)):
          `poplindex = `that.`_interpExpr(`popexprs[`j])
          `poplindexn = `fp[0].FloorToInt(`poplindex[1])
          `popevalue = `popevalue[1][`poplindexn]
          `popevalue[2] += `delta_cost_l
          `popevalue[3] += `delta_cost_n
        ENDFOR
      ELSE:
        `that.`_setRuntimeError("UNEXPECTED"+" "+"OPCODE")
        return NULL
      ENDIF
      `that.`_updateInstanceCsvarDeltaCost(`that.`_instance, `popvar, `csinstance, `delta_cost_n, `delta_cost_l)
      return `popvalue
    ENDCLOSURE
    IF `isnull(`vvar):
      THIS.`_istmtAssignToDummy(`getExpr, `next_pcounter)
    ELSIF `isnull(`vmod):
      IF `length(`exprs) == 0:
        THIS.`_istmtAssignToVar(`vvar, `getExpr, `next_pcounter)
      ELSE:
        THIS.`_istmtAssignToListAt(`vvar, `exprs, `getExpr, `next_pcounter)
      ENDIF
    ELSE:
      IF `length(`exprs) == 0:
        THIS.`_istmtAssignToCsvar(`vvar, `vmod, `getExpr, `next_pcounter)
      ELSE:
        THIS.`_istmtAssignToListAtCsvar(`vvar, `vmod, `exprs, `getExpr, `next_pcounter)
      ENDIF
    ENDIF

  METHOD `_istmtAssignUnqueue(`instruction):
    VAR `that = THIS
    VAR `next_pcounter = `instruction[1]
    VAR `vvar = `instruction[2]
    VAR `exprs = `instruction[3]
    VAR `unqvarexprs = `instruction[4]
    VAR `vmod = `instruction[5]
    CLOSURE `getExpr():
      VAR `evalue = `that.`_interpExpr(`unqvarexprs)
      IF `isnull(`evalue):
        return NULL
      ENDIF
      IF `evalue[0] != `key_interp_list:
        `that.`_setRuntimeError("EXPECTED"+" "+"LIST")
        return NULL
      ENDIF
      IF `length(`evalue[1]) == 0:
        `that.`_setRuntimeError("UNQUEUE"+" "+"EMPTY"+" "+"LIST")
        return NULL
      ENDIF
      VAR `unqvar = `unqvarexprs[1]
      VAR `unqvalue = `unqueue(`evalue[1])
      VAR `delta_cost_n = -`utils.`nsizeEvalue(`unqvalue)
      VAR `delta_cost_l = -`utils.`lsizeEvalue(`unqvalue)
      VAR `unqexprs
      VAR `unqevalue
      VAR `unqlindex
      VAR `unqlindexn
      VAR `j
      VAR `csinstance
      VAR `unqmod
      IF `unqvarexprs[0] == `OPCODE_VAR:
        `evalue[2] += `delta_cost_l
        `evalue[3] += `delta_cost_n
        `csinstance = `that.`_instance
      ELSIF `unqvarexprs[0] == `OPCODE_LIST_AT_VAR:
        `unqexprs = `unqvarexprs[2]
        `unqevalue = `that.`getVar(`unqvar)
        `unqevalue[2] += `delta_cost_l
        `unqevalue[3] += `delta_cost_n
        FORINCR `j(0 `length(`unqexprs)):
          `unqlindex = `that.`_interpExpr(`unqexprs[`j])
          `unqlindexn = `fp[0].FloorToInt(`unqlindex[1])
          `unqevalue = `unqevalue[1][`unqlindexn]
          `unqevalue[2] += `delta_cost_l
          `unqevalue[3] += `delta_cost_n
        ENDFOR
        `csinstance = `that.`_instance
      ELSIF `unqvarexprs[0] == `OPCODE_CSVAR:
        `evalue[2] += `delta_cost_l
        `evalue[3] += `delta_cost_n
        `unqmod = `unqvarexprs[2]
        `csinstance = `that.`_getCsinstance(`unqvar, `unqmod, `that.`_instance)
      ELSIF `unqvarexprs[0] == `OPCODE_LIST_AT_CSVAR:
        `unqexprs = `unqvarexprs[2]
        `unqmod = `unqvarexprs[3]
        `csinstance = `that.`_getCsinstance(`unqvar, `unqmod, `that.`_instance)
        `unqevalue = `that.`_getInstanceCsvar(`csinstance, `unqvar)
        `unqevalue[2] += `delta_cost_l
        `unqevalue[3] += `delta_cost_n
        FORINCR `j(0 `length(`unqexprs)):
          `unqlindex = `that.`_interpExpr(`unqexprs[`j])
          `unqlindexn = `fp[0].FloorToInt(`unqlindex[1])
          `unqevalue = `unqevalue[1][`unqlindexn]
          `unqevalue[2] += `delta_cost_l
          `unqevalue[3] += `delta_cost_n
        ENDFOR
      ELSE:
        `that.`_setRuntimeError("UNEXPECTED"+" "+"OPCODE")
        return NULL
      ENDIF
      `that.`_updateInstanceCsvarDeltaCost(`that.`_instance, `unqvar, `csinstance, `delta_cost_n, `delta_cost_l)
      return `unqvalue
    ENDCLOSURE
    IF `isnull(`vvar):
      THIS.`_istmtAssignToDummy(`getExpr, `next_pcounter)
    ELSIF `isnull(`vmod):
      IF `length(`exprs) == 0:
        THIS.`_istmtAssignToVar(`vvar, `getExpr, `next_pcounter)
      ELSE:
        THIS.`_istmtAssignToListAt(`vvar, `exprs, `getExpr, `next_pcounter)
      ENDIF
    ELSE:
      IF `length(`exprs) == 0:
        THIS.`_istmtAssignToCsvar(`vvar, `vmod, `getExpr, `next_pcounter)
      ELSE:
        THIS.`_istmtAssignToListAtCsvar(`vvar, `vmod, `exprs, `getExpr, `next_pcounter)
      ENDIF
    ENDIF

  METHOD `_istmtAssignToDummy(`getExpr `next_pcounter):
    VAR `evalue = `getExpr()
    IF `isnull(`evalue):
      return
    ENDIF
    THIS.`_pcounter = `next_pcounter

  METHOD `_istmtAssignToVar(`vvar `getExpr `next_pcounter):
    IF THIS.`inRepeatVars(`vvar):
      THIS.`_setRuntimeError("REPEAT"+" "+"VARIABLE"+" "+"IN"+" "+"ASSIGNMENT")
      return
    ENDIF
    VAR `evalue = `getExpr()
    IF `isnull(`evalue):
      return
    ENDIF
    VAR `delta_cost_n = `utils.`nsizeEvalue(`evalue)
    VAR `delta_cost_l = `utils.`lsizeEvalue(`evalue)
    VAR `old_evalue = THIS.`getVar(`vvar)
    IF `not(`isnull(`old_evalue)):
      `delta_cost_n += -`utils.`nsizeEvalue(`old_evalue)
      `delta_cost_l += -`utils.`lsizeEvalue(`old_evalue)
    ENDIF
    THIS.`_addVar(`vvar, `evalue)
    THIS.`_memory_delta_n += `delta_cost_n
    THIS.`_memory_delta_l += `delta_cost_l
    THIS.`_addChangedVar(`vvar)
    THIS.`_pcounter = `next_pcounter

  METHOD `_istmtAssignToListAt(`vvar `exprs `getExpr `next_pcounter):
    VAR `vvalue = THIS.`getVar(`vvar)
    IF `isnull(`vvalue):
      THIS.`_setRuntimeError("UNDEFINED"+" "+"VARIABLE"+" "+"IN"+" "+"LHS")
      return
    ENDIF
    IF `vvalue[0] != `key_interp_list:
      THIS.`_setRuntimeError("EXPECTED"+" "+"LIST"+" "+"IN"+" "+"LHS")
      return
    ENDIF
    VAR `vvalues = []
    VAR `lindex = THIS.`_interpExpr(`exprs[0])
    IF `isnull(`lindex):
      return
    ENDIF
    IF `lindex[0] != `key_interp_number:
      THIS.`_setRuntimeError("INVALID"+" "+"INDEX"+" "+"IN"+" "+"LHS")
      return
    ENDIF
    VAR `lindexn = `fp[0].FloorToInt(`lindex[1])
    IF (`lindexn < 0) OR (`lindexn >= `length(`vvalue[1])):
      THIS.`_setRuntimeError("INDEX"+" "+"OUT-OF-RANGE"+" "+"IN"+" "+"LHS")
      return
    ENDIF
    VAR `j
    FORINCR `j(1 `length(`exprs)):
      `push(`vvalues, `vvalue)
      `vvalue = `vvalue[1][`lindexn]
      IF `vvalue[0] != `key_interp_list:
        THIS.`_setRuntimeError("EXPECTED"+" "+"LIST"+" "+"IN"+" "+"LHS")
        return
      ENDIF
      `lindex = THIS.`_interpExpr(`exprs[`j])
      IF `isnull(`lindex):
        return
      ENDIF
      IF `lindex[0] != `key_interp_number:
        THIS.`_setRuntimeError("INVALID"+" "+"INDEX"+" "+"IN"+" "+"LHS")
        return
      ENDIF
      `lindexn = `fp[0].FloorToInt(`lindex[1])
      IF (`lindexn < 0) OR (`lindexn >= `length(`vvalue[1])):
        THIS.`_setRuntimeError("INDEX"+" "+"OUT-OF-RANGE"+" "+"IN"+" "+"LHS")
        return
      ENDIF
    ENDFOR
    VAR `evalue = `getExpr()
    IF `isnull(`evalue):
      return
    ENDIF
    VAR `delta_cost_n = -`utils.`nsizeEvalue(`vvalue[1][`lindexn])+`utils.`nsizeEvalue(`evalue)
    VAR `delta_cost_l = -`utils.`lsizeEvalue(`vvalue[1][`lindexn])+`utils.`lsizeEvalue(`evalue)
    `vvalue[1][`lindexn] = `evalue
    IF (`delta_cost_n != 0) OR (`delta_cost_l != 0):
      `push(`vvalues, `vvalue)
      FORINCR `j(0 `length(`vvalues)):
        `vvalues[`j][2] += `delta_cost_l
        `vvalues[`j][3] += `delta_cost_n
      ENDFOR
      THIS.`_memory_delta_n += `delta_cost_n
      THIS.`_memory_delta_l += `delta_cost_l
    ENDIF
    THIS.`_addChangedVar(`vvar)
    THIS.`_pcounter = `next_pcounter

  METHOD `_istmtAssignToCsvar(`vvar `vmod `getExpr `next_pcounter):
    VAR `csinstance = THIS.`_getCsinstance(`vvar, `vmod, THIS.`_instance)
    IF `isnull(`csinstance):
      THIS.`_setRuntimeError("INVALID"+" "+"CALLSTACK"+" "+"VARIABLE")
      return
    ENDIF
    IF `csinstance == THIS.`_instance:
      THIS.`_istmtAssignToVar(`vvar, `getExpr, `next_pcounter)
      return
    ENDIF
    IF THIS.`_inInstanceRepeatCsvars(`csinstance, `vvar) AND THIS.`_isCsinstanceStatusCodeNull(`csinstance):
      THIS.`_setRuntimeError("REPEAT"+" "+"VARIABLE"+" "+"IN"+" "+"ASSIGNMENT")
      return
    ENDIF
    VAR `evalue = `getExpr()
    IF `isnull(`evalue):
      return
    ENDIF
    IF THIS.`_existsInstanceCsvar(`csinstance, `vvar):
      THIS.`_removeInstanceCsvar(THIS.`_instance, `vvar, `csinstance)
    ENDIF
    THIS.`_addInstanceCsvar(THIS.`_instance, `vvar, `evalue, `csinstance)
    THIS.`_pcounter = `next_pcounter

  METHOD `_istmtAssignToListAtCsvar(`vvar `vmod `exprs `getExpr `next_pcounter):
    VAR `csinstance = THIS.`_getCsinstance(`vvar, `vmod, THIS.`_instance)
    IF `isnull(`csinstance):
      THIS.`_setRuntimeError("INVALID"+" "+"CALLSTACK"+" "+"VARIABLE")
      return
    ENDIF
    IF `csinstance == THIS.`_instance:
      THIS.`_istmtAssignToListAt(`vvar, `exprs, `getExpr, `next_pcounter)
      return
    ENDIF
    VAR `vvalue = THIS.`_getInstanceCsvar(`csinstance, `vvar)
    IF `isnull(`vvalue):
      THIS.`_setRuntimeError("UNDEFINED"+" "+"VARIABLE"+" "+"IN"+" "+"LHS")
      return
    ENDIF
    IF `vvalue[0] != `key_interp_list:
      THIS.`_setRuntimeError("EXPECTED"+" "+"LIST"+" "+"IN"+" "+"LHS")
      return
    ENDIF
    VAR `vvalues = []
    VAR `lindex = THIS.`_interpExpr(`exprs[0])
    IF `isnull(`lindex):
      return
    ENDIF
    IF `lindex[0] != `key_interp_number:
      THIS.`_setRuntimeError("INVALID"+" "+"INDEX"+" "+"IN"+" "+"LHS")
      return
    ENDIF
    VAR `lindexn = `fp[0].FloorToInt(`lindex[1])
    IF (`lindexn < 0) OR (`lindexn >= `length(`vvalue[1])):
      THIS.`_setRuntimeError("INDEX"+" "+"OUT-OF-RANGE"+" "+"IN"+" "+"LHS")
      return
    ENDIF
    VAR `j
    FORINCR `j(1 `length(`exprs)):
      `push(`vvalues, `vvalue)
      `vvalue = `vvalue[1][`lindexn]
      IF `vvalue[0] != `key_interp_list:
        THIS.`_setRuntimeError("EXPECTED"+" "+"LIST"+" "+"IN"+" "+"LHS")
        return
      ENDIF
      `lindex = THIS.`_interpExpr(`exprs[`j])
      IF `isnull(`lindex):
        return
      ENDIF
      IF `lindex[0] != `key_interp_number:
        THIS.`_setRuntimeError("INVALID"+" "+"INDEX"+" "+"IN"+" "+"LHS")
        return
      ENDIF
      `lindexn = `fp[0].FloorToInt(`lindex[1])
      IF (`lindexn < 0) OR (`lindexn >= `length(`vvalue[1])):
        THIS.`_setRuntimeError("INDEX"+" "+"OUT-OF-RANGE"+" "+"IN"+" "+"LHS")
        return
      ENDIF
    ENDFOR
    VAR `evalue = `getExpr()
    IF `isnull(`evalue):
      return
    ENDIF
    VAR `delta_cost_n = -`utils.`nsizeEvalue(`vvalue[1][`lindexn])+`utils.`nsizeEvalue(`evalue)
    VAR `delta_cost_l = -`utils.`lsizeEvalue(`vvalue[1][`lindexn])+`utils.`lsizeEvalue(`evalue)
    `vvalue[1][`lindexn] = `evalue
    IF (`delta_cost_n != 0) OR (`delta_cost_l != 0):
      `push(`vvalues, `vvalue)
      FORINCR `j(0 `length(`vvalues)):
        `vvalues[`j][2] += `delta_cost_l
        `vvalues[`j][3] += `delta_cost_n
      ENDFOR
    ENDIF
    THIS.`_updateInstanceCsvarDeltaCost(THIS.`_instance, `vvar, `csinstance, `delta_cost_n, `delta_cost_l)
    THIS.`_pcounter = `next_pcounter

  METHOD `_istmtIf(`instruction):
    VAR `next_pcounter = `instruction[1]
    VAR `alt_pcounter = `instruction[2]
    VAR `expr = `instruction[3]
    VAR `evalue = THIS.`_interpExpr(`expr)
    IF `isnull(`evalue):
      return
    ENDIF
    IF `evalue[1]:
      THIS.`_pcounter = `next_pcounter
    ELSE:
      THIS.`_pcounter = `alt_pcounter
    ENDIF

  METHOD `_istmtElsif(`instruction):
    VAR `next_pcounter = `instruction[1]
    VAR `alt_pcounter = `instruction[2]
    VAR `expr = `instruction[3]
    VAR `evalue = THIS.`_interpExpr(`expr)
    IF `isnull(`evalue):
      return
    ENDIF
    IF `evalue[1]:
      THIS.`_pcounter = `next_pcounter
    ELSE:
      THIS.`_pcounter = `alt_pcounter
    ENDIF

  METHOD `_istmtElse(`instruction):
    VAR `next_pcounter = `instruction[1]
    THIS.`_pcounter = `next_pcounter

  METHOD `_istmtEndif(`instruction):
    VAR `next_pcounter = `instruction[1]
    THIS.`_pcounter = `next_pcounter

  METHOD `_istmtRepeat(`instruction):
    VAR `next_pcounter = `instruction[1]
    VAR `alt_pcounter = `instruction[2]
    VAR `vvar = `instruction[3]
    IF THIS.`inRepeatVars(`vvar):
      THIS.`_setRuntimeError("REPEAT"+" "+"VARIABLE"+" "+"INSIDE"+" "+"REPEAT")
      return
    ENDIF
    VAR `evalue = THIS.`getVar(`vvar)
    IF `isnull(`evalue):
      THIS.`_setRuntimeError("UNDEFINED"+" "+"VARIABLE")
      return
    ENDIF
    IF `evalue[0] != `key_interp_number:
      THIS.`_setRuntimeError("EXPECTED"+" "+"NUMBER")
      return
    ENDIF
    `push(THIS.`_repeat_vars, `vvar)
    VAR `evaluen = `fp[0].FloorToInt(`evalue[1])
    IF `evaluen > 0:
      `evaluen -= 1
      `evalue[1] = `fp[0].FromFloat(`evaluen)
      THIS.`_addChangedVar(`vvar)
      THIS.`_has_repstop = FALSE
      THIS.`_pcounter = `next_pcounter
    ELSE:
      `evalue[1] = `fp[0].FromFloat(`evaluen)
      THIS.`_pcounter = `alt_pcounter
    ENDIF

  METHOD `_istmtRepnext(`instruction):
    VAR `next_pcounter = `instruction[1]
    THIS.`_pcounter = `next_pcounter

  METHOD `_istmtRepstop(`instruction):
    VAR `next_pcounter = `instruction[1]
    THIS.`_has_repstop = TRUE
    THIS.`_pcounter = `next_pcounter

  METHOD `_istmtEndrep(`instruction):
    VAR `next_pcounter = `instruction[1]
    VAR `alt_pcounter = `instruction[2]
    VAR `vvar = `pop(THIS.`_repeat_vars)
    VAR `evalue = THIS.`getVar(`vvar)
    IF (`evalue[1] <= 0) OR THIS.`_has_repstop:
      THIS.`_has_repstop = FALSE
      THIS.`_pcounter = `next_pcounter
    ELSE:
      THIS.`_pcounter = `alt_pcounter
    ENDIF

  METHOD `_istmtProcedure(`instruction):
    VAR `next_pcounter = `instruction[1]
    VAR `procname = `instruction[2]
    VAR `exprs = `instruction[3]
    VAR `procvalue = THIS.`_getQualvar(`procname)
    IF `isnull(`procvalue):
      THIS.`_setRuntimeError("UNDEFINED"+" "+"PROCEDURE")
      return
    ENDIF
    IF `procvalue[0] != `key_interp_procedure:
      THIS.`_setRuntimeError("EXPECTED"+" "+"PROCEDURE")
      return
    ENDIF
    VAR `args = []
    VAR `j
    VAR `evalue
    FORINCR `j(0 `length(`exprs)):
      `evalue = THIS.`_interpExpr(`exprs[`j])
      IF `isnull(`evalue):
        return
      ENDIF
      `push(`args, `utils.`decodeData(`evalue))
    ENDFOR
    THIS.`_procedure = [`procname, `args]

  METHOD `_istmtPush(`instruction):
    VAR `next_pcounter = `instruction[1]
    VAR `pvarexprs = `instruction[2]
    VAR `expr = `instruction[3]
    VAR `index = `instruction[4]
    VAR `pvar = `pvarexprs[1]
    VAR `pvalue = THIS.`_interpExpr(`pvarexprs)
    IF `isnull(`pvalue):
      return
    ENDIF
    IF `pvalue[0] != `key_interp_list:
      THIS.`_setRuntimeError("EXPECTED"+" "+"LIST")
      return
    ENDIF
    VAR `evalue = `utils.`deepCopy(THIS.`_interpExpr(`expr))
    IF `isnull(`evalue):
      return
    ENDIF
    VAR `delta_cost_n = `utils.`nsizeEvalue(`evalue)
    VAR `delta_cost_l = `utils.`lsizeEvalue(`evalue)
    VAR `lindex
    VAR `lindexn
    IF `isnull(`index):
      `push(`pvalue[1], `evalue)
    ELSE:
      `lindex = THIS.`_interpExpr(`index)
      IF `isnull(`lindex):
        return
      ENDIF
      IF `lindex[0] != `key_interp_number:
        THIS.`_setRuntimeError("INVALID"+" "+"INDEX")
        return
      ENDIF
      `lindexn = `fp[0].FloorToInt(`lindex[1])
      IF (`lindexn < 0) OR (`lindexn > `length(`pvalue[1])):
        THIS.`_setRuntimeError("INDEX"+" "+"OUT-OF-RANGE")
        return
      ENDIF
      IF `lindexn < `length(`pvalue[1]):
        `poke(`pvalue[1], `lindexn, `evalue)
      ELSE:
        `push(`pvalue[1], `evalue)
      ENDIF
    ENDIF
    VAR `pexprs
    VAR `pevalue
    VAR `plindex
    VAR `plindexn
    VAR `j
    VAR `csinstance
    VAR `pmod
    IF `pvarexprs[0] == `OPCODE_VAR:
      `pvalue[2] += `delta_cost_l
      `pvalue[3] += `delta_cost_n
      `csinstance = THIS.`_instance
    ELSIF `pvarexprs[0] == `OPCODE_LIST_AT_VAR:
      `pexprs = `pvarexprs[2]
      `pevalue = THIS.`getVar(`pvar)
      `pevalue[2] += `delta_cost_l
      `pevalue[3] += `delta_cost_n
      FORINCR `j(0 `length(`pexprs)):
        `plindex = THIS.`_interpExpr(`pexprs[`j])
        `plindexn = `fp[0].FloorToInt(`plindex[1])
        `pevalue = `pevalue[1][`plindexn]
        `pevalue[2] += `delta_cost_l
        `pevalue[3] += `delta_cost_n
      ENDFOR
      `csinstance = THIS.`_instance
    ELSIF `pvarexprs[0] == `OPCODE_CSVAR:
      `pvalue[2] += `delta_cost_l
      `pvalue[3] += `delta_cost_n
      `pmod = `pvarexprs[2]
      `csinstance = THIS.`_getCsinstance(`pvar, `pmod, THIS.`_instance)
    ELSIF `pvarexprs[0] == `OPCODE_LIST_AT_CSVAR:
      `pexprs = `pvarexprs[2]
      `pmod = `pvarexprs[3]
      `csinstance = THIS.`_getCsinstance(`pvar, `pmod, THIS.`_instance)
      `pevalue = THIS.`_getInstanceCsvar(`csinstance, `pvar)
      `pevalue[2] += `delta_cost_l
      `pevalue[3] += `delta_cost_n
      FORINCR `j(0 `length(`pexprs)):
        `plindex = THIS.`_interpExpr(`pexprs[`j])
        `plindexn = `fp[0].FloorToInt(`plindex[1])
        `pevalue = `pevalue[1][`plindexn]
        `pevalue[2] += `delta_cost_l
        `pevalue[3] += `delta_cost_n
      ENDFOR
    ELSE:
      THIS.`_setRuntimeError("UNEXPECTED"+" "+"OPCODE")
      return
    ENDIF
    THIS.`_updateInstanceCsvarDeltaCost(THIS.`_instance, `pvar, `csinstance, `delta_cost_n, `delta_cost_l)
    THIS.`_pcounter = `next_pcounter

  METHOD `_istmtQueue(`instruction):
    VAR `next_pcounter = `instruction[1]
    VAR `qvarexprs = `instruction[2]
    VAR `expr = `instruction[3]
    VAR `qvar = `qvarexprs[1]
    VAR `qvalue = THIS.`_interpExpr(`qvarexprs)
    IF `isnull(`qvalue):
      return
    ENDIF
    IF `qvalue[0] != `key_interp_list:
      THIS.`_setRuntimeError("EXPECTED"+" "+"LIST")
      return
    ENDIF
    VAR `evalue = `utils.`deepCopy(THIS.`_interpExpr(`expr))
    IF `isnull(`evalue):
      return
    ENDIF
    VAR `delta_cost_n = `utils.`nsizeEvalue(`evalue)
    VAR `delta_cost_l = `utils.`lsizeEvalue(`evalue)
    `queue(`qvalue[1], `evalue)
    VAR `qexprs
    VAR `qevalue
    VAR `qlindex
    VAR `qlindexn
    VAR `j
    VAR `csinstance
    VAR `qmod
    IF `qvarexprs[0] == `OPCODE_VAR:
      `qvalue[2] += `delta_cost_l
      `qvalue[3] += `delta_cost_n
      `csinstance = THIS.`_instance
    ELSIF `qvarexprs[0] == `OPCODE_LIST_AT_VAR:
      `qexprs = `qvarexprs[2]
      `qevalue = THIS.`getVar(`qvar)
      `qevalue[2] += `delta_cost_l
      `qevalue[3] += `delta_cost_n
      FORINCR `j(0 `length(`qexprs)):
        `qlindex = THIS.`_interpExpr(`qexprs[`j])
        `qlindexn = `fp[0].FloorToInt(`qlindex[1])
        `qevalue = `qevalue[1][`qlindexn]
        `qevalue[2] += `delta_cost_l
        `qevalue[3] += `delta_cost_n
      ENDFOR
      `csinstance = THIS.`_instance
    ELSIF `qvarexprs[0] == `OPCODE_CSVAR:
      `qvalue[2] += `delta_cost_l
      `qvalue[3] += `delta_cost_n
      `qmod = `qvarexprs[2]
      `csinstance = THIS.`_getCsinstance(`qvar, `qmod, THIS.`_instance)
    ELSIF `qvarexprs[0] == `OPCODE_LIST_AT_CSVAR:
      `qexprs = `qvarexprs[2]
      `qmod = `qvarexprs[3]
      `csinstance = THIS.`_getCsinstance(`qvar, `qmod, THIS.`_instance)
      `qevalue = THIS.`_getInstanceCsvar(`csinstance, `qvar)
      `qevalue[2] += `delta_cost_l
      `qevalue[3] += `delta_cost_n
      FORINCR `j(0 `length(`qexprs)):
        `qlindex = THIS.`_interpExpr(`qexprs[`j])
        `qlindexn = `fp[0].FloorToInt(`qlindex[1])
        `qevalue = `qevalue[1][`qlindexn]
        `qevalue[2] += `delta_cost_l
        `qevalue[3] += `delta_cost_n
      ENDFOR
    ELSE:
      THIS.`_setRuntimeError("UNEXPECTED"+" "+"OPCODE")
      return
    ENDIF
    THIS.`_updateInstanceCsvarDeltaCost(THIS.`_instance, `qvar, `csinstance, `delta_cost_n, `delta_cost_l)
    THIS.`_pcounter = `next_pcounter

  METHOD `_istmtUnassign(`instruction):
    VAR `next_pcounter = `instruction[1]
    VAR `vvar = `instruction[2]
    IF THIS.`inRepeatVars(`vvar):
      THIS.`_setRuntimeError("REPEAT"+" "+"VARIABLE"+" "+"IN"+" "+"UNASSIGN")
      return
    ENDIF
    VAR `evalue = THIS.`getVar(`vvar)
    IF `isnull(`evalue):
      THIS.`_setRuntimeError("UNDEFINED"+" "+"VARIABLE")
      return
    ENDIF
    VAR `delta_cost_n = -`utils.`nsizeEvalue(`evalue)
    VAR `delta_cost_l = -`utils.`lsizeEvalue(`evalue)
    THIS.`_removeVar(`vvar)
    THIS.`_memory_delta_n += `delta_cost_n
    THIS.`_memory_delta_l += `delta_cost_l
    THIS.`_addChangedVar(`vvar)
    THIS.`_pcounter = `next_pcounter

  METHOD `_istmtUnassignCsvar(`instruction):
    VAR `vvar = `instruction[2]
    VAR `vmod = `instruction[3]
    VAR `csinstance = THIS.`_getCsinstance(`vvar, `vmod, THIS.`_instance)
    IF `isnull(`csinstance):
      THIS.`_setRuntimeError("INVALID"+" "+"CALLSTACK"+" "+"VARIABLE")
      return
    ENDIF
    IF `csinstance == THIS.`_instance:
      THIS.`_istmtUnassign(`instruction)
      return
    ENDIF
    IF `not(THIS.`_existsInstanceCsvar(`csinstance, `vvar)):
      THIS.`_setRuntimeError("UNDEFINED"+" "+"CALLSTACK"+" "+"VARIABLE")
      return
    ENDIF
    IF THIS.`_inInstanceRepeatCsvars(`csinstance, `vvar) AND THIS.`_isCsinstanceStatusCodeNull(`csinstance):
      THIS.`_setRuntimeError("REPEAT"+" "+"VARIABLE"+" "+"IN"+" "+"UNASSIGN")
      return
    ENDIF
    THIS.`_removeInstanceCsvar(THIS.`_instance, `vvar, `csinstance)
    VAR `next_pcounter = `instruction[1]
    THIS.`_pcounter = `next_pcounter

  METHOD `_istmtDebugl(`instruction):
    VAR `next_pcounter = `instruction[1]
    VAR `debuglexprs = `instruction[2]
    VAR `debugl_message = ""
    VAR `j
    VAR `debuglexpr_j
    VAR `evalue_j
    FORINCR `j(0 `length(`debuglexprs)):
      `debuglexpr_j = `debuglexprs[`j]
      IF `debuglexpr_j[0] == `OPCODE_STRING:
        `debugl_message += `debuglexpr_j[1]
        continue
      ENDIF
      `evalue_j = THIS.`_interpExpr(`debuglexpr_j)
      `debugl_message += `utils.`stringify(`evalue_j)
    ENDFOR
    THIS.`_error = NULL
    VAR `debugl_lines = `split(`debugl_message, `chr_lf)
    VAR `debugl_line
    FORINCR `j(0 `length(`debugl_lines)):
      IF `not(`isnull(THIS.`_max_debugl_lines)) AND (`length(THIS.`_debugl_lines) >= THIS.`_max_debugl_lines):
        `unqueue(THIS.`_debugl_lines)
      ENDIF
      `debugl_line = `debugl_lines[`j]
      IF `not(`isnull(THIS.`_max_debugl_chars_per_line)) AND (`length(`debugl_line) > THIS.`_max_debugl_chars_per_line):
        `debugl_line = `substring(`debugl_line, 0, THIS.`_max_debugl_chars_per_line-3)+"..."
      ENDIF
      `push(THIS.`_debugl_lines, `debugl_line)
    ENDFOR
    THIS.`_pcounter = `next_pcounter

  METHOD `_interpExpr(`expression):
    VAR `opcode = `expression[0]
    return THIS.`_dispatch_expr[`opcode](`expression)

  METHOD `_iexprNumber(`expression):
    VAR `n = `expression[1]
    THIS.`_tmpNumber[1] = `n
    return THIS.`_tmpNumber

  METHOD `_iexprList(`expression):
    VAR `exprs = `expression[1]
    VAR `nsize = 0
    VAR `lsize = 1
    VAR `lvalue = []
    VAR `j
    VAR `evalue
    FORINCR `j(0 `length(`exprs)):
      `evalue = `utils.`deepCopy(THIS.`_interpExpr(`exprs[`j]))
      IF `isnull(`evalue):
        return NULL
      ENDIF
      `push(`lvalue, `evalue)
      `nsize += `utils.`nsizeEvalue(`evalue)
      `lsize += `utils.`lsizeEvalue(`evalue)
    ENDFOR
    return [`key_interp_list, `lvalue, `lsize, `nsize]

  METHOD `_iexprOr(`expression):
    VAR `exprs = `expression[1]
    VAR `j
    VAR `evalue
    FORINCR `j(0 `length(`exprs)):
      `evalue = THIS.`_interpExpr(`exprs[`j])
      IF `isnull(`evalue):
        return NULL
      ENDIF
      IF `evalue[1]:
        THIS.`_tmpBoolean[1] = TRUE
        return THIS.`_tmpBoolean
      ENDIF
    ENDFOR
    THIS.`_tmpBoolean[1] = FALSE
    return THIS.`_tmpBoolean

  METHOD `_iexprAnd(`expression):
    VAR `exprs = `expression[1]
    VAR `j
    VAR `evalue
    FORINCR `j(0 `length(`exprs)):
      `evalue = THIS.`_interpExpr(`exprs[`j])
      IF `isnull(`evalue):
        return NULL
      ENDIF
      IF `not(`evalue[1]):
        THIS.`_tmpBoolean[1] = FALSE
        return THIS.`_tmpBoolean
      ENDIF
    ENDFOR
    THIS.`_tmpBoolean[1] = TRUE
    return THIS.`_tmpBoolean

  METHOD `_iexprNot(`expression):
    VAR `expr = `expression[1]
    VAR `evalue = THIS.`_interpExpr(`expr)
    IF `isnull(`evalue):
      return NULL
    ENDIF
    THIS.`_tmpBoolean[1] = `not(`evalue[1])
    return THIS.`_tmpBoolean

  METHOD `_iexprRelOp(`expression `binOp):
    VAR `expr1 = `expression[1]
    VAR `expr2 = `expression[2]
    VAR `evalue1 = THIS.`_interpExpr(`expr1)
    IF `isnull(`evalue1):
      return NULL
    ENDIF
    VAR `isNumberExpr1 = (`evalue1[0] == `key_interp_number)
    VAR `evalue1n = `evalue1[1]
    VAR `evalue2 = THIS.`_interpExpr(`expr2)
    IF `isnull(`evalue2):
      return NULL
    ENDIF
    VAR `value
    IF `isNumberExpr1:
      IF `evalue2[0] == `key_interp_number:
        `value = `binOp(`evalue1n, `evalue2[1])
      ELSE:
        `value = `binOp(0, 1)
      ENDIF
    ELSE:
      `value = THIS.`_iexprRelOp_cmp(`evalue1, `evalue2)
      IF `value == 0:
        `value = `binOp(0, 0)
      ELSIF `value < 0:
        `value = `binOp(0, 1)
      ELSE:
        `value = `binOp(1, 0)
      ENDIF
    ENDIF
    THIS.`_tmpBoolean[1] = `value
    return THIS.`_tmpBoolean

  METHOD `_iexprRelOp_cmp(`evalue1 `evalue2):
    IF `evalue1[0] == `key_interp_number:
      IF `evalue2[0] == `key_interp_number:
        IF `evalue1[1] == `evalue2[1]:
          return 0
        ELSIF `evalue1[1] < `evalue2[1]:
          return -1
        ELSE:
          return 1
        ENDIF
      ENDIF
      return -1
    ENDIF
    IF `evalue2[0] == `key_interp_number:
      return 1
    ENDIF
    VAR `j
    VAR `value
    VAR `len1 = `length(`evalue1[1])
    VAR `len2 = `length(`evalue2[1])
    IF `len1 <= `len2:
      FORINCR `j(0 `len1):
        `value = THIS.`_iexprRelOp_cmp(`evalue1[1][`j], `evalue2[1][`j])
        IF `value != 0:
          return `value
        ENDIF
      ENDFOR
      IF `len1 < `len2:
        return -1
      ENDIF
      return 0
    ENDIF
    FORINCR `j(0 `len2):
      `value = THIS.`_iexprRelOp_cmp(`evalue1[1][`j], `evalue2[1][`j])
      IF `value != 0:
        return `value
      ENDIF
    ENDFOR
    return 1

  METHOD `_iexprUnaryOp(`expression `unaryOp):
    VAR `expr = `expression[1]
    VAR `evalue = THIS.`_interpExpr(`expr)
    IF `isnull(`evalue):
      return NULL
    ENDIF
    IF `evalue[0] != `key_interp_number:
      THIS.`_setRuntimeError("EXPECTED"+" "+"NUMBER")
      return NULL
    ENDIF
    VAR `value = `unaryOp(`evalue[1])
    THIS.`_tmpNumber[1] = `value
    return THIS.`_tmpNumber

  METHOD `_iexprAddOp(`expression `binOp):
    VAR `expr1 = `expression[1]
    VAR `expr2 = `expression[2]
    VAR `evalue1 = THIS.`_interpExpr(`expr1)
    IF `isnull(`evalue1):
      return NULL
    ENDIF
    IF `evalue1[0] != `key_interp_number:
      THIS.`_setRuntimeError("EXPECTED"+" "+"NUMBER")
      return NULL
    ENDIF
    VAR `evalue1n = `evalue1[1]
    VAR `evalue2 = THIS.`_interpExpr(`expr2)
    IF `isnull(`evalue2):
      return NULL
    ENDIF
    IF `evalue2[0] != `key_interp_number:
      THIS.`_setRuntimeError("EXPECTED"+" "+"NUMBER")
      return NULL
    ENDIF
    VAR `value = `binOp(`evalue1n, `evalue2[1])
    THIS.`_tmpNumber[1] = `value
    return THIS.`_tmpNumber

  METHOD `_iexprMulOp(`expression `binOp):
    VAR `expr1 = `expression[1]
    VAR `expr2 = `expression[2]
    VAR `evalue1 = THIS.`_interpExpr(`expr1)
    IF `isnull(`evalue1):
      return NULL
    ENDIF
    IF `evalue1[0] != `key_interp_number:
      THIS.`_setRuntimeError("EXPECTED"+" "+"NUMBER")
      return NULL
    ENDIF
    VAR `evalue1n = `evalue1[1]
    VAR `evalue2 = THIS.`_interpExpr(`expr2)
    IF `isnull(`evalue2):
      return NULL
    ENDIF
    IF `evalue2[0] != `key_interp_number:
      THIS.`_setRuntimeError("EXPECTED"+" "+"NUMBER")
      return NULL
    ENDIF
    VAR `value = `binOp(`evalue1n, `evalue2[1])
    THIS.`_tmpNumber[1] = `value
    return THIS.`_tmpNumber

  METHOD `_iexprByRef(`expression):
    VAR `vvar = `expression[1][0]
    VAR `vmod = `expression[1][1]
    VAR `values = [`vvar, `vmod]
    VAR `lindex
    VAR `lindexn
    VAR `j
    FORINCR `j(2 `length(`expression[1])):
      `lindex = THIS.`_interpExpr(`expression[1][`j])
      IF `isnull(`lindex):
        return NULL
      ENDIF
      IF `lindex[0] != `key_interp_number:
        THIS.`_setRuntimeError("INVALID"+" "+"INDEX")
        return NULL
      ENDIF
      `lindexn = `fp[0].FloorToInt(`lindex[1])
      `push(`values, `lindexn)
    ENDFOR
    THIS.`_tmpByRef[1] = `values
    return THIS.`_tmpByRef

  METHOD `_iexprModuleName(`expression):
    VAR `module_name = `expression[1]
    THIS.`_tmpModuleName[1] = `module_name
    return THIS.`_tmpModuleName

  METHOD `_iexprString(`expression):
    VAR `str_ = `expression[1]
    THIS.`_tmpString[1] = `str_
    return THIS.`_tmpString

  METHOD `_iexprVar(`expression):
    VAR `vvar = `expression[1]
    VAR `evalue = THIS.`getVar(`vvar)
    IF `isnull(`evalue):
      THIS.`_setRuntimeError("UNDEFINED"+" "+"VARIABLE")
      return NULL
    ENDIF
    IF (`evalue[0] != `key_interp_number) AND (`evalue[0] != `key_interp_list):
      THIS.`_setRuntimeError("EXPECTED"+" "+"NUMBER"+" "+"OR"+" "+"LIST")
      return NULL
    ENDIF
    return `evalue

  METHOD `_iexprQualvar(`expression):
    VAR `vvar = `expression[1]
    VAR `evalue = THIS.`_getQualvar(`vvar)
    IF `isnull(`evalue):
      THIS.`_setRuntimeError("UNDEFINED"+" "+"VARIABLE")
      return NULL
    ENDIF
    IF (`evalue[0] != `key_interp_number) AND (`evalue[0] != `key_interp_list):
      THIS.`_setRuntimeError("EXPECTED"+" "+"NUMBER"+" "+"OR"+" "+"LIST")
      return NULL
    ENDIF
    return `evalue

  METHOD `_iexprCsvar(`expression):
    VAR `vvar = `expression[1]
    VAR `vmod = `expression[2]
    VAR `csinstance = THIS.`_getCsinstance(`vvar, `vmod, THIS.`_instance)
    IF `isnull(`csinstance):
      THIS.`_setRuntimeError("INVALID"+" "+"CALLSTACK"+" "+"VARIABLE")
      return NULL
    ENDIF
    IF `csinstance == THIS.`_instance:
      return THIS.`_iexprVar(`expression)
    ENDIF
    VAR `evalue = THIS.`_getInstanceCsvar(`csinstance, `vvar)
    IF `isnull(`evalue):
      THIS.`_setRuntimeError("UNDEFINED"+" "+"CALLSTACK"+" "+"VARIABLE")
      return NULL
    ENDIF
    IF (`evalue[0] != `key_interp_number) AND (`evalue[0] != `key_interp_list):
      THIS.`_setRuntimeError("EXPECTED"+" "+"NUMBER"+" "+"OR"+" "+"LIST")
      return NULL
    ENDIF
    return `evalue

  METHOD `_iexprIsVar(`expression):
    VAR `vvarexprs = `expression[1]
    VAR `vvar_typetokenid = `expression[2]
    VAR `vvar = `vvarexprs[1]
    VAR `evalue
    IF `vvarexprs[0] == `OPCODE_VAR:
      `evalue = THIS.`getVar(`vvar)
    ELSIF `vvarexprs[0] == `OPCODE_QUALVAR:
      `evalue = THIS.`_getQualvar(`vvar)
    ELSE:
      `evalue = THIS.`_interpExpr(`vvarexprs)
      IF `isnull(`evalue):
        return NULL
      ENDIF
    ENDIF
    IF `isnull(`evalue):
      THIS.`_tmpBoolean[1] = (`vvar_typetokenid == `key_token_UNDEFINED)
      return THIS.`_tmpBoolean
    ENDIF
    IF `evalue[0] == `key_interp_number:
      THIS.`_tmpBoolean[1] = (`vvar_typetokenid == `key_token_NUMBER)
      return THIS.`_tmpBoolean
    ENDIF
    IF `evalue[0] == `key_interp_list:
      THIS.`_tmpBoolean[1] = ((`vvar_typetokenid == `key_token_LIST) OR ((`vvar_typetokenid == `key_token_EMPTY) AND (`length(`evalue[1]) == 0)))
      return THIS.`_tmpBoolean
    ENDIF
    IF `evalue[0] == `key_interp_procedure:
      THIS.`_tmpBoolean[1] = (`vvar_typetokenid == `key_token_PROCEDURE)
      return THIS.`_tmpBoolean
    ENDIF
    THIS.`_tmpBoolean[1] = FALSE
    return THIS.`_tmpBoolean

  METHOD `_iexprIsNotVar(`expression):
    VAR `vvarexprs = `expression[1]
    VAR `vvar_typetokenid = `expression[2]
    VAR `vvar = `vvarexprs[1]
    VAR `evalue
    IF `vvarexprs[0] == `OPCODE_VAR:
      `evalue = THIS.`getVar(`vvar)
    ELSIF `vvarexprs[0] == `OPCODE_QUALVAR:
      `evalue = THIS.`_getQualvar(`vvar)
    ELSE:
      `evalue = THIS.`_interpExpr(`vvarexprs)
      IF `isnull(`evalue):
        return NULL
      ENDIF
    ENDIF
    IF `isnull(`evalue):
      THIS.`_tmpBoolean[1] = (`vvar_typetokenid != `key_token_UNDEFINED)
      return THIS.`_tmpBoolean
    ENDIF
    IF `evalue[0] == `key_interp_number:
      THIS.`_tmpBoolean[1] = (`vvar_typetokenid != `key_token_NUMBER)
      return THIS.`_tmpBoolean
    ENDIF
    IF `evalue[0] == `key_interp_list:
      THIS.`_tmpBoolean[1] = ((`vvar_typetokenid != `key_token_LIST) AND ((`vvar_typetokenid != `key_token_EMPTY) OR (`length(`evalue[1]) > 0)))
      return THIS.`_tmpBoolean
    ENDIF
    IF `evalue[0] == `key_interp_procedure:
      THIS.`_tmpBoolean[1] = (`vvar_typetokenid != `key_token_PROCEDURE)
      return THIS.`_tmpBoolean
    ENDIF
    THIS.`_tmpBoolean[1] = TRUE
    return THIS.`_tmpBoolean

  METHOD `_iexprIsCsvar(`expression):
    VAR `vvarexprs = `expression[1]
    VAR `vvar_typetokenid = `expression[2]
    VAR `vvar = `vvarexprs[1]
    VAR `vmod
    VAR `csinstance
    VAR `evalue
    IF `vvarexprs[0] == `OPCODE_CSVAR:
      `vmod = `vvarexprs[2]
      `csinstance = THIS.`_getCsinstance(`vvar, `vmod, THIS.`_instance)
      IF `isnull(`csinstance):
        THIS.`_setRuntimeError("INVALID"+" "+"CALLSTACK"+" "+"VARIABLE")
        return NULL
      ENDIF
      `evalue = THIS.`_getInstanceCsvar(`csinstance, `vvar)
    ELSE:
      `evalue = THIS.`_interpExpr(`vvarexprs)
      IF `isnull(`evalue):
        return NULL
      ENDIF
    ENDIF
    IF `isnull(`evalue):
      THIS.`_tmpBoolean[1] = (`vvar_typetokenid == `key_token_UNDEFINED)
      return THIS.`_tmpBoolean
    ENDIF
    IF `evalue[0] == `key_interp_number:
      THIS.`_tmpBoolean[1] = (`vvar_typetokenid == `key_token_NUMBER)
      return THIS.`_tmpBoolean
    ENDIF
    IF `evalue[0] == `key_interp_list:
      THIS.`_tmpBoolean[1] = ((`vvar_typetokenid == `key_token_LIST) OR ((`vvar_typetokenid == `key_token_EMPTY) AND (`length(`evalue[1]) == 0)))
      return THIS.`_tmpBoolean
    ENDIF
    IF `evalue[0] == `key_interp_procedure:
      THIS.`_tmpBoolean[1] = (`vvar_typetokenid == `key_token_PROCEDURE)
      return THIS.`_tmpBoolean
    ENDIF
    THIS.`_tmpBoolean[1] = FALSE
    return THIS.`_tmpBoolean

  METHOD `_iexprIsNotCsvar(`expression):
    VAR `vvarexprs = `expression[1]
    VAR `vvar_typetokenid = `expression[2]
    VAR `vvar = `vvarexprs[1]
    VAR `vmod
    VAR `csinstance
    VAR `evalue
    IF `vvarexprs[0] == `OPCODE_CSVAR:
      `vmod = `vvarexprs[2]
      `csinstance = THIS.`_getCsinstance(`vvar, `vmod, THIS.`_instance)
      IF `isnull(`csinstance):
        THIS.`_setRuntimeError("INVALID"+" "+"CALLSTACK"+" "+"VARIABLE")
        return NULL
      ENDIF
      `evalue = THIS.`_getInstanceCsvar(`csinstance, `vvar)
    ELSE:
      `evalue = THIS.`_interpExpr(`vvarexprs)
      IF `isnull(`evalue):
        return NULL
      ENDIF
    ENDIF
    IF `isnull(`evalue):
      THIS.`_tmpBoolean[1] = (`vvar_typetokenid != `key_token_UNDEFINED)
      return THIS.`_tmpBoolean
    ENDIF
    IF `evalue[0] == `key_interp_number:
      THIS.`_tmpBoolean[1] = (`vvar_typetokenid != `key_token_NUMBER)
      return THIS.`_tmpBoolean
    ENDIF
    IF `evalue[0] == `key_interp_list:
      THIS.`_tmpBoolean[1] = ((`vvar_typetokenid != `key_token_LIST) AND ((`vvar_typetokenid != `key_token_EMPTY) OR (`length(`evalue[1]) > 0)))
      return THIS.`_tmpBoolean
    ENDIF
    IF `evalue[0] == `key_interp_procedure:
      THIS.`_tmpBoolean[1] = (`vvar_typetokenid != `key_token_PROCEDURE)
      return THIS.`_tmpBoolean
    ENDIF
    THIS.`_tmpBoolean[1] = TRUE
    return THIS.`_tmpBoolean

  METHOD `_iexprLengthVar(`expression):
    VAR `vvarexprs = `expression[1]
    VAR `evalue = THIS.`_interpExpr(`vvarexprs)
    IF `isnull(`evalue):
      return NULL
    ENDIF
    IF `evalue[0] != `key_interp_list:
      THIS.`_setRuntimeError("EXPECTED"+" "+"LIST")
      return NULL
    ENDIF
    VAR `lenn = `length(`evalue[1])
    IF `lenn > 0x7fff:
      THIS.`_setRuntimeError("VALUE"+" "+"EXCEEDS"+" "+"NUMERIC"+" "+"TYPE")
      return NULL
    ENDIF
    THIS.`_tmpNumber[1] = `fp[0].FromFloat(`lenn)
    return THIS.`_tmpNumber

  METHOD `_iexprSizeVar(`expression `projection):
    VAR `vvarexprs = `expression[1]
    VAR `evalue = THIS.`_interpExpr(`vvarexprs)
    IF `isnull(`evalue):
      return NULL
    ENDIF
    IF (`evalue[0] != `key_interp_number) AND (`evalue[0] != `key_interp_list):
      THIS.`_setRuntimeError("EXPECTED"+" "+"NUMBER"+" "+"OR"+" "+"LIST")
      return NULL
    ENDIF
    VAR `value = `projection(`utils.`lsizeEvalue(`evalue), `utils.`nsizeEvalue(`evalue))
    IF `value > 0x7fff:
      THIS.`_setRuntimeError("VALUE"+" "+"EXCEEDS"+" "+"NUMERIC"+" "+"TYPE")
      return NULL
    ENDIF
    THIS.`_tmpNumber[1] = `fp[0].FromFloat(`value)
    return THIS.`_tmpNumber

  METHOD `_iexprIndexofVar(`expression):
    VAR `vvarexprs = `expression[1]
    VAR `expr = `expression[2]
    VAR `ariexpr = `expression[3]
    VAR `evalue = THIS.`_interpExpr(`vvarexprs)
    IF `isnull(`evalue):
      return NULL
    ENDIF
    IF `evalue[0] != `key_interp_list:
      THIS.`_setRuntimeError("EXPECTED"+" "+"LIST")
      return NULL
    ENDIF
    VAR `varvalue = `utils.`decodeData(`evalue)
    VAR `from = THIS.`_interpExpr(`ariexpr)
    IF `isnull(`from):
      return NULL
    ENDIF
    IF `from[0] != `key_interp_number:
      THIS.`_setRuntimeError("EXPECTED"+" "+"NUMBER")
      return NULL
    ENDIF
    VAR `fromn = `fp[0].FloorToInt(`from[1])
    VAR `indexof_ = THIS.`_interpExpr(`expr)
    IF `isnull(`indexof_):
      return NULL
    ENDIF
    IF (`indexof_[0] != `key_interp_number) AND (`indexof_[0] != `key_interp_list):
      THIS.`_setRuntimeError("INVALID"+" "+"INDEXOF"+" "+"EXPRESSION")
      return NULL
    ENDIF
    VAR `indexofvalue = `utils.`decodeData(`indexof_)
    VAR `result
    IF `isnull(`varvalue) OR `isnull(`indexofvalue):
      `result = -1
    ELSE:
      `result = `utils.`structuralIndexOf(`varvalue[1], `indexofvalue[1], `fromn)
    ENDIF
    IF `result > 0x7fff:
      THIS.`_setRuntimeError("VALUE"+" "+"EXCEEDS"+" "+"NUMERIC"+" "+"TYPE")
      return NULL
    ENDIF
    THIS.`_tmpNumber[1] = `fp[0].FromFloat(`result)
    return THIS.`_tmpNumber

  METHOD `_iexprListAtList(`expression):
    VAR `exprs = `expression[1]
    VAR `nsize = 0
    VAR `lsize = 1
    VAR `lvalue = []
    VAR `j
    VAR `evalue
    FORINCR `j(0 `length(`exprs)):
      `evalue = `utils.`deepCopy(THIS.`_interpExpr(`exprs[`j]))
      IF `isnull(`evalue):
        return NULL
      ENDIF
      `push(`lvalue, `evalue)
      `nsize += `utils.`nsizeEvalue(`evalue)
      `lsize += `utils.`lsizeEvalue(`evalue)
    ENDFOR
    `evalue = [`key_interp_list, `lvalue, `lsize, `nsize]
    VAR `idxexprs = `expression[2]
    VAR `lindex
    VAR `lindexn
    FORINCR `j(0 `length(`idxexprs)):
      IF `evalue[0] != `key_interp_list:
        THIS.`_setRuntimeError("EXPECTED"+" "+"LIST")
        return NULL
      ENDIF
      `lindex = THIS.`_interpExpr(`idxexprs[`j])
      IF `isnull(`lindex):
        return NULL
      ENDIF
      IF `lindex[0] != `key_interp_number:
        THIS.`_setRuntimeError("INVALID"+" "+"INDEX")
        return NULL
      ENDIF
      `lindexn = `fp[0].FloorToInt(`lindex[1])
      IF (`lindexn < 0) OR (`lindexn >= `length(`evalue[1])):
        THIS.`_setRuntimeError("INDEX"+" "+"OUT-OF-RANGE")
        return NULL
      ENDIF
      `evalue = `evalue[1][`lindexn]
    ENDFOR
    return `evalue

  METHOD `_iexprListAtVar(`expression):
    VAR `vvar = `expression[1]
    VAR `exprs = `expression[2]
    VAR `evalue = THIS.`getVar(`vvar)
    IF `isnull(`evalue):
      THIS.`_setRuntimeError("UNDEFINED"+" "+"VARIABLE")
      return NULL
    ENDIF
    VAR `lindex
    VAR `lindexn
    VAR `j
    FORINCR `j(0 `length(`exprs)):
      IF `evalue[0] != `key_interp_list:
        THIS.`_setRuntimeError("EXPECTED"+" "+"LIST")
        return NULL
      ENDIF
      `lindex = THIS.`_interpExpr(`exprs[`j])
      IF `isnull(`lindex):
        return NULL
      ENDIF
      IF `lindex[0] != `key_interp_number:
        THIS.`_setRuntimeError("INVALID"+" "+"INDEX")
        return NULL
      ENDIF
      `lindexn = `fp[0].FloorToInt(`lindex[1])
      IF (`lindexn < 0) OR (`lindexn >= `length(`evalue[1])):
        THIS.`_setRuntimeError("INDEX"+" "+"OUT-OF-RANGE")
        return NULL
      ENDIF
      `evalue = `evalue[1][`lindexn]
    ENDFOR
    return `evalue

  METHOD `_iexprListAtQualvar(`expression):
    VAR `vvar = `expression[1]
    VAR `exprs = `expression[2]
    VAR `evalue = THIS.`_getQualvar(`vvar)
    IF `isnull(`evalue):
      THIS.`_setRuntimeError("UNDEFINED"+" "+"VARIABLE")
      return NULL
    ENDIF
    VAR `lindex
    VAR `lindexn
    VAR `j
    FORINCR `j(0 `length(`exprs)):
      IF `evalue[0] != `key_interp_list:
        THIS.`_setRuntimeError("EXPECTED"+" "+"LIST")
        return NULL
      ENDIF
      `lindex = THIS.`_interpExpr(`exprs[`j])
      IF `isnull(`lindex):
        return NULL
      ENDIF
      IF `lindex[0] != `key_interp_number:
        THIS.`_setRuntimeError("INVALID"+" "+"INDEX")
        return NULL
      ENDIF
      `lindexn = `fp[0].FloorToInt(`lindex[1])
      IF (`lindexn < 0) OR (`lindexn >= `length(`evalue[1])):
        THIS.`_setRuntimeError("INDEX"+" "+"OUT-OF-RANGE")
        return NULL
      ENDIF
      `evalue = `evalue[1][`lindexn]
    ENDFOR
    return `evalue

  METHOD `_iexprListAtCsvar(`expression):
    VAR `vvar = `expression[1]
    VAR `vmod = `expression[3]
    VAR `csinstance = THIS.`_getCsinstance(`vvar, `vmod, THIS.`_instance)
    IF `isnull(`csinstance):
      THIS.`_setRuntimeError("INVALID"+" "+"CALLSTACK"+" "+"VARIABLE")
      return NULL
    ENDIF
    IF `csinstance == THIS.`_instance:
      return THIS.`_iexprListAtVar(`expression)
    ENDIF
    VAR `evalue = THIS.`_getInstanceCsvar(`csinstance, `vvar)
    IF `isnull(`evalue):
      THIS.`_setRuntimeError("UNDEFINED"+" "+"CALLSTACK"+" "+"VARIABLE")
      return NULL
    ENDIF
    VAR `exprs = `expression[2]
    VAR `lindex
    VAR `lindexn
    VAR `j
    FORINCR `j(0 `length(`exprs)):
      IF `evalue[0] != `key_interp_list:
        THIS.`_setRuntimeError("EXPECTED"+" "+"LIST")
        return NULL
      ENDIF
      `lindex = THIS.`_interpExpr(`exprs[`j])
      IF `isnull(`lindex):
        return NULL
      ENDIF
      IF `lindex[0] != `key_interp_number:
        THIS.`_setRuntimeError("INVALID"+" "+"INDEX")
        return NULL
      ENDIF
      `lindexn = `fp[0].FloorToInt(`lindex[1])
      IF (`lindexn < 0) OR (`lindexn >= `length(`evalue[1])):
        THIS.`_setRuntimeError("INDEX"+" "+"OUT-OF-RANGE")
        return NULL
      ENDIF
      `evalue = `evalue[1][`lindexn]
    ENDFOR
    return `evalue

  METHOD `_iexprMathOp(`expression `mathOp):
    VAR `expr1
    VAR `evalue1
    VAR `evalue1n
    VAR `value
    IF `length(`expression[1]) == 1:
      `expr1 = `expression[1][0]
      `evalue1 = THIS.`_interpExpr(`expr1)
      IF `evalue1[0] != `key_interp_number:
        THIS.`_setRuntimeError("EXPECTED"+" "+"NUMBER")
        return NULL
      ENDIF
      `evalue1n = `evalue1[1]
      `value = `mathOp(`evalue1n)
      THIS.`_tmpNumber[1] = `value
      return THIS.`_tmpNumber
    ENDIF
    VAR `expr2
    VAR `evalue2
    IF `length(`expression[1]) == 2:
      `expr1 = `expression[1][0]
      `evalue1 = THIS.`_interpExpr(`expr1)
      IF `evalue1[0] != `key_interp_number:
        THIS.`_setRuntimeError("EXPECTED"+" "+"NUMBER")
        return NULL
      ENDIF
      `evalue1n = `evalue1[1]
      `expr2 = `expression[1][1]
      `evalue2 = THIS.`_interpExpr(`expr2)
      IF `evalue2[0] != `key_interp_number:
        THIS.`_setRuntimeError("EXPECTED"+" "+"NUMBER")
        return NULL
      ENDIF
      `value = `mathOp(`evalue1n, `evalue2[1])
      THIS.`_tmpNumber[1] = `value
      return THIS.`_tmpNumber
    ENDIF
    THIS.`_setRuntimeError("NOT"+" "+"IMPLEMENTED")
    return NULL

  METHOD `destroy():
    VAR `x = NULL

ENDCLASS

VAR `key_modules_module_name = 0
VAR `key_modules_module_name_lcase = 1
VAR `key_modules_editor_m = 2
VAR `key_modules_instances = 3

VAR `key_envs_environment = 0
VAR `key_envs_varnames = 1
VAR `key_envs_procnames = 2
VAR `key_envs_instances = 3

VAR `key_instances_interp_m = 0
VAR `key_instances_module = 1
VAR `key_instances_envs = 2
VAR `key_instances_state = 3

CLASS `PrequelM:

  METHOD_INIT(`args):
    VAR `x = NULL

  METHOD `init(`onProcedure `onYieldResume `rnd32b):
    THIS.`_ihandle = NEW `ResourceIds()
    THIS.`_modules = {}
    THIS.`_module_list = []
    THIS.`_instances = {}
    THIS.`_instance_list = []
    THIS.`_envs = {}
    THIS.`_env_list = []
    THIS.`_running_instance = NULL
    THIS.`_ready_instances = []
    THIS.`_limit_instances = []
    THIS.`_pause_instances = []
    THIS.`_yield_instances = []
    THIS.`_error_instances = []
    THIS.`_ended_instances = []
    THIS.`_onProcedure = `onProcedure
    THIS.`_onYieldResume = `onYieldResume
    THIS.`_rnd32b = `rnd32b
    VAR `that = THIS
    CLOSURE `closure_getQualvar(`qualvar):
      IF `isnull(`that.`_running_instance):
        return NULL
      ENDIF
      VAR `instance = `that.`_running_instance
      VAR `envs = `that.`_instances[`instance][`key_instances_envs]
      VAR `j
      VAR `env
      VAR `evalue
      FORDECR `j(`length(`envs)-1 0):
        `env = `envs[`j]
        `evalue = `that.`_envs[`env][`key_envs_environment].`get(`qualvar)
        IF `not(`isnull(`evalue)):
          return `evalue
        ENDIF
      ENDFOR
      return NULL
    ENDCLOSURE
    THIS.`_getQualvar = `closure_getQualvar
    CLOSURE `closure_existsInstanceCsvar(`csinstance `vvar):
      VAR `ivarnames = `that.`getInstanceVarNames(`csinstance)
      return (`indexof(`ivarnames, `vvar) >= 0)
    ENDCLOSURE
    THIS.`_existsInstanceCsvar = `closure_existsInstanceCsvar
    CLOSURE `closure_getInstanceCsvar(`csinstance `vvar):
      VAR `evalue = `that.`getInstanceVar(`csinstance, `vvar)
      return `evalue
    ENDCLOSURE
    THIS.`_getInstanceCsvar = `closure_getInstanceCsvar
    CLOSURE `closure_addInstanceCsvar(`instance `vvar `evalue `csinstance):
      return `that.`addInstanceCsvar(`instance, `vvar, `evalue, `csinstance)
    ENDCLOSURE
    THIS.`_addInstanceCsvar = `closure_addInstanceCsvar
    CLOSURE `closure_removeInstanceCsvar(`instance `vvar `csinstance):
      `that.`removeInstanceCsvar(`instance, `vvar, `csinstance)
    ENDCLOSURE
    THIS.`_removeInstanceCsvar = `closure_removeInstanceCsvar
    CLOSURE `closure_updateInstanceCsvarDeltaCost(`instance `vvar `csinstance `delta_cost_n `delta_cost_l):
      `that.`updateInstanceCsvarDeltaCost(`instance, `vvar, `csinstance, `delta_cost_n, `delta_cost_l)
    ENDCLOSURE
    THIS.`_updateInstanceCsvarDeltaCost = `closure_updateInstanceCsvarDeltaCost
    CLOSURE `closure_inInstanceRepeatCsvars(`csinstance `vvar):
      return `that.`inRepeatVars(`csinstance, `vvar)
    ENDCLOSURE
    THIS.`_inInstanceRepeatCsvars = `closure_inInstanceRepeatCsvars
    CLOSURE `closure_isCsinstanceStatusCodeNull(`csinstance):
      return `isnull(`that.`getStatusCode(`csinstance))
    ENDCLOSURE
    THIS.`_isCsinstanceStatusCodeNull = `closure_isCsinstanceStatusCodeNull
    CLOSURE `closure_getCsinstance(`vvar `vmod `instance):
      return `instance
    ENDCLOSURE
    THIS.`_getCsinstance = `closure_getCsinstance

  METHOD `setCallbacks(`onProcedure `onYieldResume `rnd32b):
    THIS.`_onProcedure = `onProcedure
    THIS.`_onYieldResume = `onYieldResume
    THIS.`_rnd32b = `rnd32b

  METHOD `setCbGetCsinstance(`cbGetCsinstance):
    THIS.`_getCsinstance = `cbGetCsinstance

  METHOD `getModules():
    return THIS.`_module_list

  METHOD `openModule(`source_code `module_name):
    VAR `j
    VAR `module_idx
    VAR `module_j
    VAR `module_name_lcase
    VAR `num
    VAR `ok
    VAR `prefix
    IF `isnull(`module_name):
      `prefix = "untitled"
      `num = 1
      WHILE TRUE:
        `ok = TRUE
        `module_name = `prefix+`str(`num)
        `module_name_lcase = `lowercase(`module_name)
        `module_idx = `length(THIS.`_module_list)
        FORINCR `j(0 `length(THIS.`_module_list)):
          `module_j = THIS.`_module_list[`j]
          IF THIS.`_modules[`module_j][`key_modules_module_name_lcase] < `module_name_lcase:
            continue
          ENDIF
          IF THIS.`_modules[`module_j][`key_modules_module_name_lcase] > `module_name_lcase:
            `module_idx = `j
            break
          ENDIF
          `ok = FALSE
          break
        ENDFOR
        IF `ok:
          break
        ENDIF
        `num += 1
      ENDWHILE
    ELSE:
      `module_name_lcase = `lowercase(`module_name)
      `module_idx = `length(THIS.`_module_list)
      FORINCR `j(0 `length(THIS.`_module_list)):
        `module_j = THIS.`_module_list[`j]
        IF THIS.`_modules[`module_j][`key_modules_module_name_lcase] < `module_name_lcase:
          continue
        ENDIF
        `module_idx = `j
        break
      ENDFOR
    ENDIF
    VAR `module = THIS.`_ihandle.`alloc()
    VAR `editor_m = NEW `EditorM(`source_code)
    `poke(THIS.`_module_list, `module_idx, `module)
    THIS.`_modules[`module] = {}
    THIS.`_modules[`module][`key_modules_module_name] = `module_name
    THIS.`_modules[`module][`key_modules_module_name_lcase] = `module_name_lcase
    THIS.`_modules[`module][`key_modules_editor_m] = `editor_m
    THIS.`_modules[`module][`key_modules_instances] = []
    return `module

  METHOD `getModuleName(`module):
    return THIS.`_modules[`module][`key_modules_module_name]

  METHOD `getModuleNameLcase(`module):
    return THIS.`_modules[`module][`key_modules_module_name_lcase]

  METHOD `renameModule(`module `module_name):
    THIS.`_modules[`module][`key_modules_module_name] = `module_name
    THIS.`_modules[`module][`key_modules_module_name_lcase] = `lowercase(`module_name)

  METHOD `getModuleInstances(`module):
    return THIS.`_modules[`module][`key_modules_instances]

  METHOD `getParserError(`module):
    return THIS.`_modules[`module][`key_modules_editor_m].`getParserError()

  METHOD `getEntryLnno(`module):
    return THIS.`_modules[`module][`key_modules_editor_m].`getEntryLnno()

  METHOD `getSourceCode(`module):
    return THIS.`_modules[`module][`key_modules_editor_m].`getSourceCode()

  METHOD `setSourceCode(`module `source_code):
    THIS.`_modules[`module][`key_modules_editor_m].`setSourceCode(`source_code)

  METHOD `getLnnoCount(`module):
    return THIS.`_modules[`module][`key_modules_editor_m].`getLnnoCount()

  METHOD `getTokens(`module `lnno):
    return THIS.`_modules[`module][`key_modules_editor_m].`getTokens(`lnno)

  METHOD `hasBreakpoint(`module `lnno):
    return THIS.`_modules[`module][`key_modules_editor_m].`hasBreakpoint(`lnno)

  METHOD `setBreakpoint(`module `lnno):
    THIS.`_modules[`module][`key_modules_editor_m].`setBreakpoint(`lnno)

  METHOD `clearBreakpoint(`module `lnno):
    THIS.`_modules[`module][`key_modules_editor_m].`clearBreakpoint(`lnno)

  METHOD `isCompiled(`module):
    return THIS.`_modules[`module][`key_modules_editor_m].`isCompiled()

  METHOD `compile(`module):
    THIS.`_modules[`module][`key_modules_editor_m].`compile()

  METHOD `closeModule(`module):
    VAR `module_idx = `indexof(THIS.`_module_list, `module)
    THIS.`_modules[`module][`key_modules_editor_m].`destroy()
    THIS.`_modules[`module][`key_modules_editor_m] = NULL
    `pick(THIS.`_module_list, `module_idx)
    `delete(THIS.`_modules, `module)
    THIS.`_ihandle.`free(`module)

  METHOD `getEnvs():
    return THIS.`_env_list

  METHOD `createEnv():
    VAR `env = THIS.`_ihandle.`alloc()
    `push(THIS.`_env_list, `env)
    THIS.`_envs[`env] = {}
    THIS.`_envs[`env][`key_envs_environment] = NEW `Environment()
    THIS.`_envs[`env][`key_envs_varnames] = []
    THIS.`_envs[`env][`key_envs_procnames] = []
    THIS.`_envs[`env][`key_envs_instances] = []
    return `env

  METHOD `getEnvInstances(`env):
    return THIS.`_envs[`env][`key_envs_instances]

  METHOD `deleteEnv(`env):
    VAR `env_idx = `indexof(THIS.`_env_list, `env)
    THIS.`_envs[`env][`key_envs_environment].`destroy()
    THIS.`_envs[`env][`key_envs_environment] = NULL
    THIS.`_envs[`env][`key_envs_varnames] = NULL
    THIS.`_envs[`env][`key_envs_procnames] = NULL
    THIS.`_envs[`env][`key_envs_instances] = NULL
    `pick(THIS.`_env_list, `env_idx)
    `delete(THIS.`_envs, `env)
    THIS.`_ihandle.`free(`env)

  METHOD `getInstances():
    return THIS.`_instance_list

  METHOD `addInstance(`module):
    VAR `instance = THIS.`_ihandle.`alloc()
    VAR `interp_m = NEW `InterpM(THIS.`_modules[`module][`key_modules_editor_m], THIS.`_getQualvar, THIS.`_onProcedure, THIS.`_onYieldResume, THIS.`_rnd32b, `instance, THIS.`_existsInstanceCsvar, THIS.`_getInstanceCsvar, THIS.`_addInstanceCsvar, THIS.`_removeInstanceCsvar, THIS.`_updateInstanceCsvarDeltaCost, THIS.`_inInstanceRepeatCsvars, THIS.`_isCsinstanceStatusCodeNull, THIS.`_getCsinstance)
    `push(THIS.`_instance_list, `instance)
    THIS.`_instances[`instance] = {}
    THIS.`_instances[`instance][`key_instances_interp_m] = `interp_m
    THIS.`_instances[`instance][`key_instances_module] = `module
    THIS.`_instances[`instance][`key_instances_envs] = []
    THIS.`_instances[`instance][`key_instances_state] = `INTERP_STATE_READY
    `push(THIS.`_modules[`module][`key_modules_instances], `instance)
    `push(THIS.`_ready_instances, `instance)
    return `instance

  METHOD `cloneInstance(`instance):
    VAR `module = THIS.`_instances[`instance][`key_instances_module]
    VAR `cloned_instance = THIS.`addInstance(`module)
    VAR `instance_envs = THIS.`_instances[`instance][`key_instances_envs]
    VAR `j
    VAR `env
    FORINCR `j(0 `length(`instance_envs)):
      `env = `instance_envs[`j]
      THIS.`pushEnv(`cloned_instance, `env)
    ENDFOR
    VAR `ivarnames = THIS.`getInstanceVarNames(`instance)
    VAR `ivarname
    VAR `ivarvalue
    FORINCR `j(0 `length(`ivarnames)):
      `ivarname = `ivarnames[`j]
      `ivarvalue = THIS.`getInstanceVar(`instance, `ivarname)
      THIS.`addInstanceVar(`cloned_instance, `ivarname, `ivarvalue)
    ENDFOR
    return `cloned_instance

  METHOD `getInstanceModule(`instance):
    return THIS.`_instances[`instance][`key_instances_module]

  METHOD `getInstanceEnvs(`instance):
    return THIS.`_instances[`instance][`key_instances_envs]

  METHOD `getInstanceState(`instance):
    return THIS.`_instances[`instance][`key_instances_state]

  METHOD `removeInstance(`instance):
    THIS.`_instances[`instance][`key_instances_interp_m].`destroy()
    VAR `module = THIS.`_instances[`instance][`key_instances_module]
    VAR `module_instance_idx = `indexof(THIS.`_modules[`module][`key_modules_instances], `instance)
    `pick(THIS.`_modules[`module][`key_modules_instances], `module_instance_idx)
    VAR `envs = THIS.`_instances[`instance][`key_instances_envs]
    VAR `j
    VAR `env
    VAR `env_instance_idx
    FORINCR `j(0 `length(`envs)):
      `env = `envs[`j]
      `env_instance_idx = `indexof(THIS.`_envs[`env][`key_envs_instances], `env)
      `pick(THIS.`_envs[`env][`key_envs_instances], `env_instance_idx)
    ENDFOR
    VAR `state = THIS.`_instances[`instance][`key_instances_state]
    VAR `ready_instance_idx
    VAR `limit_instance_idx
    VAR `pause_instance_idx
    VAR `yield_instance_idx
    VAR `error_instance_idx
    VAR `ended_instance_idx
    IF `state == `INTERP_STATE_READY:
      `ready_instance_idx = `indexof(THIS.`_ready_instances, `instance)
      `pick(THIS.`_ready_instances, `ready_instance_idx)
    ELSIF `state == `INTERP_STATE_LIMIT:
      `limit_instance_idx = `indexof(THIS.`_limit_instances, `instance)
      `pick(THIS.`_limit_instances, `limit_instance_idx)
    ELSIF `state == `INTERP_STATE_PAUSE:
      `pause_instance_idx = `indexof(THIS.`_pause_instances, `instance)
      `pick(THIS.`_pause_instances, `pause_instance_idx)
    ELSIF `state == `INTERP_STATE_YIELD:
      `yield_instance_idx = `indexof(THIS.`_yield_instances, `instance)
      `pick(THIS.`_yield_instances, `yield_instance_idx)
    ELSIF `state == `INTERP_STATE_ERROR:
      `error_instance_idx = `indexof(THIS.`_error_instances, `instance)
      `pick(THIS.`_error_instances, `error_instance_idx)
    ELSIF `state == `INTERP_STATE_ENDED:
      `ended_instance_idx = `indexof(THIS.`_ended_instances, `instance)
      `pick(THIS.`_ended_instances, `ended_instance_idx)
    ENDIF
    VAR `instance_idx = `indexof(THIS.`_instance_list, `instance)
    `pick(THIS.`_instance_list, `instance_idx)
    THIS.`_instances[`instance][`key_instances_interp_m] = NULL
    THIS.`_instances[`instance][`key_instances_module] = NULL
    THIS.`_instances[`instance][`key_instances_envs] = NULL
    THIS.`_instances[`instance][`key_instances_state] = NULL
    `delete(THIS.`_instances, `instance)
    THIS.`_ihandle.`free(`instance)

  METHOD `pushEnv(`instance `env):
    `push(THIS.`_instances[`instance][`key_instances_envs], `env)
    `push(THIS.`_envs[`env][`key_envs_instances], `instance)

  METHOD `removeEnv(`instance `env):
    VAR `instance_env_idx = `indexof(THIS.`_instances[`instance][`key_instances_envs], `env)
    `pick(THIS.`_instances[`instance][`key_instances_envs], `instance_env_idx)
    VAR `env_instance_idx = `indexof(THIS.`_envs[`env][`key_envs_instances], `instance)
    `pick(THIS.`_envs[`env][`key_envs_instances], `env_instance_idx)

  METHOD `getVarNames(`env):
    return THIS.`_envs[`env][`key_envs_varnames]

  METHOD `addVar(`env `varname `evalue):
    `push(THIS.`_envs[`env][`key_envs_varnames], `varname)
    THIS.`_envs[`env][`key_envs_environment].`set(`varname, `evalue)

  METHOD `overwriteVar(`env `varname `varvalue):
    return THIS.`_envs[`env][`key_envs_environment].`overwrite(`varname, `varvalue)

  METHOD `getVar(`env `varname):
    return THIS.`_envs[`env][`key_envs_environment].`get(`varname)

  METHOD `removeVar(`env `varname):
    VAR `idx = `indexof(THIS.`_envs[`env][`key_envs_varnames], `varname)
    `pick(THIS.`_envs[`env][`key_envs_varnames], `idx)
    THIS.`_envs[`env][`key_envs_environment].`del(`varname)

  METHOD `getProcedureNames(`env):
    return THIS.`_envs[`env][`key_envs_procnames]

  METHOD `addProcedure(`env `procname `evalue):
    `push(THIS.`_envs[`env][`key_envs_procnames], `procname)
    THIS.`_envs[`env][`key_envs_environment].`set(`procname, `evalue)

  METHOD `removeProcedure(`env `procname):
    VAR `idx = `indexof(THIS.`_envs[`env][`key_envs_procnames], `procname)
    `pick(THIS.`_envs[`env][`key_envs_procnames], `idx)
    THIS.`_envs[`env][`key_envs_environment].`del(`procname)

  METHOD `getInstanceVarNames(`instance):
    return THIS.`_instances[`instance][`key_instances_interp_m].`getVarNames()

  METHOD `addInstanceVar(`instance `ivarname `evalue):
    THIS.`_instances[`instance][`key_instances_interp_m].`addVar(`ivarname, `evalue)

  METHOD `getInstanceVar(`instance `ivarname):
    return THIS.`_instances[`instance][`key_instances_interp_m].`getVar(`ivarname)

  METHOD `removeInstanceVar(`instance `ivarname):
    THIS.`_instances[`instance][`key_instances_interp_m].`removeVar(`ivarname)

  METHOD `addInstanceCsvar(`instance `ivarname `evalue `csinstance):
    VAR `csvarname = `ivarname+"@"+THIS.`getModuleName(THIS.`getInstanceModule(`csinstance))
    THIS.`_instances[`csinstance][`key_instances_interp_m].`addCsvar(`ivarname, `evalue)
    THIS.`_instances[`instance][`key_instances_interp_m].`addCsvarCost(`csvarname, `evalue)

  METHOD `removeInstanceCsvar(`instance `ivarname `csinstance):
    VAR `csvarname = `ivarname+"@"+THIS.`getModuleName(THIS.`getInstanceModule(`csinstance))
    VAR `evalue = THIS.`_instances[`csinstance][`key_instances_interp_m].`removeCsvar(`ivarname)
    THIS.`_instances[`instance][`key_instances_interp_m].`removeCsvarCost(`csvarname, `evalue)

  METHOD `updateInstanceCsvarDeltaCost(`instance `ivarname `csinstance `delta_cost_n `delta_cost_l):
    VAR `csvarname
    IF `instance == `csinstance:
      THIS.`_instances[`instance][`key_instances_interp_m].`updateCsvarDeltaCost(`ivarname, `delta_cost_n, `delta_cost_l)
    ELSE:
      `csvarname = `ivarname+"@"+THIS.`getModuleName(THIS.`getInstanceModule(`csinstance))
      THIS.`_instances[`instance][`key_instances_interp_m].`updateCsvarDeltaCost(`csvarname, `delta_cost_n, `delta_cost_l)
    ENDIF

  METHOD `getRunningInstance():
    return THIS.`_running_instance

  METHOD `getReadyInstances():
    return THIS.`_ready_instances

  METHOD `getLimitInstances():
    return THIS.`_limit_instances

  METHOD `getPauseInstances():
    return THIS.`_pause_instances

  METHOD `getYieldInstances():
    return THIS.`_yield_instances

  METHOD `getErrorInstances():
    return THIS.`_error_instances

  METHOD `getEndedInstances():
    return THIS.`_ended_instances

  METHOD `inRepeatVars(`instance `ivarname):
    return THIS.`_instances[`instance][`key_instances_interp_m].`inRepeatVars(`ivarname)

  METHOD `run(`instance `stepping `limits):
    THIS.`_running_instance = `instance
    VAR `result_list = THIS.`_instances[`instance][`key_instances_interp_m].`run(`instance, `stepping, `limits)
    THIS.`_running_instance = NULL
    VAR `state = `result_list[0]
    THIS.`_updateInstanceState(`instance, `state)
    return `result_list

  METHOD `resume(`instance `stepping `limits):
    VAR `resume_yield = (THIS.`_instances[`instance][`key_instances_state] == `INTERP_STATE_YIELD)
    THIS.`_running_instance = `instance
    VAR `result_list = THIS.`_instances[`instance][`key_instances_interp_m].`resume(`instance, `resume_yield, `stepping, `limits)
    THIS.`_running_instance = NULL
    VAR `state = `result_list[0]
    THIS.`_updateInstanceState(`instance, `state)
    return `result_list

  METHOD `reap(`instance):
    THIS.`_instances[`instance][`key_instances_interp_m].`reap()
    THIS.`_updateInstanceState(`instance, `INTERP_STATE_READY)

  METHOD `reset(`instance):
    THIS.`_instances[`instance][`key_instances_interp_m].`reset()

  METHOD `returnWithStatus(`instance `status_code):
    THIS.`_instances[`instance][`key_instances_interp_m].`returnWithStatus(`status_code)

  METHOD `prequelYield(`instance):
    THIS.`_instances[`instance][`key_instances_interp_m].`prequelYield()

  METHOD `runtimeError(`instance `error_message):
    THIS.`_instances[`instance][`key_instances_interp_m].`runtimeError(`error_message)

  METHOD `getStatusCode(`instance):
    return THIS.`_instances[`instance][`key_instances_interp_m].`getStatusCode()

  METHOD `readDebugl(`instance):
    return THIS.`_instances[`instance][`key_instances_interp_m].`readDebugl()

  METHOD `readChangedVars(`instance):
    return THIS.`_instances[`instance][`key_instances_interp_m].`readChangedVars()

  METHOD `_updateInstanceState(`instance `state):
    VAR `old_state = THIS.`_instances[`instance][`key_instances_state]
    IF `old_state == `state:
      return
    ENDIF
    THIS.`_instances[`instance][`key_instances_state] = `state
    VAR `idx
    IF `old_state == `INTERP_STATE_READY:
      `idx = `indexof(THIS.`_ready_instances, `instance)
      `pick(THIS.`_ready_instances, `idx)
    ELSIF `old_state == `INTERP_STATE_LIMIT:
      `idx = `indexof(THIS.`_limit_instances, `instance)
      `pick(THIS.`_limit_instances, `idx)
    ELSIF `old_state == `INTERP_STATE_PAUSE:
      `idx = `indexof(THIS.`_pause_instances, `instance)
      `pick(THIS.`_pause_instances, `idx)
    ELSIF `old_state == `INTERP_STATE_YIELD:
      `idx = `indexof(THIS.`_yield_instances, `instance)
      `pick(THIS.`_yield_instances, `idx)
    ELSIF `old_state == `INTERP_STATE_ERROR:
      `idx = `indexof(THIS.`_error_instances, `instance)
      `pick(THIS.`_error_instances, `idx)
    ELSIF `old_state == `INTERP_STATE_ENDED:
      `idx = `indexof(THIS.`_ended_instances, `instance)
      `pick(THIS.`_ended_instances, `idx)
    ENDIF
    IF `state == `INTERP_STATE_READY:
      `push(THIS.`_ready_instances, `instance)
    ELSIF `state == `INTERP_STATE_LIMIT:
      `push(THIS.`_limit_instances, `instance)
    ELSIF `state == `INTERP_STATE_PAUSE:
      `push(THIS.`_pause_instances, `instance)
    ELSIF `state == `INTERP_STATE_YIELD:
      `push(THIS.`_yield_instances, `instance)
    ELSIF `state == `INTERP_STATE_ERROR:
      `push(THIS.`_error_instances, `instance)
    ELSIF `state == `INTERP_STATE_ENDED:
      `push(THIS.`_ended_instances, `instance)
    ENDIF

ENDCLASS

CLASS Prequel:

  METHOD_INIT(`onProcedure `onYieldResume `rnd32b `_fp):
    `fp[0] = `_fp
    THIS.`_prequel_m = NEW `PrequelM({})
    THIS.`_prequel_m.`init(`onProcedure, `onYieldResume, `rnd32b)
    THIS.`_error = NULL

  METHOD getVersion():
    return "1.0"

  METHOD setFP(`_fp):
    `fp[0] = `_fp

  METHOD setCallbacks(`onProcedure `onYieldResume `rnd32b):
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `length(`instances) > 0:
      THIS.`_error = "NON"+"-"+"EMPTY"+" "+"INSTANCES"
      return NULL
    ENDIF
    THIS.`_prequel_m.`setCallbacks(`onProcedure, `onYieldResume, `rnd32b)
    return TRUE

  METHOD setCbGetCsinstance(`cbGetCsinstance):
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `length(`instances) > 0:
      THIS.`_error = "NON"+"-"+"EMPTY"+" "+"INSTANCES"
      return NULL
    ENDIF
    THIS.`_prequel_m.`setCbGetCsinstance(`cbGetCsinstance)
    return TRUE

  METHOD getModules():
    return `utils.`deepCopy(THIS.`_prequel_m.`getModules())

  METHOD openModule(`source_code `module_name):
    IF `not(`lexer.`isValidSourceCode(`source_code)):
      THIS.`_error = "INVALID"+" "+"SOURCE"+" "+"CODE"
      return NULL
    ENDIF
    VAR `module_name_lcase
    VAR `modules
    VAR `j
    VAR `module_name_lcase_j
    IF `is_type_str(`get_type(`module_name)):
      IF `length(`module_name) == 0:
        THIS.`_error = "EMPTY"+" "+"MODULE"+" "+"NAME"
        return NULL
      ENDIF
      IF `not(`lexer.`isValidModuleName(`module_name)):
        THIS.`_error = "INVALID"+" "+"CHARACTERS"+" "+"IN"+" "+"MODULE"+" "+"NAME"
        return NULL
      ENDIF
      `module_name_lcase = `lowercase(`module_name)
      `modules = THIS.`_prequel_m.`getModules()
      FORINCR `j(0 `length(`modules)):
        `module_name_lcase_j = THIS.`_prequel_m.`getModuleNameLcase(`modules[`j])
        IF `module_name_lcase_j > `module_name_lcase:
          break
        ENDIF
        IF `module_name_lcase_j == `module_name_lcase:
          THIS.`_error = "DUPLICATE"+" "+"MODULE"+" "+"NAME"
          return NULL
        ENDIF
      ENDFOR
    ELSIF `not(`isnull(`module_name)):
      THIS.`_error = "INVALID"+" "+"MODULE"+" "+"NAME"
      return NULL
    ENDIF
    VAR `module = THIS.`_prequel_m.`openModule(`source_code, `module_name)
    VAR `parser_error_info = THIS.`_prequel_m.`getParserError(`module)
    VAR `parser_error = {}
    VAR `entry_lnno
    IF `not(`isnull(`parser_error_info)):
      `parser_error["lnno"] = `parser_error_info[1]
      `parser_error["startcol"] = `parser_error_info[2]
      `parser_error["endcol"] = `parser_error_info[3]
      `parser_error["error_message"] = `parser_error_info[4]
    ELSE:
      IF `not(THIS.`_prequel_m.`isCompiled(`module)):
        THIS.`_prequel_m.`compile(`module)
      ENDIF
      `entry_lnno = THIS.`_prequel_m.`getEntryLnno(`module)
      IF `entry_lnno < 0:
        `parser_error["lnno"] = -1
        `parser_error["startcol"] = -1
        `parser_error["endcol"] = -1
        `parser_error["error_message"] = "NO"+" "+"INSTRUCTION"+" "+"FOUND"
      ELSE:
        `parser_error["error_message"] = ""
      ENDIF
    ENDIF
    VAR `result = {}
    `result["module"] = `module
    `result["parser_error"] = `parser_error
    `result["source_code"] = THIS.`_prequel_m.`getSourceCode(`module)
    `result["module_name"] = THIS.`_prequel_m.`getModuleName(`module)
    return `result

  METHOD closeModule(`module):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    VAR `module_instances = THIS.`_prequel_m.`getModuleInstances(`module)
    IF `length(`module_instances) > 0:
      THIS.`_error = "MODULE"+" "+"HAS"+" "+"INSTANCES"
      return NULL
    ENDIF
    THIS.`_prequel_m.`closeModule(`module)
    return TRUE

  METHOD getSourceCode(`module):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    return THIS.`_prequel_m.`getSourceCode(`module)

  METHOD setSourceCode(`module `source_code):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    IF `not(`lexer.`isValidSourceCode(`source_code)):
      THIS.`_error = "INVALID"+" "+"SOURCE"+" "+"CODE"
      return NULL
    ENDIF
    VAR `module_instances = THIS.`_prequel_m.`getModuleInstances(`module)
    IF `length(`module_instances) > 0:
      THIS.`_error = "MODULE"+" "+"HAS"+" "+"INSTANCES"
      return NULL
    ENDIF
    THIS.`_prequel_m.`setSourceCode(`module, `source_code)
    return THIS.`_prequel_m.`getSourceCode(`module)

  METHOD getModuleName(`module):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    return THIS.`_prequel_m.`getModuleName(`module)

  METHOD renameModule(`module `module_name):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    IF `not(`is_type_str(`get_type(`module_name))):
      THIS.`_error = "INVALID"+" "+"MODULE"+" "+"NAME"
      return NULL
    ENDIF
    IF `length(`module_name) == 0:
      THIS.`_error = "EMPTY"+" "+"MODULE"+" "+"NAME"
      return NULL
    ENDIF
    IF `not(`lexer.`isValidModuleName(`module_name)):
      THIS.`_error = "INVALID"+" "+"CHARACTERS"+" "+"IN"+" "+"MODULE"+" "+"NAME"
      return NULL
    ENDIF
    VAR `module_name_lcase = `lowercase(`module_name)
    VAR `old_module_name_lcase = THIS.`_prequel_m.`getModuleNameLcase(`module)
    VAR `j
    VAR `module_name_lcase_j
    IF `module_name_lcase != `old_module_name_lcase:
      FORINCR `j(0 `length(`modules)):
        `module_name_lcase_j = THIS.`_prequel_m.`getModuleNameLcase(`modules[`j])
        IF `module_name_lcase_j > `module_name_lcase:
          break
        ENDIF
        IF `module_name_lcase_j == `module_name_lcase:
          THIS.`_error = "DUPLICATE"+" "+"MODULE"+" "+"NAME"
          return NULL
        ENDIF
      ENDFOR
    ENDIF
    THIS.`_prequel_m.`renameModule(`module, `module_name)
    return TRUE

  METHOD getLnnoCount(`module):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    return THIS.`_prequel_m.`getLnnoCount(`module)

  METHOD getTokens(`module `lnno):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    IF `not(`is_type_num(`get_type(`lnno))) OR (`lnno != `trunc(`lnno)) OR (`lnno < 0):
      THIS.`_error = "INVALID"+" "+"LNNO"
      return NULL
    ENDIF
    VAR `lnno_count = THIS.`_prequel_m.`getLnnoCount(`module)
    IF `lnno >= `lnno_count:
      THIS.`_error = "INVALID"+" "+"LNNO"
      return NULL
    ENDIF
    VAR `raw_tokens = THIS.`_prequel_m.`getTokens(`module, `lnno)
    VAR `tokens = []
    VAR `j
    VAR `token_str
    VAR `token_value
    VAR `token_extra
    VAR `indexof_csvar
    FORINCR `j(0 `length(`raw_tokens)-1):
      `token_str = `lexer.`tokenIdToString(`lexer.`tokenId(`raw_tokens[`j]))
      `token_value = `lexer.`tokenValue(`raw_tokens[`j])
      IF `lexer.`isCompoundToken(`token_str):
        `token_extra = `lexer.`tokenExtra(`raw_tokens[`j])
        IF `token_extra[0] == "!":
          `push(`tokens, ["CSVAR", `substring(`token_value, 0, `length(`token_extra))])
        ELSIF `indexof(`token_extra, ".") >= 0:
          `push(`tokens, ["QUALVAR", `substring(`token_value, 0, `length(`token_extra))])
        ELSE:
          `push(`tokens, ["VAR", `substring(`token_value, 0, `length(`token_extra))])
        ENDIF
        `push(`tokens, [`token_str, "."+`substring(`token_value, `length(`token_value)-`length(`token_str), `length(`token_value))])
      ELSE:
        `push(`tokens, [`token_str, `token_value])
      ENDIF
    ENDFOR
    return `tokens

  METHOD getParserError(`module):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    VAR `parser_error_info = THIS.`_prequel_m.`getParserError(`module)
    VAR `parser_error = {}
    VAR `entry_lnno
    IF `not(`isnull(`parser_error_info)):
      `parser_error["lnno"] = `parser_error_info[1]
      `parser_error["startcol"] = `parser_error_info[2]
      `parser_error["endcol"] = `parser_error_info[3]
      `parser_error["error_message"] = `parser_error_info[4]
    ELSE:
      IF `not(THIS.`_prequel_m.`isCompiled(`module)):
        THIS.`_prequel_m.`compile(`module)
      ENDIF
      `entry_lnno = THIS.`_prequel_m.`getEntryLnno(`module)
      IF `entry_lnno < 0:
        `parser_error["lnno"] = -1
        `parser_error["startcol"] = -1
        `parser_error["endcol"] = -1
        `parser_error["error_message"] = "NO"+" "+"INSTRUCTION"+" "+"FOUND"
      ELSE:
        `parser_error["error_message"] = ""
      ENDIF
    ENDIF
    return `parser_error

  METHOD getEntryLnno(`module):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    VAR `parser_error = THIS.`_prequel_m.`getParserError(`module)
    IF `not(`isnull(`parser_error)):
      THIS.`_error = "PARSER"+" "+"ERROR"
      return NULL
    ENDIF
    IF `not(THIS.`_prequel_m.`isCompiled(`module)):
      THIS.`_prequel_m.`compile(`module)
    ENDIF
    VAR `entry_lnno = THIS.`_prequel_m.`getEntryLnno(`module)
    IF `entry_lnno < 0:
      THIS.`_error = "PARSER"+" "+"ERROR"
      return NULL
    ENDIF
    return `entry_lnno

  METHOD hasBreakpoint(`module `lnno):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    IF `not(`is_type_num(`get_type(`lnno))) OR (`lnno != `trunc(`lnno)) OR (`lnno < 0):
      THIS.`_error = "INVALID"+" "+"LNNO"
      return NULL
    ENDIF
    VAR `lnno_count = THIS.`_prequel_m.`getLnnoCount(`module)
    IF `lnno >= `lnno_count:
      THIS.`_error = "INVALID"+" "+"LNNO"
      return NULL
    ENDIF
    return THIS.`_prequel_m.`hasBreakpoint(`module, `lnno)

  METHOD setBreakpoint(`module `lnno):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    IF `not(`is_type_num(`get_type(`lnno))) OR (`lnno != `trunc(`lnno)) OR (`lnno < 0):
      THIS.`_error = "INVALID"+" "+"LNNO"
      return NULL
    ENDIF
    VAR `lnno_count = THIS.`_prequel_m.`getLnnoCount(`module)
    IF `lnno >= `lnno_count:
      THIS.`_error = "INVALID"+" "+"LNNO"
      return NULL
    ENDIF
    THIS.`_prequel_m.`setBreakpoint(`module, `lnno)
    return TRUE

  METHOD clearBreakpoint(`module `lnno):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    IF `not(`is_type_num(`get_type(`lnno))) OR (`lnno != `trunc(`lnno)) OR (`lnno < 0):
      THIS.`_error = "INVALID"+" "+"LNNO"
      return NULL
    ENDIF
    VAR `lnno_count = THIS.`_prequel_m.`getLnnoCount(`module)
    IF `lnno >= `lnno_count:
      THIS.`_error = "INVALID"+" "+"LNNO"
      return NULL
    ENDIF
    THIS.`_prequel_m.`clearBreakpoint(`module, `lnno)
    return TRUE

  METHOD getEnvs():
    return `utils.`deepCopy(THIS.`_prequel_m.`getEnvs())

  METHOD createEnv():
    return THIS.`_prequel_m.`createEnv()

  METHOD deleteEnv(`env):
    VAR `envs = THIS.`_prequel_m.`getEnvs()
    IF `indexof(`envs, `env) < 0:
      THIS.`_error = "INVALID"+" "+"ENV"
      return NULL
    ENDIF
    VAR `env_instances = THIS.`_prequel_m.`getEnvInstances(`env)
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `not(`isnull(`running_instance)) AND (`indexof(`env_instances, `running_instance) >= 0):
      THIS.`_error = "ENV"+" "+"IN"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    THIS.`_prequel_m.`deleteEnv(`env)
    return TRUE

  METHOD getModuleInstances(`module):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    return `utils.`deepCopy(THIS.`_prequel_m.`getModuleInstances(`module))

  METHOD addInstance(`module):
    VAR `modules = THIS.`_prequel_m.`getModules()
    IF `indexof(`modules, `module) < 0:
      THIS.`_error = "INVALID"+" "+"MODULE"
      return NULL
    ENDIF
    VAR `parser_error = THIS.`_prequel_m.`getParserError(`module)
    IF `not(`isnull(`parser_error)):
      THIS.`_error = "PARSER"+" "+"ERROR"
      return NULL
    ENDIF
    IF `not(THIS.`_prequel_m.`isCompiled(`module)):
      THIS.`_prequel_m.`compile(`module)
    ENDIF
    VAR `entry_lnno = THIS.`_prequel_m.`getEntryLnno(`module)
    IF `entry_lnno < 0:
      THIS.`_error = "PARSER"+" "+"ERROR"
      return NULL
    ENDIF
    VAR `instance = THIS.`_prequel_m.`addInstance(`module)
    return `instance

  METHOD cloneInstance(`instance):
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `running_instance == `instance:
      THIS.`_error = "RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `instance_state = THIS.`_prequel_m.`getInstanceState(`instance)
    IF `instance_state != `INTERP_STATE_READY:
      THIS.`_error = "ACTIVE"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `cloned_instance = THIS.`_prequel_m.`cloneInstance(`instance)
    return `cloned_instance

  METHOD removeInstance(`instance):
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `running_instance == `instance:
      THIS.`_error = "RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `instance_state = THIS.`_prequel_m.`getInstanceState(`instance)
    IF `instance_state != `INTERP_STATE_READY:
      THIS.`_error = "ACTIVE"+" "+"INSTANCE"
      return NULL
    ENDIF
    THIS.`_prequel_m.`removeInstance(`instance)
    return TRUE

  METHOD getInstanceEnvs(`instance):
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    return `utils.`deepCopy(THIS.`_prequel_m.`getInstanceEnvs(`instance))

  METHOD pushEnv(`instance `env):
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `envs = THIS.`_prequel_m.`getEnvs()
    IF `indexof(`envs, `env) < 0:
      THIS.`_error = "INVALID"+" "+"ENV"
      return NULL
    ENDIF
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `running_instance == `instance:
      THIS.`_error = "RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    THIS.`_prequel_m.`pushEnv(`instance, `env)
    return TRUE

  METHOD removeEnv(`instance `env):
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `envs = THIS.`_prequel_m.`getEnvs()
    IF `indexof(`envs, `env) < 0:
      THIS.`_error = "INVALID"+" "+"ENV"
      return NULL
    ENDIF
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `running_instance == `instance:
      THIS.`_error = "RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    THIS.`_prequel_m.`removeEnv(`instance, `env)
    return TRUE

  METHOD getVarNames(`env):
    VAR `envs = THIS.`_prequel_m.`getEnvs()
    IF `indexof(`envs, `env) < 0:
      THIS.`_error = "INVALID"+" "+"ENV"
      return NULL
    ENDIF
    return `utils.`deepCopy(THIS.`_prequel_m.`getVarNames(`env))

  METHOD addVar(`env `varname `varvalue):
    VAR `envs = THIS.`_prequel_m.`getEnvs()
    IF `indexof(`envs, `env) < 0:
      THIS.`_error = "INVALID"+" "+"ENV"
      return NULL
    ENDIF
    VAR `env_instances = THIS.`_prequel_m.`getEnvInstances(`env)
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `not(`isnull(`running_instance)) AND (`indexof(`env_instances, `running_instance) >= 0):
      THIS.`_error = "ENV"+" "+"IN"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    IF `not(`lexer.`isValidVarname(`varname)):
      THIS.`_error = "INVALID"+" "+"VARNAME"
      return NULL
    ENDIF
    VAR `varnames = THIS.`_prequel_m.`getVarNames(`env)
    IF `indexof(`varnames, `varname) >= 0:
      THIS.`_error = "DUPLICATE"+" "+"VARNAME"
      return NULL
    ENDIF
    VAR `procnames = THIS.`_prequel_m.`getProcedureNames(`env)
    IF `indexof(`procnames, `varname) >= 0:
      THIS.`_error = "PROCEDURE"+" "+"NAMED"+" "+"VARNAME"+" "+"ALREADY"+" "+"EXISTS"
      return NULL
    ENDIF
    VAR `evalue = `utils.`encodeData(`varvalue)
    IF `isnull(`evalue):
      THIS.`_error = "INVALID"+" "+"VARVALUE"
      return NULL
    ENDIF
    THIS.`_prequel_m.`addVar(`env, `varname, `evalue)
    return TRUE

  METHOD overwriteVar(`env `varname `varvalue):
    VAR `envs = THIS.`_prequel_m.`getEnvs()
    IF `indexof(`envs, `env) < 0:
      THIS.`_error = "INVALID"+" "+"ENV"
      return NULL
    ENDIF
    VAR `env_instances = THIS.`_prequel_m.`getEnvInstances(`env)
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `not(`isnull(`running_instance)) AND (`indexof(`env_instances, `running_instance) >= 0):
      THIS.`_error = "ENV"+" "+"IN"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `varnames = THIS.`_prequel_m.`getVarNames(`env)
    VAR `procnames
    VAR `evalue
    IF `indexof(`varnames, `varname) < 0:
      IF `not(`lexer.`isValidVarname(`varname)):
        THIS.`_error = "INVALID"+" "+"VARNAME"
        return NULL
      ENDIF
      `procnames = THIS.`_prequel_m.`getProcedureNames(`env)
      IF `indexof(`procnames, `varname) >= 0:
        THIS.`_error = "PROCEDURE"+" "+"NAMED"+" "+"VARNAME"+" "+"ALREADY"+" "+"EXISTS"
        return NULL
      ENDIF
      `evalue = `utils.`encodeData(`varvalue)
      IF `isnull(`evalue):
        THIS.`_error = "INVALID"+" "+"VARVALUE"
        return NULL
      ENDIF
      THIS.`_prequel_m.`addVar(`env, `varname, `evalue)
      return TRUE
    ENDIF
    IF `not(THIS.`_prequel_m.`overwriteVar(`env, `varname, `varvalue)):
      THIS.`_error = "INVALID"+" "+"VARVALUE"
      return NULL
    ENDIF
    return TRUE

  METHOD getVar(`env `varname):
    VAR `envs = THIS.`_prequel_m.`getEnvs()
    IF `indexof(`envs, `env) < 0:
      THIS.`_error = "INVALID"+" "+"ENV"
      return NULL
    ENDIF
    VAR `varnames = THIS.`_prequel_m.`getVarNames(`env)
    IF `indexof(`varnames, `varname) < 0:
      IF `not(`lexer.`isValidVarname(`varname)):
        THIS.`_error = "INVALID"+" "+"VARNAME"
        return NULL
      ENDIF
      return ""
    ENDIF
    VAR `evalue = THIS.`_prequel_m.`getVar(`env, `varname)
    VAR `varvalue = `utils.`decodeData(`evalue)
    IF `isnull(`varvalue):
      THIS.`_error = "INVALID"+" "+"VARVALUE"
      return NULL
    ENDIF
    return `varvalue[1]

  METHOD removeVar(`env `varname):
    VAR `envs = THIS.`_prequel_m.`getEnvs()
    IF `indexof(`envs, `env) < 0:
      THIS.`_error = "INVALID"+" "+"ENV"
      return NULL
    ENDIF
    VAR `env_instances = THIS.`_prequel_m.`getEnvInstances(`env)
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `not(`isnull(`running_instance)) AND (`indexof(`env_instances, `running_instance) >= 0) AND `isnull(THIS.`_prequel_m.`getStatusCode(`running_instance)):
      THIS.`_error = "ENV"+" "+"IN"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `varnames = THIS.`_prequel_m.`getVarNames(`env)
    IF `indexof(`varnames, `varname) < 0:
      IF `not(`lexer.`isValidVarname(`varname)):
        THIS.`_error = "INVALID"+" "+"VARNAME"
        return NULL
      ENDIF
      THIS.`_error = "UNKNOWN"+" "+"VARNAME"
      return NULL
    ENDIF
    THIS.`_prequel_m.`removeVar(`env, `varname)
    return TRUE

  METHOD getProcedureNames(`env):
    VAR `envs = THIS.`_prequel_m.`getEnvs()
    IF `indexof(`envs, `env) < 0:
      THIS.`_error = "INVALID"+" "+"ENV"
      return NULL
    ENDIF
    return `utils.`deepCopy(THIS.`_prequel_m.`getProcedureNames(`env))

  METHOD addProcedure(`env `procname `args_synopsis):
    VAR `envs = THIS.`_prequel_m.`getEnvs()
    IF `indexof(`envs, `env) < 0:
      THIS.`_error = "INVALID"+" "+"ENV"
      return NULL
    ENDIF
    VAR `env_instances = THIS.`_prequel_m.`getEnvInstances(`env)
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `not(`isnull(`running_instance)) AND (`indexof(`env_instances, `running_instance) >= 0):
      THIS.`_error = "ENV"+" "+"IN"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    IF `not(`lexer.`isValidVarname(`procname)) AND (`procname != "CALL") AND (`procname != "RETURN"):
      THIS.`_error = "INVALID"+" "+"PROCNAME"
      return NULL
    ENDIF
    VAR `procnames = THIS.`_prequel_m.`getProcedureNames(`env)
    IF `indexof(`procnames, `procname) >= 0:
      THIS.`_error = "DUPLICATE"+" "+"PROCNAME"
      return NULL
    ENDIF
    VAR `varnames = THIS.`_prequel_m.`getVarNames(`env)
    IF `indexof(`varnames, `procname) >= 0:
      THIS.`_error = "VAR"+" "+"NAMED"+" "+"PROCNAME"+" "+"ALREADY"+" "+"EXISTS"
      return NULL
    ENDIF
    VAR `evalue = `utils.`encodeProcedure(`args_synopsis)
    IF `isnull(`evalue):
      THIS.`_error = "INVALID"+" "+"ARGS"+" "+"SYNOPSIS"
      return NULL
    ENDIF
    THIS.`_prequel_m.`addProcedure(`env, `procname, `evalue)
    return TRUE

  METHOD existsProcedure(`env `procname):
    VAR `envs = THIS.`_prequel_m.`getEnvs()
    IF `indexof(`envs, `env) < 0:
      THIS.`_error = "INVALID"+" "+"ENV"
      return NULL
    ENDIF
    VAR `procnames = THIS.`_prequel_m.`getProcedureNames(`env)
    IF `indexof(`procnames, `procname) < 0:
      IF `not(`lexer.`isValidVarname(`procname)) AND (`procname != "CALL") AND (`procname != "RETURN"):
        THIS.`_error = "INVALID"+" "+"PROCNAME"
        return NULL
      ENDIF
      return FALSE
    ENDIF
    return TRUE

  METHOD removeProcedure(`env `procname):
    VAR `envs = THIS.`_prequel_m.`getEnvs()
    IF `indexof(`envs, `env) < 0:
      THIS.`_error = "INVALID"+" "+"ENV"
      return NULL
    ENDIF
    VAR `env_instances = THIS.`_prequel_m.`getEnvInstances(`env)
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `not(`isnull(`running_instance)) AND (`indexof(`env_instances, `running_instance) >= 0):
      THIS.`_error = "ENV"+" "+"IN"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `procnames = THIS.`_prequel_m.`getProcedureNames(`env)
    IF `indexof(`procnames, `procname) < 0:
      IF `not(`lexer.`isValidVarname(`procname)) AND (`procname != "CALL") AND (`procname != "RETURN"):
        THIS.`_error = "INVALID"+" "+"PROCNAME"
        return NULL
      ENDIF
      THIS.`_error = "UNKNOWN"+" "+"PROCNAME"
      return NULL
    ENDIF
    THIS.`_prequel_m.`removeProcedure(`env, `procname)
    return TRUE

  METHOD getInstanceVarNames(`instance):
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    return `utils.`deepCopy(THIS.`_prequel_m.`getInstanceVarNames(`instance))

  METHOD existsInstanceVar(`instance `ivarname):
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      return FALSE
    ENDIF
    VAR `ivarnames = THIS.`_prequel_m.`getInstanceVarNames(`instance)
    return (`indexof(`ivarnames, `ivarname) >= 0)

  METHOD addInstanceVar(`ivarname `ivarvalue):
    VAR `instance = THIS.`_prequel_m.`getRunningInstance()
    IF `isnull(`instance):
      THIS.`_error = "NOT"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    IF `not(`lexer.`isValidIvarname(`ivarname)):
      THIS.`_error = "INVALID"+" "+"IVARNAME"
      return NULL
    ENDIF
    VAR `ivarnames = THIS.`_prequel_m.`getInstanceVarNames(`instance)
    IF `indexof(`ivarnames, `ivarname) >= 0:
      THIS.`_error = "DUPLICATE"+" "+"IVARNAME"
      return NULL
    ENDIF
    VAR `evalue = `utils.`encodeData(`ivarvalue)
    IF `isnull(`evalue):
      THIS.`_error = "INVALID"+" "+"IVARVALUE"
      return NULL
    ENDIF
    THIS.`_prequel_m.`addInstanceVar(`instance, `ivarname, `evalue)
    return TRUE

  METHOD getInstanceVar(`instance `ivarname):
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    IF `not(`lexer.`isValidIvarname(`ivarname)):
      THIS.`_error = "INVALID"+" "+"IVARNAME"
      return NULL
    ENDIF
    VAR `evalue = THIS.`_prequel_m.`getInstanceVar(`instance, `ivarname)
    VAR `ivarvalue
    IF `not(`isnull(`evalue)):
      `ivarvalue = `utils.`decodeData(`evalue)
      IF `isnull(`ivarvalue):
        THIS.`_error = "INVALID"+" "+"IVARVALUE"
        return NULL
      ENDIF
      return `ivarvalue[1]
    ENDIF
    return ""

  METHOD removeInstanceVar(`ivarname):
    VAR `instance = THIS.`_prequel_m.`getRunningInstance()
    IF `isnull(`instance):
      THIS.`_error = "NOT"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `ivarnames = THIS.`_prequel_m.`getInstanceVarNames(`instance)
    IF `indexof(`ivarnames, `ivarname) < 0:
      IF `not(`lexer.`isValidIvarname(`ivarname)):
        THIS.`_error = "INVALID"+" "+"IVARNAME"
        return NULL
      ENDIF
      THIS.`_error = "UNKNOWN"+" "+"IVARNAME"
      return NULL
    ENDIF
    IF THIS.`_prequel_m.`inRepeatVars(`instance, `ivarname) AND `isnull(THIS.`_prequel_m.`getStatusCode(`instance)):
      THIS.`_error = "IVARNAME"+" "+"IN"+" "+"REPEAT"+" "+"VARIABLES"
      return NULL
    ENDIF
    THIS.`_prequel_m.`removeInstanceVar(`instance, `ivarname)
    return TRUE

  METHOD addInstanceCsvar(`csinstance `ivarname `ivarvalue):
    VAR `instance = THIS.`_prequel_m.`getRunningInstance()
    IF `instance == `csinstance:
      return THIS.addInstanceVar(`ivarname, `ivarvalue)
    ENDIF
    IF `isnull(`instance):
      THIS.`_error = "NOT"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    IF `not(`lexer.`isValidIvarname(`ivarname)):
      THIS.`_error = "INVALID"+" "+"IVARNAME"
      return NULL
    ENDIF
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `csinstance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    IF (THIS.`_prequel_m.`getInstanceState(`csinstance) != `INTERP_STATE_YIELD) AND (`csinstance != `instance):
      THIS.`_error = "INSTANCE"+" "+"NOT"+" "+"IN"+" "+"CALLSTACK"
      return NULL
    ENDIF
    VAR `ivarnames = THIS.`_prequel_m.`getInstanceVarNames(`csinstance)
    IF `indexof(`ivarnames, `ivarname) >= 0:
      THIS.`_error = "DUPLICATE"+" "+"IVARNAME"
      return NULL
    ENDIF
    VAR `evalue = `utils.`encodeData(`ivarvalue)
    IF `isnull(`evalue):
      THIS.`_error = "INVALID"+" "+"IVARVALUE"
      return NULL
    ENDIF
    THIS.`_prequel_m.`addInstanceCsvar(`instance, `ivarname, `evalue, `csinstance)
    return TRUE

  METHOD removeInstanceCsvar(`csinstance `ivarname):
    VAR `instance = THIS.`_prequel_m.`getRunningInstance()
    IF `instance == `csinstance:
      return THIS.removeInstanceVar(`ivarname)
    ENDIF
    IF `isnull(`instance):
      THIS.`_error = "NOT"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `csinstance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    IF (THIS.`_prequel_m.`getInstanceState(`csinstance) != `INTERP_STATE_YIELD) AND (`csinstance != `instance):
      THIS.`_error = "INSTANCE"+" "+"NOT"+" "+"IN"+" "+"CALLSTACK"
      return NULL
    ENDIF
    VAR `ivarnames = THIS.`_prequel_m.`getInstanceVarNames(`csinstance)
    IF `indexof(`ivarnames, `ivarname) < 0:
      IF `not(`lexer.`isValidIvarname(`ivarname)):
        THIS.`_error = "INVALID"+" "+"IVARNAME"
        return NULL
      ENDIF
      THIS.`_error = "UNKNOWN"+" "+"IVARNAME"
      return NULL
    ENDIF
    IF THIS.`_prequel_m.`inRepeatVars(`csinstance, `ivarname) AND `isnull(THIS.`_prequel_m.`getStatusCode(`csinstance)):
      THIS.`_error = "IVARNAME"+" "+"IN"+" "+"REPEAT"+" "+"VARIABLES"
      return NULL
    ENDIF
    THIS.`_prequel_m.`removeInstanceCsvar(`instance, `ivarname, `csinstance)
    return TRUE

  METHOD getInstanceState(`instance):
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    return THIS.`_prequel_m.`getInstanceState(`instance)

  METHOD run(`instance `stepping `limits):
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `not(`isnull(`running_instance)):
      THIS.`_error = "ALREADY"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `instance_state = THIS.`_prequel_m.`getInstanceState(`instance)
    IF `instance_state != `INTERP_STATE_READY:
      THIS.`_error = "NOT"+" "+"READY"+" "+"INSTANCE"
      return NULL
    ENDIF
    IF `not(`is_type_bool(`get_type(`stepping))):
      THIS.`_error = "STEPPING"+" "+"IS"+" "+"NOT"+" "+"BOOLEAN"
      return NULL
    ENDIF
    `limits = `utils.`getNormalizedLimits(`limits)
    IF `isnull(`limits):
      THIS.`_error = "INVALID"+" "+"LIMITS"
      return NULL
    ENDIF
    VAR `result_list = THIS.`_prequel_m.`run(`instance, `stepping, `limits)
    `instance_state = `result_list[0]
    VAR `result = {}
    `result["state"] = `instance_state
    `result["count"] = `utils.`setNormalizedLimits(`result_list[1])
    `result["lnno"] = `result_list[2]
    IF `instance_state == `INTERP_STATE_ENDED:
      `result["status_code"] = `result_list[3]
    ELSIF `instance_state == `INTERP_STATE_ERROR:
      `result["error_message"] = `result_list[3]
    ENDIF
    return `result

  METHOD resume(`instance `stepping `limits):
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `not(`isnull(`running_instance)):
      THIS.`_error = "ALREADY"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `instance_state = THIS.`_prequel_m.`getInstanceState(`instance)
    IF (`instance_state < `INTERP_STATE_LIMIT) OR (`instance_state > `INTERP_STATE_YIELD):
      THIS.`_error = "INVALID"+" "+"INSTANCE"+" "+"STATE"
      return NULL
    ENDIF
    IF `not(`is_type_bool(`get_type(`stepping))):
      THIS.`_error = "STEPPING"+" "+"IS"+" "+"NOT"+" "+"BOOLEAN"
      return NULL
    ENDIF
    IF `not(`isnull(`limits)):
      `limits = `utils.`getNormalizedLimits(`limits)
      IF `isnull(`limits):
        THIS.`_error = "INVALID"+" "+"LIMITS"
        return NULL
      ENDIF
    ENDIF
    VAR `result_list = THIS.`_prequel_m.`resume(`instance, `stepping, `limits)
    `instance_state = `result_list[0]
    VAR `result = {}
    `result["state"] = `instance_state
    `result["count"] = `utils.`setNormalizedLimits(`result_list[1])
    `result["lnno"] = `result_list[2]
    IF `instance_state == `INTERP_STATE_ENDED:
      `result["status_code"] = `result_list[3]
    ELSIF `instance_state == `INTERP_STATE_ERROR:
      `result["error_message"] = `result_list[3]
    ENDIF
    return `result

  METHOD reap(`instance):
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `not(`isnull(`running_instance)):
      THIS.`_error = "RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    THIS.`_prequel_m.`reap(`instance)
    return TRUE

  METHOD reset(`instance):
    VAR `running_instance = THIS.`_prequel_m.`getRunningInstance()
    IF `not(`isnull(`running_instance)):
      THIS.`_error = "RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    VAR `instance_state = THIS.`_prequel_m.`getInstanceState(`instance)
    IF `instance_state != `INTERP_STATE_READY:
      THIS.`_error = "NOT"+" "+"READY"+" "+"INSTANCE"
      return NULL
    ENDIF
    THIS.`_prequel_m.`reset(`instance)
    return TRUE

  METHOD returnWithStatus(`status_code):
    VAR `instance = THIS.`_prequel_m.`getRunningInstance()
    IF `isnull(`instance):
      THIS.`_error = "NOT"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    IF `not(`is_type_num(`get_type(`status_code))) OR (`status_code != `trunc(`status_code)) OR (`status_code != `int32(`status_code)):
      THIS.`_error = "INVALID"+" "+"STATUS"+" "+"CODE"
      return NULL
    ENDIF
    THIS.`_prequel_m.`returnWithStatus(`instance, `status_code)
    return TRUE

  METHOD prequelYield():
    VAR `instance = THIS.`_prequel_m.`getRunningInstance()
    IF `isnull(`instance):
      THIS.`_error = "NOT"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    THIS.`_prequel_m.`prequelYield(`instance)
    return TRUE

  METHOD runtimeError(`error_message):
    VAR `instance = THIS.`_prequel_m.`getRunningInstance()
    IF `isnull(`instance):
      THIS.`_error = "NOT"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    IF `not(`utils.`isValidErrorMessage(`error_message)):
      THIS.`_error = "INVALID"+" "+"ERROR"+" "+"MESSAGE"
      return NULL
    ENDIF
    THIS.`_prequel_m.`runtimeError(`instance, `error_message)
    return TRUE

  METHOD readDebugl(`instance):
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    return THIS.`_prequel_m.`readDebugl(`instance)

  METHOD readChangedVars(`instance):
    VAR `instances = THIS.`_prequel_m.`getInstances()
    IF `indexof(`instances, `instance) < 0:
      THIS.`_error = "INVALID"+" "+"INSTANCE"
      return NULL
    ENDIF
    return THIS.`_prequel_m.`readChangedVars(`instance)

  METHOD getRunningModule():
    VAR `instance = THIS.`_prequel_m.`getRunningInstance()
    IF `isnull(`instance):
      THIS.`_error = "NOT"+" "+"RUNNING"+" "+"INSTANCE"
      return NULL
    ENDIF
    return THIS.`_prequel_m.`getInstanceModule(`instance)

  METHOD edAddLine(`module `lnno):
    THIS.`_error = "NOT"+" "+"IMPLEMENTED"
    return NULL

  METHOD edSetLine(`module `lnno `line):
    THIS.`_error = "NOT"+" "+"IMPLEMENTED"
    return NULL

  METHOD edDelLine(`module `lnno):
    THIS.`_error = "NOT"+" "+"IMPLEMENTED"
    return NULL

  METHOD edAddLineAfter(`module `lnno):
    THIS.`_error = "NOT"+" "+"IMPLEMENTED"
    return NULL

  METHOD edCutLine(`module `lnno):
    THIS.`_error = "NOT"+" "+"IMPLEMENTED"
    return NULL

  METHOD edPasteLines(`module `lnno):
    THIS.`_error = "NOT"+" "+"IMPLEMENTED"
    return NULL

  METHOD edIndentLine(`module `lnno):
    THIS.`_error = "NOT"+" "+"IMPLEMENTED"
    return NULL

  METHOD edCanUndo(`module):
    THIS.`_error = "NOT"+" "+"IMPLEMENTED"
    return NULL

  METHOD edCanRedo(`module):
    THIS.`_error = "NOT"+" "+"IMPLEMENTED"
    return NULL

  METHOD edUndo(`module):
    THIS.`_error = "NOT"+" "+"IMPLEMENTED"
    return NULL

  METHOD edRedo(`module):
    THIS.`_error = "NOT"+" "+"IMPLEMENTED"
    return NULL

  METHOD isInstanceStateReady(`instance_state):
    return (`instance_state == `INTERP_STATE_READY)

  METHOD isInstanceStateLimit(`instance_state):
    return (`instance_state == `INTERP_STATE_LIMIT)

  METHOD isInstanceStatePause(`instance_state):
    return (`instance_state == `INTERP_STATE_PAUSE)

  METHOD isInstanceStateYield(`instance_state):
    return (`instance_state == `INTERP_STATE_YIELD)

  METHOD isInstanceStateError(`instance_state):
    return (`instance_state == `INTERP_STATE_ERROR)

  METHOD isInstanceStateEnded(`instance_state):
    return (`instance_state == `INTERP_STATE_ENDED)

  METHOD isArgTypeNumber(`arg):
    IF `not(`utils.`isArgData(`arg)):
      THIS.`_error = "INVALID"+" "+"ARG"
      return NULL
    ENDIF
    return (`arg[0] == `ARG_TYPE_NUMBER)

  METHOD isArgTypeList(`arg):
    IF `not(`utils.`isArgData(`arg)):
      THIS.`_error = "INVALID"+" "+"ARG"
      return NULL
    ENDIF
    return (`arg[0] == `ARG_TYPE_LIST)

  METHOD isArgTypeString(`arg):
    IF `not(`utils.`isArgData(`arg)):
      THIS.`_error = "INVALID"+" "+"ARG"
      return NULL
    ENDIF
    return (`arg[0] == `ARG_TYPE_STRING)

  METHOD isArgTypeVarname(`arg):
    IF `not(`utils.`isArgData(`arg)):
      THIS.`_error = "INVALID"+" "+"ARG"
      return NULL
    ENDIF
    return (`arg[0] == `ARG_TYPE_VARNAME)

  METHOD isArgTypeModname(`arg):
    IF `not(`utils.`isArgData(`arg)):
      THIS.`_error = "INVALID"+" "+"ARG"
      return NULL
    ENDIF
    return (`arg[0] == `ARG_TYPE_MODNAME)

  METHOD getArgValue(`arg):
    IF `not(`utils.`isArgData(`arg)):
      THIS.`_error = "INVALID"+" "+"ARG"
      return NULL
    ENDIF
    return `arg[1]

  METHOD getCostValue(`varvalue):
    VAR `evalue = `utils.`encodeData(`varvalue)
    IF `isnull(`evalue):
      THIS.`_error = "INVALID"+" "+"VARVALUE"
      return NULL
    ENDIF
    VAR `nsize = `utils.`nsizeEvalue(`evalue)
    VAR `lsize = `utils.`lsizeEvalue(`evalue)
    VAR `cost = {}
    `cost["memory"] = `lsize+`nsize
    `cost["memory_n"] = `nsize
    `cost["memory_l"] = `lsize
    return `cost

  METHOD isValidSourceCode(`source_code):
    return `lexer.`isValidSourceCode(`source_code)

  METHOD isValidModuleName(`module_name):
    return `lexer.`isValidModuleName(`module_name)

  METHOD isValidVarname(`varname):
    return `lexer.`isValidVarname(`varname)

  METHOD isValidIvarname(`ivarname):
    return `lexer.`isValidIvarname(`ivarname)

  METHOD readError():
    VAR `error = THIS.`_error
    THIS.`_error = NULL
    return `error

  METHOD clearError():
    THIS.`_error = NULL
    return TRUE

ENDCLASS
